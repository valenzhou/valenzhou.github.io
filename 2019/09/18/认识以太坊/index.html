<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>认识以太坊 | Mr.喵的网络日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="认识以太坊 以太坊不同于比特币,它是一种图灵完备的系统.以太坊能够执行存储在区块链之上的程序的能力，是由被称为EVM的状态机完成的,创建了一个分布式的单体状态世界计算机。 根据图灵的理论，在真正运行合约之前，以太坊实际上无法预先判断一个合约是否会运行终止，或者它需要运行多久，也许这个合约会陷入死循环一直运行。无论是程序中的瑕疵，还是故意为之，智能合约都可能在一个节点试图验证它的时候永远不停地执行下">
<meta name="keywords" content="ETH">
<meta property="og:type" content="article">
<meta property="og:title" content="认识以太坊">
<meta property="og:url" content="http://yoursite.com/2019/09/18/认识以太坊/index.html">
<meta property="og:site_name" content="Mr.喵的网络日志">
<meta property="og:description" content="认识以太坊 以太坊不同于比特币,它是一种图灵完备的系统.以太坊能够执行存储在区块链之上的程序的能力，是由被称为EVM的状态机完成的,创建了一个分布式的单体状态世界计算机。 根据图灵的理论，在真正运行合约之前，以太坊实际上无法预先判断一个合约是否会运行终止，或者它需要运行多久，也许这个合约会陷入死循环一直运行。无论是程序中的瑕疵，还是故意为之，智能合约都可能在一个节点试图验证它的时候永远不停地执行下">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2021-08-30T11:30:52.053Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="认识以太坊">
<meta name="twitter:description" content="认识以太坊 以太坊不同于比特币,它是一种图灵完备的系统.以太坊能够执行存储在区块链之上的程序的能力，是由被称为EVM的状态机完成的,创建了一个分布式的单体状态世界计算机。 根据图灵的理论，在真正运行合约之前，以太坊实际上无法预先判断一个合约是否会运行终止，或者它需要运行多久，也许这个合约会陷入死循环一直运行。无论是程序中的瑕疵，还是故意为之，智能合约都可能在一个节点试图验证它的时候永远不停地执行下">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-认识以太坊" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/categories">Categories</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      认识以太坊
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h1 id="认识以太坊"><a href="#认识以太坊" class="headerlink" title="认识以太坊"></a>认识以太坊</h1><ol>
<li>以太坊不同于比特币,它是一种图灵完备的系统.以太坊能够执行存储在区块链之上的程序的能力，是由被称为EVM的状态机完成的,创建了一个分布式的单体状态世界计算机。</li>
<li>根据图灵的理论，在真正运行合约之前，以太坊实际上无法预先判断一个合约是否会运行终止，或者它需要运行多久，也许这个合约会陷入死循环一直运行。无论是程序中的瑕疵，还是故意为之，智能合约都可能在一个节点试图验证它的时候永远不停地执行下去，这也就造成了一种DDoS攻击的后果。为了应对这个挑战，以太坊引入了名为gas的计量机制。以太坊的货币是 eth,不同于比特币,eth 的总量没有上限,它的最小单位是 wei,1eth 等于 10 的 18 次方 wei.</li>
<li>DAPP 去中心化应用,代表更为广泛的智能合约.它需要一个智能合约和web 用户界面,是一个区中心化的 web 应用程序.</li>
<li>Web3 是一种去中心化的互联网协议.</li>
<li>选择一款以太坊钱包(推荐MetaMask可以运行在 chrome 中),并保管好你的私钥.在交易时矿工会收取一部分手续费,手续费是由矿工决定的.交易完成后可以通过以太坊区块浏览器 查询到.</li>
<li>钱包创建的账户是外部账户,用户掌握私钥.而合约账户掌握智能合约代码,没有私钥,它由代码所控制.合约具有地址,可以接收和发送以太币.合约账户无法启动交易,但合约可以互相调用,对交易做出反应.</li>
<li>以太坊支持多种编程语言,最常用的是Solidity,有以太坊创始人之一Gavin Wood 创立.Solidity 编译器会把代码编译成EVM 字节码然后可以再区块链上的 EVM 中所执行.在次之前需要给合约注册到以太坊链上,需要通过一个特殊的交易，这个交易的目标地址是0x0000000000000000000000000000000000000000,被称为零地址,用来告诉以太坊区块链用户希望通过这样的交易来注册合约.注册成功后合约有了自己的地址.</li>
<li>有人向合约地址发送交易就会触发合约在 EVM 上的执行,交易的本身就是合约函数的输入参数.合约发起的交易称内部转账或消息.</li>
<li>请注意,JavaScript的限制，大于10的17次幂 的数值无法处理,我们需要单独处理.</li>
<li>以太坊协议分别有六种实现,分别是以 rust,pathon,Go,Java,cpp,scala 实现的.开发以太坊并不需要在主网上有运行一个全功能节点,可以再测试网络上的节点完成开发.测试网络节点连接的是一个公共测试区块链.</li>
<li>以太坊客户端的API是一组远程过程调用（RPC）命令，并采用JSON格式编码。这被称为JSON-RPCAPI。最基本的，JSON-RPCAPI作为一个接口，允许程序员编写代码，把以太坊客户端作为进入以太坊网络和区块数据的大门-网关.RPC接口使用8545端口以HTTP协议的方式对外服务。出于安全的目的，在默认情况下对这个端口的访问是受限的，只允许来自本地网络的链接.RPC 接口提供了很多服务,比如“管理钱包中的私钥和以太坊地址。创建、签名并广播交易。通过交易内数据载荷的方式与智能合约交互。浏览并使用DApp。提供外部服务的链接，例如区块浏览器。转换以太币的单位,向浏览器注入一个 web3 实例.移动钱包都属于远程客户端.</li>
<li>不要尝试用编程的方式 创建随机数,使用密码学安全的伪随机数生成器（如CSPRNG），并且使用熵源充足的随机源做种子,可以确保它在密码学上是安全的.</li>
<li>椭圆曲线程序库, openSSL和libsecp256k1(bitcoinCore).</li>
<li>加密哈希函数是一种单向的哈希函数，可以将任意长度的数据映射为固定长度的比特序列。这种“单向性”意味着，如果我们只知道哈希函数的输出值，还原出输入数据在计算上是不可能的。以太坊使用的哈希算法是Keccak-256(爱德华斯诺登爆出美国国家安全部门在该算法的随机数生成器中留有后门), 可能会更改为FIPS-202 SHA-3. 不同于比特币,以太坊的地址没有校验信息,在交易时注意地址是否正确.EIP55 提案增加了校验,但只有支持 EIP55 的钱包才能使用.</li>
<li>以太坊的交易信息中有一个 nonce值,它是一个记数器,如果同时发起多笔交易,矿工是以任意顺序接收交易的,交易信息中有 nonce 的比没有 nonce 值的交易优先级要高.如果你按顺序创建了一系列交易，但其中一个没有得到确认，那么之后的所有交易都会“堵”住，等待这个缺失的交易。如果某个 nonce 的值不对或者没有足够的 gas,交易都会被堵住.</li>
<li>交易信息中还包含 gas 和 gasLimit 这两个信息,gas 不是以太币,但它跟以太币有汇率关系会上下波动.gas 是用来支付给矿工的手续费,高额的 gas 可以让你的交易快速完成.gasLimit 是付款人为了完成交易愿意付出的最大 gas 量.由于每次调用合约,合约的计算量会根据代码决定,为了应对突发状况,你需要多付出一些 gas.以太坊没有找零机制.</li>
<li>向一个错误的地址 发送交易会导致 eth 被销毁(进入黑洞),因为错误的地址没有私钥,无法完成签名去使用它.</li>
<li>交易的核心数据是 value 和 data 两个字段,他们都可以为空.接收者为外部账户,不管对方是否存在该金额都会转移到接收地址.如果接收者是合约地址,就会执行 EVM 合约,data为空时执行合约的回退函数.data 有内容时,data字段的内容会被EVM解读为针对合约的函数调用，调用data中指定的函数，并把需要的参数传递给这个函数。</li>
<li>一但被部署之后,智能合约就不能被更改,更改的唯一方式就是部署一个新的合约实例.但合约实例可以被删除,当把合约地址和内部存储信息清空之后合约就成了一个空地址,系统会提供 gas 退款,用来激励大家释放资源.需要注意，只有合约的开发者在代码中编写了对应的删除功能，SELFDESTRUCT字节码才会起作用。否则无法删除合约实例.</li>
<li>智能合约为程序员设定了一个很高的门槛：如果有bug，可能会损失大量的金钱。因此，编写智能合约就需要极力避免任何可能的副作用。</li>
<li>gas的费用由交易的发起方支付，因此我们需要避免调用那些可能引发高额gas的合约或者函数。程序员的最佳策略就是设法避免合约可能产生的 gas 消耗.比如避免对动态数组所执行的循环操作,避免调用未知的合约.</li>
<li>Vyper是在以太坊虚拟机上执行的、面向合约的实验性编程语言，旨在提供更好的可审计性，并帮助程序员更轻松地完成清晰易懂的代码.OpenZeppelin项目完成了一项伟大的工作，它为以太坊社区构建并审计了很多安全的库合约,可以避免漏洞.</li>
<li>有很多可重用的代码可以供我们编写自己的合约，包括已经部署到链上的可调用合约以及可以作为代码模板使用的库合约代码.有OpenZeppelin 和 zeppelinOS 等</li>
<li>ERC20 标准是在以太坊上构建代币的标准.工具型代币是指用来支付某个服务、应用或资源的代币,比如 gas。权益型代币可以被设定为没有投票权的，用来分红和分配利润的代币，也可以承载一个去中心化自治组织的投票权，这类组织的管理由持有代币的所有人共同投票决定.</li>
<li>ERC 合约必须实现如下函数和事件,总发行量 totalSupply,balanceOf 余额,transfer 转账,transform 转账信息,approve 审核,allowance配额,Transfer 转账事件,Approval 审核事件,name 名称,其他的都是可选函数.symbol 符号等.</li>
<li>ERC20支持两种转账。第一种是单一式转账，直接使用transfer函数。这个流程被钱包软件用来发送代币给其他地址。大多数的代币转账都是通过transfer函数完成的。第二种方式是使用了approve和transferFrom的两步式交易。这个流程允许代币的持有人授权其他地址操纵他们的代币。这通常用于授权给某一个合约地址，进行代币的分发，但也可以用于交易所的场景。</li>
<li>以太币是使用带有目标接受人地址的交易进行转账的，而代币的转账是通过代币合约内相关的状态转换进行的，使用合约作为地址，而不是接收方的地址。代币合约跟踪余额并发出事件。在代币的转账过程中，并没有任何针对接收方地址的交易。接收方的地址被加入代币合约的余额映射表中。即使是支持ERC20代币的钱包软件，也不会自动发现对应地址上的代币余额变化，触发用户主动把某个代币合约添加到钱包的关注列表。大多数ERC20代币都像是垃圾邮件一般毫无价值。</li>
<li>以太币使用send函数发送，任何合约中的可支付函数或者外部账户都可以接收以太币。代币使用transfer或approve&amp;transferFrom函数发送，这些函数只存在于创建这个代币的合约中.并不会触发接收方合约中的任何可支付函数。</li>
<li>预言机（oracle），它是可以为以太坊智能合约提供外部数据源的系统。为了保持共识，EVM的执行过程必须完全确定，并且仅基于以太坊状态和签名交易的共享上下文。这产生了两个特别重要的后果：一个是EVM和智能合约没有内在的随机性来源；另一个是外部数据只能作为交易的数据载荷引入。我们可以引入外部信息，包括随机性、价格信息、天气预报等，作为发送到网络的交易的数据部分。但是，这些数据本身无法信任，因为它的来源无法核实。我们使用预言机尝试解决这个问题.理想状态下预言机可以无信任的获取外部信息,用于智能合约,还可以把信息安全的中继到 dapp 前端.</li>
<li>预言机的设计模式: 所有的预言机都提供了一些关键功能。这些能力包括：从链外的数据源收集数据。使用签名消息在链上传输数据。将数据放入智能合约的存储空间，使数据可用。其他智能合约再调用预言机智能合约的检索功能来访问它.预言机的三种主要方式可以分为请求与响应、发布与订阅和立即读取。数据证明:让链外方法可以证明返回数据的完整性是非常关键的。两种常见的数据认证方法是真实性证明以及可信执行环境,上面列举出的所有机制描述的都是中心化的预言机系统，都需要依赖可信的权威。</li>
<li>去中心化预言机可以用于保证数据可得性，还可搭配链上数据汇总系统创建独立数据提供者网络。比如 chainLink,它分为三部分分别是声誉合约、订单匹配合约、数据汇总合约.</li>
<li>DAPP 通常是指具有 web 前端的智能合约.Dapp 的后端部署在区块链上,无法篡改.因为在智能合约中执行计算非常昂贵,所以应该让它尽量小.当需要计算量特别大时,一般选做外部计算或使用外部数据源.但前提是你的用户必须信任这些外部源.Dapp 的前端与传统前端并无不同,通过 web3.js 连接以太坊.</li>
<li>不仅是计算,储存数据也通常储存在链下.可以是中心化的数据存储平台,也可以说去中心化数据存储平台IPFS和以太坊自有平台 Swarm.星际文件系统（IPFS）是一个去中心化的、内容可寻址的存储系统，它可以在P2P网络中分配存储的对象。Swarm是另外一个内容可寻址的、类似于IPFS的P2P存储系统。</li>
<li>任何应用都会包含的重要组件是进程之间的通信。传统情况下，这可以通过依赖中心化的服务器进行。但是，也有许多基于P2P网络的替代方案。对DApp来说，最值得关注的P2P消息协议是Whisper.</li>
<li>一些DApp可能设置一个或者多个具有特殊功能的特权账户，如终止DApp合约，覆盖或者更改合约配置，甚至“否决”某些操作。通常，在DApp中引入这些治理功能是为了避免某些未知的问题而引起的bug。在构建一个DApp时，你必须决定是让其完全独立，一旦部署之后就无法被控制，还是创建一个特权账户，承受受到攻击的风险。任何一种选择都会带来风险，但是长远来看，真正的DApp不应该存在能进行特权访问的特权账户，因为这不是去中心化。</li>
<li>以太坊名称服务:ENS不仅仅是一个智能合约，它本身是一个基础的DApp，提供去中心化的名称服务。是以太坊的域名(DNS服务商 ,域名是.eth,它通过一个拍卖系统被分发，并且没有保留列表或者优先级，获得名称的唯一办法就是使用该系统。ENS的顶层是另一个超级简单的合约，目的只有一个：持有资金。如果所有者不再需要这个名称，他们可以将其卖给系统并拿回他们的以太币(资金只能转给所有者).这种方法大大降低了因为bug引起的攻击而给资金带来的风险。</li>
<li>以太坊虚拟机 EVM 用来处理智能合约的部署和执行.EVM有一个基于栈的架构，在一个栈中保存了所有内存数值 。EVM的数据处理单位被定义为256位的“字”（这主要是为了方便处理哈希运算和椭圆曲线运算操作），并且它还具有以下数据组件:一个不可变的程序代码存储区ROM，加载了要执行的智能合约字节码。一个内容可变的内存，它被严格地初始化为全0数值。一个永久的存储，它是作为以太坊状态的一部分存在的，也会被初始化为全0.它仅仅是一个计算引擎，仅提供对计算和存储的抽象，就像Java虚拟机（JVM）那样。从高级视角来看，JVM的设计提供了一个无须知晓底层宿主OS或硬件的运行环境，从而提供了跨不同系统平台的兼容性.EVM 的执行顺序由以太坊发起的交易决定,就像是 js 中的单线程.</li>
<li>EVM既没有任何“系统接口”，也没有“硬件支持”，因为并没有任何物理机器需要与之交互。以太坊世界计算机是完全虚拟化的。EVM 的任务是基于以太坊协议、根据智能合约代码的执行来计算合法的状态转换，用以更新以太坊的状态。</li>
<li>由于停机问题，以太坊世界计算机就有了一个被程序要求永远执行下去的风险。这可能是由于某些意外情况或者恶意的目的。不过在有了gas之后，也就有了一个解决方案：如果在一个预先指定的最大计算量被用尽的时候计算还没有结束，那么所有处理都会无条件地停止。这个限制并不是固定的，你可以通过支付费用来将它提高到最大值.</li>
<li>与比特币协议中仅仅以交易数据的字节大小来计算交易费不同，以太坊协议中计算交易费Gas时需要计量由交易和智能合约代码执行所引发的所有计算步骤。比如相加两个数值需要消耗3 gas,发送一个交易需要消耗21000 gas.Gas 是以太币和矿工奖励之间的缓冲,增加攻击者的攻击成本.如果智能合约执行完成,gas 作为交易费给矿工,矿工费= 合约实际消费的gas * gas 的价格(与以太币的汇率)最后得到一笔以太币,交易剩余的 gas 兑换成以太币返还. 交易未成功的话也需要支付交易费,因为矿工为发生错误的操作执行了计算.</li>
<li>在一个敌意环伺、没有中心化控制者的分布式网络中达成共识的能力是所有开放性公有区块链的核心。比如工作量证明POW是支撑比特币的最重要的发明,奖励只是工具,它的目的是保护比特币系统的安全和去中心化.PoW共识意味着一套风险与收益的细致权衡，驱动着参与者出于自利而遵循共识规则行动。</li>
<li>POW 提出之前就已经出现了权益证明共识 POS.以太坊也正在由 pow 逐渐向 pos 过渡.PoS算法的运作流程大体如下: 持有以太币的人会有投票权,但是需要质押自己的资产充作保证金,投票的权重和保证金成正比,投票的区块通过则按比例获取奖励,不通过则失去保证金.另外还有一种 DPOS 它是分布式的 POS.</li>
<li>POW 的币种都要考虑有 ASIC 矿机造成的算力集中,GPU短缺,电力浪费等问题.</li>
<li>THE DAO 去中心化的自治组织,在ICO众筹自己发行的代币 DAO 时遭到黑客攻击,损失了 360 万 ETH. 以太坊社区针对是否回滚发生争议,硬分叉为 ETC(不回滚) 和 ETH (回滚)两条链.根据社区投票,ETH 为客户端默认选择.</li>
<li>Truffle框架由若干个Node.js包构成。用来开发以太坊智能合约.相似的框架还有 embark和 OpenZeppelin,zeppelinOS.web3 提供了与以太坊连接的接口.Ganache 提供了一个本地测试区块链用来测试智能合约.</li>
<li>以太坊共包含流程,从下往上分别是 数据层(区块和区块链),网络层(p2p),共识层(pow/pos),激励层(挖矿和 gas),合约层(EVM 和智能合约),应用层(DAPP,钱包)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2019/09/18/认识以太坊/" class="article-date">
  <time datetime="2019-09-18T11:29:39.000Z" itemprop="datePublished">2019-09-18</time>
</a>

        </li>
        
          <li>
            <span class="label">Category:</span>
            
  <div class="article-category">
    <a class="article-category-link" href="/categories/ETH/">ETH</a>
  </div>


          </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ETH/">ETH</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2020/04/11/solidity 区块链编程入门/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          solidity 区块链编程入门
        
      </div>
    </a>
  
  
    <a href="/2019/08/30/认识比特币/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">认识比特币</div>
    </a>
  
</nav>


  
</article>






      </div>
      
    <footer id="footer" class="post-footer footer">
      
        <ul class="footer-links">
          
            <li><a href="/archives/"><span class="fa fa-book"></span></a></li>
          
            <li><a href="https://github.com/valenzhou"><span class="fa fa-github-alt"></span></a></li>
          
            <li><a href="https://www.facebook.com/valen.zhou"><span class="fa fa-facebook"></span></a></li>
          
            <li><a href="https://twitter.com/valenzhou/"><span class="fa fa-twitter"></span></a></li>
          
            <li><a href="https://plus.google.com/"><span class="fa fa-google-plus"></span></a></li>
          
            <li><a href="https://www.google.com/"><span class="fa fa-globe"></span></a></li>
          
            <li><a href="/atom.xml"><span class="fa fa-rss"></span></a></li>
          
        </ul>
	    
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>ipsum dolor sit amet, <strong>consectetur adipiscing elit.</strong> Fusce eget urna vitae velit <em>eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque</em> penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Post</p>


      </div>
    </footer>

      



<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
