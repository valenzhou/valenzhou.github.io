<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.喵的网络日志</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-13T07:42:01.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ValenZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习CSS Grid布局</title>
    <link href="http://yoursite.com/2017/12/13/%E5%AD%A6%E4%B9%A0CSS-Grid%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2017/12/13/学习CSS-Grid布局/</id>
    <published>2017-12-13T07:39:20.000Z</published>
    <updated>2017-12-13T07:42:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CSS Grid 布局是CSS中最强大的布局系统,与flexbox的一维布局系统不同,CSS Grid是一个二维布局系统,它可以同时处理行和列.</p></blockquote><h3 id="第一个Grid布局"><a href="#第一个Grid布局" class="headerlink" title="第一个Grid布局"></a>第一个Grid布局</h3><p>css Grid布局由两个核心组成部分,warpper(父元素)和items(子元素).warpper是实际的grid(网格),items是网格的内容.</p><p>下面是一个warpper元素,内部包含了6个items:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"warpper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要把warpper元素变成一个grid(网格),只需要把它的<code>display</code>属性设置为<code>grid</code>即可.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warpper</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们还没有写任何样式,他会简单的将6个div堆叠在一起.</p><h3 id="Columns-列-和rows-行"><a href="#Columns-列-和rows-行" class="headerlink" title="Columns(列)和rows(行)"></a>Columns(列)和rows(行)</h3><p>为了使其成为二维的网格容器,我们需要定义行和列.让我们创建两行三列,使用<code>grid-template-cloumns</code>和<code>grid-template-rows</code>属性.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warpper</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">grid-template-cloumns</span>: <span class="number">100px</span> <span class="number">80px</span> <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为<code>grid-template-cloumns</code>写入了3个值,这样我们就得到了3列,每列的值代表列的宽度.而<code>grid-template-rows</code>代表行数及行的高度.</p><h3 id="放置items-子元素"><a href="#放置items-子元素" class="headerlink" title="放置items(子元素)"></a>放置items(子元素)</h3><p>为了帮助理解,我们在每个items(子元素)加上单独的class.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"warpper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item5"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item6"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在我们来创建一个 3*3的grid:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warpper</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-cloumns</span>:<span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只在页面上看到3-2的grid,而我们定义的是3-3的grid.这是因为我们只有6个items来填充这个网格.我们我们再追加3个items,name最后一行也会被填满.</p><p>要定位和调整items大小,可以使用grid-cloumn和grid-row属性来设置.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">  <span class="attribute">grid-cloumn-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-cloumn-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的样式表示,我们希望item1占据从第一个网格线开始,到第四条网格线结束.换句话说它将独占一行.而剩下的items都推到了下一行.</p><p>这种形式也可以缩写为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">  <span class="attribute">grid-cloumn</span>: <span class="number">1</span>/<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span>&#123;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>/<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ol><li>网格容器(Grid):应用<code>display:grid</code>的元素,items的直接父级元素.</li><li>网格项(items): 网格容器的直接子元素,后代元素不是.</li><li>网格线(Grid-line):构成网格结构的分界线.</li><li>网格轨道(Grid-Track):两条相邻网格线之间的空间.</li><li>网格单元格(Grid-cell):两个相邻行与相邻列之间的空间.</li><li>网格区域(Grid-Area):四条网格线包围的总空间.</li></ol><h3 id="父元素-网格容器属性"><a href="#父元素-网格容器属性" class="headerlink" title="父元素 网格容器属性"></a>父元素 网格容器属性</h3><h5 id="display"><a href="#display" class="headerlink" title="display"></a>display</h5><p>将元素定义为网格容器,并为其建立新的网格式上下文.</p><ul><li>grid : 生成一个块级网格</li><li>inline-grid: 生成一个内联网格</li><li>subgrid: 嵌套的子网格.</li></ul><p><strong>在网格容器中使用float,clear,column,vertical-align不会产生任何效果.</strong></p><h5 id="grid-template-cloumns-rows"><a href="#grid-template-cloumns-rows" class="headerlink" title="grid-template-cloumns/rows"></a>grid-template-cloumns/rows</h5><p>使用空格分割值列表,用来定义网格的行和列.可以是长度值和百分比,和自动分配(auto)或网格线名称<line-name>.</line-name></p><h5 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h5><p>指定Grid Area名称来定义网格模板.一个<code>.</code>号代表一个空的单元.你可以使用任意数量的<code>.</code>只要这些<code>.</code>之间没有空隙隔开就表示一个个的单元格.</p><ul><li><grid-area-name>:由items的grid-area指定的区域名称</grid-area-name></li><li>.(点号):代表一个空网格单元</li><li>none:不定义网格区域</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>:auto;</span><br><span class="line">  <span class="attribute">grid-template-cloumns</span>:<span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">"header header header"</span></span><br><span class="line">    <span class="string">"main main . sidebar"</span></span><br><span class="line">    <span class="string">"footer footer footer footer"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-a</span>&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>:header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-b</span>&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>:main;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当你命名网格区域后,该区域两端的网格线实际上是自动命名的,如果你的网格区域名字是foo,则起始行网格线和列网格线是foo-statrt,最后的网格线是foo-end.则意味着一个网格线可能有很多名称.</p><h5 id="grid-template"><a href="#grid-template" class="headerlink" title="grid-template"></a>grid-template</h5><p>用于定义<code>grid-template-rows</code>,<code>grid-template-cloumns</code>,和<code>grid-template-areas</code>的缩写.</p><ul><li>none:将所有的属性设置为初始值.</li><li>subgrid:将rows和cloumns设置为subgrid,areas设置为初始值.</li><li><grid-template-rows>/<grid-template-cloumns>:将rows和cloumns设置为特定值,areas为none.</grid-template-cloumns></grid-template-rows></li></ul><h5 id="grid-column-gap-grid-row-gap"><a href="#grid-column-gap-grid-row-gap" class="headerlink" title="grid-column-gap/grid-row-gap"></a>grid-column-gap/grid-row-gap</h5><p>指定网格线的大小,可以把它想象为设置列/行之间间距的宽度.值为长度值.</p><h5 id="grid-gap"><a href="#grid-gap" class="headerlink" title="grid-gap"></a>grid-gap</h5><p>grid-column-gap/grid-row-gap的缩写语法</p><h5 id="justify-items"><a href="#justify-items" class="headerlink" title="justify-items"></a>justify-items</h5><p>网格容器的水平对其方式,这些行为也可以通过items的justify-self属性设置:</p><ul><li>start 左侧对其</li><li>end 右侧对其</li><li>center 居中对齐</li><li>stretch 填满区域宽度</li></ul><h5 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h5><p>网格容器的垂直对齐方式:</p><ul><li>start 顶部对齐</li><li>end 底部对齐</li><li>center 垂直居中</li><li>stretch 填满区域高度</li></ul><h5 id="justify-content-align-content"><a href="#justify-content-align-content" class="headerlink" title="justify-content/align-content"></a>justify-content/align-content</h5><p>有时,网格容器的内容小于整体容器的大小,可以设置内容在容器中的对齐方式.</p><ul><li>start 左对齐</li><li>end 右对齐</li><li>center 居中</li><li>stretch 填充</li><li>space-around 左右两边都有空间,空格之间距离相等</li><li>space-between 左右两边没有空间,空格之间距离相等</li><li>space-evenly 左右和每个空间距离相等</li></ul><h5 id="grid-auto-columns-grid-auto-rows"><a href="#grid-auto-columns-grid-auto-rows" class="headerlink" title="grid-auto-columns/grid-auto-rows"></a>grid-auto-columns/grid-auto-rows</h5><p>指定自动生成隐式网格轨道,但定义行和列自动超出网格范围时,隐式网格轨道创建.值为长度,百分比等等.</p><h5 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h5><p>如果你有一些未明确放置的网格,自动放置算法会自动放置这些项.</p><ul><li>row: 依次填充每行</li><li>column:依次填充每列</li><li>dense: 出现较小的网格项时,尝试填充网格中较早的空缺.但它可能导致你的网格项出现混乱.</li></ul><h3 id="子元素-网格项items属性"><a href="#子元素-网格项items属性" class="headerlink" title="子元素 网格项items属性"></a>子元素 网格项items属性</h3><h5 id="grid-column-start-end"><a href="#grid-column-start-end" class="headerlink" title="grid-column-start/end"></a>grid-column-start/end</h5><p>通过指定网格线来确定网格在容器中的列的起始位置</p><h5 id="grid-row-start-end"><a href="#grid-row-start-end" class="headerlink" title="grid-row-start/end"></a>grid-row-start/end</h5><p>通过指定网格线来确定网格在容器中的行的起始位置</p><h5 id="grid-column-grid-row"><a href="#grid-column-grid-row" class="headerlink" title="grid-column/grid-row"></a>grid-column/grid-row</h5><p>上面两者的缩写</p><h5 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h5><p>为网格项提供一个名词,一遍容器grid-template-areas属性创建模板进行引用.也可以作为<code>grid-row</code>和<code>grid-cloumn</code>的缩写.</p><h5 id="justify-self-align-self"><a href="#justify-self-align-self" class="headerlink" title="justify-self/align-self"></a>justify-self/align-self</h5><p>items的水平/垂直对其方式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;CSS Grid 布局是CSS中最强大的布局系统,与flexbox的一维布局系统不同,CSS Grid是一个二维布局系统,它可以同时处理行和列.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第一个Grid布局&quot;&gt;&lt;a href=&quot;#第一个G
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端 css" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF-css/"/>
    
  </entry>
  
  <entry>
    <title>vue项目中的小总结</title>
    <link href="http://yoursite.com/2017/05/21/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/21/vue项目中的小总结/</id>
    <published>2017-05-21T06:45:23.000Z</published>
    <updated>2017-11-22T08:06:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单文件组件中data必须是一个函数-然后返回一个对象-避免多个组件数据混乱"><a href="#单文件组件中data必须是一个函数-然后返回一个对象-避免多个组件数据混乱" class="headerlink" title="单文件组件中data必须是一个函数,然后返回一个对象.避免多个组件数据混乱."></a>单文件组件中data必须是一个函数,然后返回一个对象.避免多个组件数据混乱.</h3><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="string">"123"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="列表循环时-尽量使用key-避免元素复用"><a href="#列表循环时-尽量使用key-避免元素复用" class="headerlink" title="列表循环时,尽量使用key,避免元素复用"></a>列表循环时,尽量使用key,避免元素复用</h3><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in array"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="在vue中使用less"><a href="#在vue中使用less" class="headerlink" title="在vue中使用less"></a>在vue中使用less</h3><pre><code>安装less及less-loader依赖<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader --save-dev</span><br></pre></td></tr></table></figure>修改webpack配置文件在单文件组件中使用<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure></code></pre><h3 id="nextTick的用法"><a href="#nextTick的用法" class="headerlink" title="$nextTick的用法"></a>$nextTick的用法</h3><pre><code>异步更新队列:Vue在观察到数据变化时不会直接更新Dom,而是开启一个队列,并缓冲在同一事件循环中发生的所有数据变化,然后去除重复数据,避免重复计算和dom操作,然后在下一个事件循环tick中,刷新队列并执行实际(已去重)的工作.$nextTick就是用来知道什么时候dom更新完成的.<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span>这是一段文本<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getText"</span>&gt;</span>获取div内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当我们点击按钮时,获取div的文本 --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getText: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.isShow = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> text = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>).innerText;</span><br><span class="line">        <span class="built_in">console</span>.log(text);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="webpack打包上传服务器后项目图片路径的问题"><a href="#webpack打包上传服务器后项目图片路径的问题" class="headerlink" title="webpack打包上传服务器后项目图片路径的问题"></a>webpack打包上传服务器后项目图片路径的问题</h3><pre><code>1. 解决方式一:    修改config文件中index.js里assetsPublicPath为&apos;./&apos;,    然后修改webpack.base.conf.js里的url-loader的limit,根据文件大小相应的修改.    但是修改后打包的文件比较大,影响页面加载.2. 解决方式二:    修改config文件中index.js里assetsPublicPath为&apos;./&apos;,然后修改源代码中css的图片路径为绝对路径,    静态资源由之前的src下的assets文件转移到src同级的static文件下新建一个img文件.    如果该项目有两级以上的域名,就在绝对路径前加上该子域名,如&apos;/XXX/static/img/a.png&apos;</code></pre><h3 id="scoped下尽量不要使用标签选择器"><a href="#scoped下尽量不要使用标签选择器" class="headerlink" title="scoped下尽量不要使用标签选择器"></a>scoped下尽量不要使用标签选择器</h3><pre><code>scoped下尽量不要使用标签选择器,会影响页面性能.</code></pre><h3 id="vue组件添加原生事件"><a href="#vue组件添加原生事件" class="headerlink" title="vue组件添加原生事件"></a>vue组件添加原生事件</h3><pre><code>vue组件添加原生事件,必须在事件后添加.native修饰符,否则事件不会生效.     </code></pre><h3 id="在vue中使用TypeScript"><a href="#在vue中使用TypeScript" class="headerlink" title="在vue中使用TypeScript"></a>在vue中使用TypeScript</h3><pre><code>在vue中使用TypeScript1. 安装依赖    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-class-component vue-property-decorator --save</span><br><span class="line">npm i ts-loader typescript tslint tslint-loader tslint-config-standard --save-dev</span><br></pre></td></tr></table></figure>2. 配置webpack    -  找到&apos;./build/webpack.base.conf.js&apos;添加        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;<span class="attr">extensions</span>: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>, <span class="string">'.ts'</span>],&#125;</span><br></pre></td></tr></table></figure>    -  找到module.rules,添加对.ts的解析        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    enforce: <span class="string">'pre'</span>,</span><br><span class="line">    loader: <span class="string">'tslint-loader'</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">    loader: <span class="string">'ts-loader'</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        appendTsSuffixTo: [<span class="regexp">/\.vue$/</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>    - 添加根路径tsconfig.json文件        <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 编译选项</span><br><span class="line">    "compilerOptions": &#123;</span><br><span class="line">        // 输出目录</span><br><span class="line">        "outDir": "./output",</span><br><span class="line">        // 是否包含可以用于 debug 的 sourceMap</span><br><span class="line">        "sourceMap": true,</span><br><span class="line">        // 以严格模式解析</span><br><span class="line">        "strict": true,</span><br><span class="line">        // 采用的模块系统</span><br><span class="line">        "module": "esnext",</span><br><span class="line">        // 如何处理模块</span><br><span class="line">        "moduleResolution": "node",</span><br><span class="line">        // 编译输出目标 ES 版本</span><br><span class="line">        "target": "es5",</span><br><span class="line">        // 允许从没有设置默认导出的模块中默认导入</span><br><span class="line">        "allowSyntheticDefaultImports": true,</span><br><span class="line">        // 将每个文件作为单独的模块</span><br><span class="line">        "isolatedModules": false,</span><br><span class="line">        // 启用装饰器</span><br><span class="line">        "experimentalDecorators": true,</span><br><span class="line">        // 启用设计类型元数据（用于反射）</span><br><span class="line">        "emitDecoratorMetadata": true,</span><br><span class="line">        // 在表达式和声明上有隐含的any类型时报错</span><br><span class="line">        "noImplicitAny": false,</span><br><span class="line">        // 不是函数的所有返回路径都有返回值时报错。</span><br><span class="line">        "noImplicitReturns": true,</span><br><span class="line">        // 从 tslib 导入外部帮助库: 比如__extends，__rest等</span><br><span class="line">        "importHelpers": true,</span><br><span class="line">        // 编译过程中打印文件名</span><br><span class="line">        "listFiles": true,</span><br><span class="line">        // 移除注释</span><br><span class="line">        "removeComments": true,</span><br><span class="line">        "suppressImplicitAnyIndexErrors": true,</span><br><span class="line">        // 允许编译javascript文件</span><br><span class="line">        "allowJs": true,</span><br><span class="line">        // 解析非相对模块名的基准目录</span><br><span class="line">        "baseUrl": "./",</span><br><span class="line">        // 指定特殊模块的路径</span><br><span class="line">        "paths": &#123;</span><br><span class="line">        "jquery": [</span><br><span class="line">            <span class="string">"node_modules/jquery/dist/jquery"</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br><span class="line">        // 编译过程中需要引入的库文件的列表</span><br><span class="line">        "lib": [</span><br><span class="line">        "dom",</span><br><span class="line">        "es2015",</span><br><span class="line">        <span class="string">"es2015.promise"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    - 添加根路径tslint.json文件        <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"extends"</span>: <span class="string">"tslint-config-standard"</span>,</span><br><span class="line">    <span class="attr">"globals"</span>: &#123;</span><br><span class="line">        <span class="attr">"require"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    - 在src下创建vue-shim.d.ts        <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "*.vue" &#123;</span><br><span class="line">    <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>        之后再代码中引入.vue文件时需要加上.vue后缀,因为ts默认只识别*.ts文件    - 改造APP.vue文件        <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    @Component(&#123;&#125;)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>    - 修改main.js为main.ts,并修改&apos;./build/webpack.base.conf.js&apos;中的entry为 `{app: &apos;./src/main.ts&apos;}`</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单文件组件中data必须是一个函数-然后返回一个对象-避免多个组件数据混乱&quot;&gt;&lt;a href=&quot;#单文件组件中data必须是一个函数-然后返回一个对象-避免多个组件数据混乱&quot; class=&quot;headerlink&quot; title=&quot;单文件组件中data必须是一个函数,
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue 前端" scheme="http://yoursite.com/tags/vue-%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>用NodeJS写一个爬虫</title>
    <link href="http://yoursite.com/2016/12/05/%E7%94%A8NodeJS%E5%86%99%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2016/12/05/用NodeJS写一个爬虫/</id>
    <published>2016-12-05T07:45:03.000Z</published>
    <updated>2017-12-05T07:51:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>用NodeJS下一个爬虫,用来获取简书首页的文章,然后保存以txt文件的形式保存在本地,数量为20篇.</p><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>​   npm init || yarn init</p><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>​   npm install superagent cheerio —save || yarn add superagent cheerio</p><h4 id="页面数据下载"><a href="#页面数据下载" class="headerlink" title="页面数据下载"></a>页面数据下载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">"superagent"</span>)</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">"cheerio"</span>)</span><br><span class="line"><span class="keyword">let</span> reptileUrl = <span class="string">"http://www.jianshu.com/"</span></span><br><span class="line"></span><br><span class="line">request</span><br><span class="line">    .get(reptileUrl)</span><br><span class="line">    .end(<span class="function"><span class="keyword">function</span>(<span class="params">err,res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> $ = cheerio.load(res.text,&#123;<span class="attr">decodeEntities</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">            <span class="comment">//每页有20篇文章,找到标题及其href的值</span></span><br><span class="line">            $(<span class="string">"#list-container .note-list li"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,value</span>)</span>&#123;</span><br><span class="line">              <span class="keyword">let</span> url = $(v).find(<span class="string">".title"</span>).attr(<span class="string">"href"</span>)</span><br><span class="line">              <span class="comment">//url即文章的链接,需要和reptileUrl拼接起来</span></span><br><span class="line">              getContent(url)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="获取文章内容-保存在本地"><a href="#获取文章内容-保存在本地" class="headerlink" title="获取文章内容,保存在本地"></a>获取文章内容,保存在本地</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getContent</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> adress = reptileUrl + url</span><br><span class="line">  request</span><br><span class="line">    .get(adress)</span><br><span class="line">    .end(<span class="function"><span class="keyword">function</span>(<span class="params">err,res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> $ = cherrio.load(res.text,&#123;<span class="attr">decodeEntities</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">          <span class="comment">//文章标题</span></span><br><span class="line">          <span class="keyword">let</span> title = $(<span class="string">".article .title"</span>).text()</span><br><span class="line">          <span class="comment">//文章内容</span></span><br><span class="line">          <span class="keyword">let</span> content = <span class="string">''</span></span><br><span class="line">          $(<span class="string">".article .show-content p"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">i, v, a</span>) </span>&#123;</span><br><span class="line">             content += $(v).text();</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">//要写入的数据</span></span><br><span class="line">          <span class="keyword">let</span> data = &#123;</span><br><span class="line">            title: title,</span><br><span class="line">            content: content</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//本地保存</span></span><br><span class="line">          fs.writeFile(<span class="string">'../data/'</span> + title + <span class="string">'.txt'</span>, <span class="built_in">JSON</span>.stringify(data), <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">"It's OK !"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;用NodeJS下一个爬虫,用来获取简书首页的文章,然后保存以txt文件的形式保存在本地,数量为20篇.&lt;/p&gt;
&lt;h4 id=&quot;初始化项目&quot;
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="node 爬虫" scheme="http://yoursite.com/tags/node-%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>重温&lt;&lt;计算机操作系统&gt;&gt;</title>
    <link href="http://yoursite.com/2015/10/18/%E9%87%8D%E6%B8%A9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2015/10/18/重温-计算机操作系统/</id>
    <published>2015-10-18T07:19:25.000Z</published>
    <updated>2017-11-14T06:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>并行是指两个或多个事件在同一时刻发生,而并发是两个或多个事件在同一时间间隔内发生.在多道程序环境下,并发性是指在一段时间内宏观上有多个程序在同时运行,但在单处理机系统中,每一时刻却仅能有一道程序执行,故微观上这些程序只能是分时的交替执行.倘若在多处理机,这些可以并发执行的程序便可分配到多个处理机上,实现并行执行.</p><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>如果某个系统支持两个或多个动作<strong>同时存在</strong>,name这个系统就是一个并发系统.如果某个系统支持两个或多个动作<strong>同时执行</strong>,那么这个系统就是一个并行系统.并发系统与并行系统这两个定义之间的关键差异在于<strong>存在</strong>这个词.  在并发程序中可以同时拥有两个或多个线程,这意味着,如果程序在单核处理器上运行,那么这两个线程将交替换入或换出内存.这些线程是同时<strong>存在</strong>的,每个线程都处于执行过程中的某个状态.如果程序能够并行执行,那么就一定是运行在多核处理器上的.此时,程序中的每个线程都将分配到一个独立的处理器核上,因此可以同时运行.  我相信你已经能够得出结论:”并行概念是并发概念的一个子集”.也就是说,你可以编写一个拥有多个线程或进程的并发程序,但如果没有多核处理器来执行这个程序,那么就不能以并行的方式来运行代码.因此,凡是在求解单个问题涉及多个执行流程的编程模式或执行行为,都属于并发编程的范畴.  摘自:&lt;&lt;并发的艺术&gt;&gt;-[美]布雷谢斯 </p><p>Erlang 之父 Joe Armstrong 用一张5岁小孩都能看懂的图解释了并发与并行的区别.<br><img src="http://oy299xjr2.bkt.clouddn.com/v2-674f0d37fca4fac1bd2df28a2b78e633_r.jpg" alt="并发与并行图解"><br>从图中可以看出,并发是两个队列交替使用一台咖啡机,并行是两个队列同时使用两台咖啡机.如果串行,一个队列使用一台咖啡机.并发和并行都可以是多个线程,就看这些线程能不能同时被多个CPU执行,如果可以说明是并行,而并发是多个线程被一个CPU轮流切换着执行.</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>对进程较为经典的定义有:</p><pre><code>1. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动.2. 进程是程序在一个数据集合上运行的过程,它是系统进行资源分配和调度的一个独立单位.3. 系统为每个进程定义了一个数据结构-进程控制块(PCB).OS根据PCB来对并发执行的进程进行控制和管理.</code></pre><p>线程和进程的比较: </p><pre><code>1. 再引入线程的操作系统中,通常一个进程都拥有若干个线程,至少有一个线程.2. 进程为资源拥有的最小单位,而线程作为调度和分派的基本单位,线程不拥有系统资源,可以访问资源.</code></pre><h4 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h4><p>进程和线程的主要差别在于他们是不同的操作系统资源的管理方式.进程有独立的地址空间,一个进程崩溃后,在保护模式下不会对其他进程产生影响,而线程只是一个进程中的不同执行路径.线程有自己的堆栈和局部变量,但线程没有单独的地址空间,一个线程死掉就等于整个进程死掉,所以在进程切换时,耗费资源较大,效率变差.但对于一些要求同时进行并且又要共享某些变量的并发操作,只能用进程,不能用线程.</p><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>生产者消费者问题是一个经典的多进程同步问题,也叫缓存绑定问题.  既有两个进程:一组生产者进程和一组消费者进程共享一个初始值为空固定大小为n的缓存区.生产者的工作是制造一段数据,只要缓存没满就放入缓存区,否则必须等待,如此反复.同时,只要缓存区不为空,消费者才能从中取出消息,一个取出一段数据,否则只能等待.由于缓存区是临界资源,它只允许一个生产者放入消息,或一个消费者从中取出消息.  问题的核心是要保证不让生产者在缓存满的时候还要向内写数据,不让消费者试图从空的缓存中取出数据.</p><h4 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h4><p>生产者和消费者对缓存区互斥访问是互斥关系,同时又是相互协作关系,即同步关系.那么需要解决的是互斥和同步PV操作的位置.使用”进程间通信”即可解决唤醒问题:  我们使用了两个信号标:full和empty.信号量mutex作为互斥信号量.用于控制互斥访问缓存池,互斥信号量初始值为1.信号量full用于记录当前缓冲池中”满”缓冲区数,初始值为0.信号量empty用于记录当前缓存区”空”缓存区数,初始值为n.新的数据增加后,full增加,empty减少.如果生产和试图在empty为0时减少其值,生产者就会被”催眠”.下一轮中有数据消费掉时,empty就会增加,生产者就会被”唤醒”.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//临界区互斥信号量</span></span><br><span class="line">semaphore empty = n;<span class="comment">//空闲缓存区</span></span><br><span class="line">semaphore full = <span class="number">1</span>;<span class="comment">//缓存区初始化为空</span></span><br><span class="line">produce()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        produce an item in dextp;<span class="comment">//生产数据</span></span><br><span class="line">        P(empty);<span class="comment">//获取空缓存区单元</span></span><br><span class="line">        P(mutex);<span class="comment">//进入临界区</span></span><br><span class="line">        add nextp to buffer;<span class="comment">//将数据放入缓存区</span></span><br><span class="line">        V(mutex);<span class="comment">//离开临界区,释放互斥信号量</span></span><br><span class="line">        V(full)<span class="comment">//满缓存区加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consume()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full);<span class="comment">//获取满缓存区单元</span></span><br><span class="line">        P(mutex);<span class="comment">//进入临界区</span></span><br><span class="line">        remove an item from buffer;<span class="comment">//拿走数据</span></span><br><span class="line">        V(mutex);<span class="comment">//离开临界区</span></span><br><span class="line">        V(empty);<span class="comment">//空缓存区单元加1</span></span><br><span class="line">        consume the item<span class="comment">//消费数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发与并行&quot;&gt;&lt;a href=&quot;#并发与并行&quot; class=&quot;headerlink&quot; title=&quot;并发与并行&quot;&gt;&lt;/a&gt;并发与并行&lt;/h2&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://yoursite.com/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="计算机基础 操作系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
