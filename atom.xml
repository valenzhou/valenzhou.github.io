<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.喵的网络日志</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-21T02:46:01.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ValenZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[阮一峰ES6标准]学习笔记</title>
    <link href="http://yoursite.com/2017/12/21/%E9%98%AE%E4%B8%80%E5%B3%B0ES6%E6%A0%87%E5%87%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/12/21/阮一峰ES6标准-学习笔记/</id>
    <published>2017-12-21T02:43:25.000Z</published>
    <updated>2017-12-21T02:46:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>let声明的变量只在代码块内有效</li><li>不存在变量提升</li><li>let声明变量之前,该变量都是不可用的,称为暂时性死区</li><li>相同作用域内不允许重复声明同一个变量</li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li>const声明一个只读的常量,一旦声明,常量的值不能改变.</li><li>const一旦声明变量,必须初始化,不赋值就会报错.</li><li>const保证的其实是保存变量的内存地址不得改动.对于简单数据类型,值就保存在变量指向的内存地址,等同于常量.对于复合类型的数据,变量指向的地址保存的是一个指针.</li><li>var和function声明的全局变量,是顶层对象的属性.而let,const,class声明的全局变量不再属于顶层对象.</li></ul><h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><p>从数组和对象中提取值,对变量进行赋值,这就称为解构.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];<span class="comment">//a=1,b=2,c=3</span></span><br><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>] <span class="comment">//解构不成功变量值为undefined</span></span><br></pre></td></tr></table></figure><p>如果等号右边不是数组(或不是可遍历的解构),会报错.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a] = <span class="literal">false</span>;<span class="comment">//false不是可遍历解构,报错</span></span><br></pre></td></tr></table></figure><p>解构赋值允许指定默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b=<span class="number">666</span>] = [<span class="number">1</span>]<span class="comment">//a=1,b=666</span></span><br></pre></td></tr></table></figure><p>对象也可以用于解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;foo,bar&#125; = &#123;<span class="attr">foo</span>:<span class="string">'a'</span>,<span class="attr">bar</span>:<span class="string">'b'</span>&#125;;<span class="comment">//foo='a',bar='b'</span></span><br><span class="line"><span class="comment">//属性名相同才能取到值</span></span><br><span class="line"><span class="keyword">let</span> &#123;foo,bar&#125; = &#123;<span class="attr">foo</span>:<span class="string">'a'</span>,<span class="attr">baszz</span>:<span class="string">'b'</span>&#125;;<span class="comment">//bar为undefined</span></span><br><span class="line"><span class="comment">//&#123;foo&#125;其实就是&#123;foo:foo&#125;的简写</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>:bar&#125; = &#123;<span class="attr">foo</span>:<span class="string">'a'</span>&#125;<span class="comment">//bar='a',foo未定义</span></span><br><span class="line"><span class="comment">//对象解构赋值也可以指定默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123;x,y=<span class="number">3</span>&#125;=&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;<span class="comment">//x=1,y=3</span></span><br></pre></td></tr></table></figure><p>字符串也可用于解构赋值,因此此时,字符串被转换为一个类似数组的对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c,d,e] = <span class="string">'hello'</span>;<span class="comment">//a='h',b='e'</span></span><br></pre></td></tr></table></figure><p>函数的参数也可用于解构赋值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x,y=<span class="number">3</span>]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>,<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><p>ES6为字符串添加了便利器接口,使得字符串可以被for…of循环遍历.</p><p>ES5有indexOf用来确定一个字符串是否在另一个字符串中.</p><p>ES6又提供了三种方法:</p><ul><li>includes():返回布尔值,表示是否找到了参数字符串</li><li>startsWith():返回布尔值,表示是否在原字符串的头部</li><li>endsWith():返回布尔值,表示是否在原字符串的尾部</li></ul><p>这三个方法都提供了第二个参数,表示搜索的位置.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s =<span class="string">"hello World"</span></span><br><span class="line">s.includes(<span class="string">"hello"</span>)<span class="comment">//true</span></span><br><span class="line">s.startsWith(<span class="string">"hel"</span>)<span class="comment">//true</span></span><br><span class="line">s.endsWith(<span class="string">"rld"</span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>repeat()</strong>方法返回一个新字符串,表示将元字符串重复n次.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>);<span class="comment">//'hellohello'</span></span><br></pre></td></tr></table></figure><p>模板字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'world'</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">`hello <span class="subst">$&#123;s&#125;</span> !`</span><span class="comment">//a='hello world !'</span></span><br></pre></td></tr></table></figure><p><code>${}</code>里面不仅可以嵌入变量,还可以嵌入函数.</p><h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><ul><li>Number.isFinite()用来检查一个数值是否为有限的(finite)</li><li>Number.isNaN()用来检查一个数值是否为NaN.</li><li>上面两个方法与传统的全局方法isFinite()和isNaN()的区别在于,传统方法会先调用Number()将非数值转换为数值在判断,新的两个方法只对数值有效,非数组一律返回false.</li><li>Number.parseInt();</li><li>Number.parseFloat();将全局方法移植到Number对象上,使语言逐步模块化.</li><li>Number.isInteger();用来判断一个值是否为整数.</li><li>指数运算符,例如<code>2**3===8;</code></li></ul><h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><p>函数参数的默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x,y=<span class="string">'world'</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x,y)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">'hello'</span>)<span class="comment">//hello world</span></span><br><span class="line"><span class="comment">//参数是默认声明的,所以不能用let和const再次声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=<span class="number">5</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;<span class="comment">//error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>;<span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rest参数</strong></p><p>ES6引入rest参数,用于获取函数的多余参数,rest参数搭配的变量是一个数组,该变量将多余的参数放入数组中.rest参数只能是最后一个参数,否则会报错.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> val <span class="keyword">of</span> values)&#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)<span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>函数的name属性返回该函数的函数名.</p><p><strong>箭头函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span>=&gt;</span> v;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span>=&gt;</span><span class="number">5</span>;<span class="comment">//没有参数或多个参数用()包括,多个函数语句用&#123;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>箭头函数内的this是定义时所在的对象,不是使用时的对象</li><li>不可以当做构造函数</li><li>不可以使用arguments对象</li><li>不可以使用yield命令,不能作为Generator函数</li><li>箭头函数中的this的指向是固定的,不可变的.</li></ul><p><strong>尾调用</strong>就是在函数的最后一步调用另外一个函数.</p><p><strong>尾递归</strong>函数在最后一步调用自身就是尾递归.尾递归不会发生栈溢出,相对节省内存.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorrial</span>(<span class="params">n,total</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n<span class="number">-1</span>,n*total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式编程有一个概念,叫做柯里化,意思就是将多参数的函数转换成单参数的函数形式.</p><h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><p><strong>扩展运算符</strong>是三个点<code>...</code>.它好比rest参数的逆运算,将一个数组转为用逗号分隔的参数序列.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure><p>由于扩展运算符可以展开数组,所以不再需要<code>apply</code>方法将数组转为函数的函数了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y,z</span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">f.apply(<span class="literal">null</span>,args)</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y,z</span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">f(...args)</span><br></pre></td></tr></table></figure><p>扩展运算符的应用</p><ul><li>复制数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line">cionst a2 = [...a1]</span><br></pre></td></tr></table></figure><ul><li>合并数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line">arr1.concat(arr2,arr3)</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line">[...arr1,...arr2,...arr3]</span><br></pre></td></tr></table></figure><ul><li>字符串转为数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">"hello"</span>]<span class="comment">//['h','e','l','l','o']</span></span><br></pre></td></tr></table></figure><ul><li>只要是有Iterator接口的对象都可以用扩展运算符转为数组.</li></ul><p><strong>Array.from()</strong>将类似数组的对象和可遍历对象转换为真正的数组.</p><p>扩展运算符转换为数组调用的是遍历器接口Iterator,Array.from()不仅可以支持可遍历对象还支持类似数组的对象,既任何拥有length属性的对象都可以通过Array.from转换为数组,而扩展运算符不行.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;<span class="string">'0'</span>:<span class="string">'a'</span>,<span class="string">'1'</span>:<span class="string">'b'</span>,<span class="attr">length</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike)</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike)</span><br></pre></td></tr></table></figure><p><strong>Array.of()</strong>用于将一组值转换为数组.因为Array()和new Array(),由于参数不同导致行为不统一.一个参数指定数组的长度,不少于两个才能组成新数组,这样会导致行为有差异.Array.of()基本可以替代Array()和new Array().</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p><strong>find()</strong>用于找出第一个符合条件的数组成员.他的第一个参数是一个回调函数,所有成员依次执行该函数,直到找到第一个为true的成员,没有找到返回undefined.该回调函数一个接受3个参数,分别是value,index,arr.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">10</span>].find(<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;n&lt;<span class="number">0</span>&#125;)<span class="comment">//-5</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">10</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">v,i,a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span></span><br><span class="line">&#125;)<span class="comment">//10</span></span><br></pre></td></tr></table></figure><p><strong>findIndex()</strong>与find()用法类似,用于找出符合条件成员的索引,都不符合返回-1.由于数组的IndexOf方法无法识别数组的NaN成员,而find和findIndex弥补了数组indexOf的不足.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">10</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">v,i,a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="number">4</span>;<span class="comment">//1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>fill()</strong>填充一个数组.接受第二和第三个参数分别为起始位置和结束位置之前.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>].fill(<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//['a',7,'c']</span></span><br></pre></td></tr></table></figure><p><strong>entries(),keys(),values()</strong>都返回一个遍历器对象,可以用for…of进行遍历.entries()是对键值对的遍历,keys()是对键名的遍历,values()是对值得遍历.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>,<span class="string">'b'</span>].keys())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);<span class="comment">//0  //1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组的includes()</strong>返回一个布尔值表示数组是否包含给定的值,与字符串的includes()方法类似.另外Map和Set数据结构有一个has方法,需要注意与includes区分.Map的has用来查找key,Set的has用来查找value.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].includes(<span class="number">3</span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><p><strong>属性的简写形式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>:x,<span class="attr">y</span>:y&#125;;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;x,y&#125;</span><br></pre></td></tr></table></figure><p><strong>属性名表达式</strong></p><p>ES6允许字面量定义对象时,用表达式作为对象的属性名.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [name]: <span class="string">'foo'</span>,</span><br><span class="line">  [<span class="string">'a'</span>+<span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;foo:'foo','abc':123&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Object.is()</strong>用来比较两个值是否严格相等,与===行为基本一致.<strong>不同之处在于+0不等于-0,NaN等于NaN</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span>;<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>,<span class="number">-0</span>)<span class="comment">//false</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>;<span class="comment">//false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>Object.assign()</strong>用于对象合并,将源对象所有可枚举属性复制到目标对象.</p><ul><li>如果只有一个参数,直接返回该对象.</li><li>同名属性,后者会覆盖前者</li><li>Object.assign方法实行的是浅拷贝.如果某个属性的值是对象,那么目标对象拷贝的是这个对象的引用.</li></ul><p>Object.assign的用途.</p><ul><li>为对象添加属性</li><li>为对象添加方法(将函数放在空对象中)</li><li>克隆对象(和一个空对象合并)</li></ul><p><strong>Object.setPrototypeOf()</strong>设置一个对象的prototype对象,返回参数对象本身,它是ES6整数推荐的设置原型对象的方法.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> proto = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a,proto);<span class="comment">//a.b === 2</span></span><br><span class="line"><span class="comment">//上面代码将proto对象设置为a对象的原型</span></span><br></pre></td></tr></table></figure><p><strong>Object.getPrototypeOf()</strong>用于读取一个对象的原型对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a);<span class="comment">//&#123;b:2&#125;</span></span><br></pre></td></tr></table></figure><p><strong>super关键字</strong>指向当前对象的原型对象.</p><p><strong>Object.keys()</strong>返回一个数组,成员是对象所有可遍历属性的键名.</p><p><strong>Object.values()</strong>返回一个数组,成员是对象所有可遍历属性的值.</p><p><strong>Object.entries()</strong>返回一个数组,成员是对象所有可遍历属性的键值对数组.</p><p><strong>对象也可用于解构赋值以及扩展运算符</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x,...y&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">z</span>:<span class="number">3</span>&#125;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y<span class="comment">// &#123;y:2,z:3&#125;</span></span><br><span class="line"><span class="keyword">let</span> z = &#123;...y&#125;<span class="comment">//&#123;y:2,z:3&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Null</strong>传导运算符<code>?.</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = (msg &amp;&amp; msg.body&amp;&amp;msg.body.user || <span class="string">'default'</span>)</span><br><span class="line"><span class="comment">//使用null传导运算符</span></span><br><span class="line"><span class="keyword">const</span> first = (msg?.body?.user || <span class="string">'default'</span>)</span><br></pre></td></tr></table></figure><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>ES6引入了一种原始数据类型Symbol,表示独一无二的值.它是js第七种数据类型,分别是<code>undefined,null,Boolean,String,Number,Object,Symbol</code></p><p>由于symbol不是对象,而是数据类型,所以不能使用new,他是一种类似于字符串的的数据类型.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line">s === s1;<span class="comment">//false,Symbol不能参与运算.</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj[s] = <span class="string">'hello'</span><span class="comment">//Symbol作为属性名不能用.运算形式,且不能被遍历到</span></span><br></pre></td></tr></table></figure><h3 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h3><p>ES6提供了新的数据结构Set,它类似于数组,但是成员都是唯一的,没有重复的值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)]</span><br></pre></td></tr></table></figure><ul><li>Set,prototype.constructor: 构造函数,默认就是Set函数</li><li>Set.prototype.size: 返回set实例的成员总数</li></ul><p>Set的4个操作方法</p><ul><li>add(value): 添加某个值,返回set结构本身</li><li>delete(value):删除某个值,返回一个布尔值,表示是否成功</li><li>has(value): 返回一个布尔值,表示是否为Set成员.</li><li>clear():清除所有成员.</li></ul><p>Set的4个遍历方法</p><ul><li>keys():返回键名的遍历器</li><li>values():返回值得遍历器(默认遍历生成函数)</li><li>entries():返回键值对的遍历器</li><li>forEach():使用回调函数遍历每个成员</li></ul><p>ES6提供了Map数据类型,类似于对象,但他的”键”的范围不限于字符串,各种类型的值都可以作为键.</p><p>Map的实例属性与操作方法:</p><ul><li>size: Map结构的成员总数</li><li>set(key,value):设置键值,返回整个结构</li><li>get(key): 读取某个键的值,找不到key返回undefined</li><li>has(key):返回布尔值,表示某个键是否在当前Map对象中</li><li>delete(key):删除某个键,返回布尔值表示是否成功.</li><li>clear():清除所有.</li></ul><p>Map结构提供的遍历方法与Set相同.</p><h3 id="promise对象"><a href="#promise对象" class="headerlink" title="promise对象"></a>promise对象</h3><p>promise是异步编程的一种解决方案.它接受一个函数作为参数,函数有两个参数resolve和reject有js引擎提供,resolve函数将promise有未完成变为成功,reject由未完成变为失败.</p><p>promise实例生成后可以用then指定resolved和rejected状态的回调函数,并且then返回一个新的promise实例,所以可以链式调用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*成功*/</span>)&#123;</span><br><span class="line">      resolve(value)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//success</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//error</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//一般来说,不要再then中定义rejected状态的回调函数,既then的第二个参数,而应该总是使用catch方法.</span></span><br></pre></td></tr></table></figure><p>promise.catch是.then(null,rejection)的别名,指定发生错误是的回调函数.</p><p>promise.all将多个promise实例包装成一个promise实例.全部成功才成功,有一个失败就是失败.</p><p>promise.race将多个promise包装为一个,只要其中有一个先改变状态,整个状态就会改变.</p><p>promise.finally方法用于指定不管promise的最后状态无论怎样都会执行,它接受一个普通的回调函数作为参数,不管怎样都必须执行.</p><h3 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h3><p>当使用for…of循环某种数据结构时,该循环会自动寻找Iterator接口.</p><p>一个对象只要具备Symbol.iterator属性就代表该对象可遍历.</p><p>默认调用Iterator接口的场合:</p><ul><li>解构赋值<code>let [x,y] = [1,2]</code></li><li>扩展运算符<code>[...arr]</code></li><li>yield<em>后面如果跟的是可遍历结构就会调用遍历器接口`yield\</em> [2,3,4]`</li><li>for…of,Array.from()…</li></ul><p>遍历器对象除了具有next()函数,还要return()和throw()</p><p>for..of与其他遍历语法比较.</p><ul><li>for循环</li><li>数组的forEach(无法跳出循环,break,return都不行)</li><li>for …in(主要是循环对象而设计,不适用于遍历数组)</li><li>for…of,与for..in一样简洁,可以跳出循环…</li></ul><h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p>Generator是ES6题提供的异步编程解决方案.可以把它理解为一个状态机,封装了多个状态.还是一个遍历器对象生成函数.</p><p>Generator函数的特征:function与函数名之间有一个*号,函数体内部使用yield表达式定义不同的内部状态.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorld</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorld();</span><br><span class="line"><span class="comment">//generator函数调用后该函数并不执行,返回的也不是函数运行结果,而是遍历器对象Iterator.然后调用遍历器对象的next方法使得指针移动到下一个状态.</span></span><br><span class="line">hw.next();<span class="comment">//&#123;value:'hello',done:fasle&#125;</span></span><br><span class="line">hw.next();<span class="comment">//&#123;value:'world',done:false&#125;</span></span><br><span class="line">hw.next();<span class="comment">//&#123;value:'ending',done:true&#125;</span></span><br></pre></td></tr></table></figure><p>由于Generator函数返回一个遍历器对象,调用next才会遍历下一个内部状态,所以其实他是一个可以暂停执行的函数,yield就是暂停标志.next()遇到yield就会暂停后面的操作,并把yield后面表达式的值作为返回的value值,下一次调用next,再继续执行,知道遇到yield或return为止.另外yield表达式在其他地方使用都会报错.</p><p><strong>next()</strong>可以带一个参数,作为上一次yield表达式的返回值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span>*(<span class="keyword">yield</span> (x+<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y/<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x+y+z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next();<span class="comment">//&#123;value:6,done:fasle&#125;</span></span><br><span class="line">a.next();<span class="comment">//&#123;value:NaN,done:fasle&#125;</span></span><br><span class="line">a.next();<span class="comment">//&#123;value:NaN,done:fasle&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next();<span class="comment">//&#123;value:6,done:fasle&#125;</span></span><br><span class="line">b.next(<span class="number">12</span>);<span class="comment">//&#123;value:8,done:fasle&#125;</span></span><br><span class="line">b.next(<span class="number">13</span>);<span class="comment">//&#123;value:42,done:fasle&#125;</span></span><br></pre></td></tr></table></figure><p><strong>for…of</strong>可以自动遍历Generator函数生成的遍历器对象,并且不再需要调用next方法.但函数return 的值不会再循环中.</p><p><strong>在Generator函数中调用Generator函数是没有效果的</strong>,这就需要用到<code>yield*</code>表达式,用来达成以上目的.并且任何数据结构只要有Iterator接口,就可以使用<code>yield*</code>遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h3><p>ES6引入了async函数,使异步操作更加方便.async函数就是Generator函数的语法糖.它将*替换成async,将yield替换成await,仅此而已.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  cosnt f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/a.txt'</span>)</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/b.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span>  readFile(<span class="string">'/etc/a.txt'</span>)</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span>  readFile(<span class="string">'/etc/b.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async对generator的改进</p><ul><li>内置执行器.async函数的执行与普通函数一样<code>gen()</code></li><li>更好的语义.比起*与yield,语义更清楚.</li><li>更广的适用性.async函数的await命令后面可以是promise对象和原始类型的值(但此时等同于同步操作).</li><li>返回值是promise对象,而generator返回的是一个Iterator遍历器.而async可以看做多个异步操作包装的promise对象,而await命令就是内部then的语法糖.</li></ul><p><strong>async函数内部return语句返回的值会成为then方法回调函数的参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'helloWorld'</span></span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span>=&gt;</span><span class="built_in">console</span>,log(v))<span class="comment">//'helloWorld'</span></span><br></pre></td></tr></table></figure><p>async函数内部抛出错误会导致promise对象变为reject状态.错误对象会被catch方法回调函数接收.</p><p><strong>正常情况下await后面是一个peomise对象,如果不是,会转成一个立即resolve的promise</strong></p><p>for await of 用来遍历异步的iterator接口.</p><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>ES6引入class的概念,作为对象的模板,通过class关键字来定义类.</p><p>class其实只是一个语法糖,他的大部分功能ES5都可以做到,只是让对象原型的写法更像面向对象编程语法而已.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x+<span class="string">','</span>+<span class="keyword">this</span>.y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x,y)&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x+<span class="string">','</span>+<span class="keyword">this</span>.y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Point === Point.prototype.constructor<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point();</span><br></pre></td></tr></table></figure><p>toString是Point类内部定义的方法,它是不可枚举的,这与ES5不一致.</p><p><strong>类不存在变量提升</strong></p><p><strong>class的静态方法</strong>,类相当于实例的原型,所有类中定义的方法都会被实例继承,如果在一个方法前加上<code>static</code>关键字就表示该方法不会被实例继承,而是直接通过类来调用,这就成为静态方法.静态方法中的this指的是类而不是实例.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> hello()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'helloWorld'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.hello()<span class="comment">//'helloWorld'</span></span><br><span class="line"><span class="keyword">var</span> h = <span class="keyword">new</span> Foo();</span><br><span class="line">h.hello()<span class="comment">//报错typeError...</span></span><br></pre></td></tr></table></figure><p><strong>父的静态方法可以被子类继承</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x,y)&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> hello()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'helloWorld'</span></span><br><span class="line">  &#125;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x,y,z)&#123;</span><br><span class="line">    <span class="keyword">super</span>(x,y)<span class="comment">//调用父类的constructor(x,y)</span></span><br><span class="line">    <span class="keyword">this</span>.z = z;</span><br><span class="line">  &#125;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.z +<span class="string">','</span>+<span class="keyword">super</span>.toString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.hello()<span class="comment">//'helloWorld'</span></span><br></pre></td></tr></table></figure><p>super关键字表示父类的构造函数,用来新建父类的this对象.</p><p><strong>子类必须在constructor方法中调用super方法,否则新建实例会报错</strong>,这是因为子类没有自己的this对象而是继承父类的this对象,然后对其加工,不调用super()子类就得不到this对象.</p><p><strong>如果子类没有定义constructor,这个方法会被默认添加,super也会默认添加</strong>.只要调用super才能使用this关键字.</p><h3 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h3><p>修饰器函数用来修改类的行为,是对一个类进行处理的函数,修饰器函数的第一个参数就是说要修身的目标类.如果觉得一个参数不够用,可以再修饰器外再封装一层函数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span>()</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    target.isTest = <span class="literal">true</span>;<span class="comment">//静态属性</span></span><br><span class="line">    target.prototype.isOk = <span class="literal">false</span>;<span class="comment">//实例属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  MyTest.isTest <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>修饰器实在代码编译时发生的,这意味着修饰器本质就是编译时执行的函数.</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>export 用于规定模块的对外接口.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> b = <span class="string">'b'</span></span><br><span class="line"><span class="keyword">export</span> &#123;a,b&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  a,</span><br><span class="line">  b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>import 用于输入其他模块提供的功能.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a,b&#125; <span class="keyword">from</span> <span class="string">'./xxx'</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">as</span> A <span class="keyword">from</span> <span class="string">'./xxx'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> num <span class="keyword">from</span> <span class="string">'./xxx'</span></span><br></pre></td></tr></table></figure><p>如果import要取代Node的require方法就形成了障碍,因为require是运行时加载模块,而import无法取代require的动态加载功能.CommonJS输出的是一个值得拷贝,而ES6模块输出的是值得引用.</p><p><strong>浏览器加载ES6模块,也使用<code>&lt;script&gt;</code>,但要加入type=’module’属性</strong>告诉浏览器这是一个ES6模块.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;let&quot;&gt;&lt;a href=&quot;#let&quot; class=&quot;headerlink&quot; title=&quot;let&quot;&gt;&lt;/a&gt;let&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;let声明的变量只在代码块内有效&lt;/li&gt;
&lt;li&gt;不存在变量提升&lt;/li&gt;
&lt;li&gt;let声明变量之前,该变量都是不可
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习CSS Grid布局</title>
    <link href="http://yoursite.com/2017/12/13/%E5%AD%A6%E4%B9%A0CSS-Grid%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2017/12/13/学习CSS-Grid布局/</id>
    <published>2017-12-13T07:39:20.000Z</published>
    <updated>2017-12-13T07:42:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CSS Grid 布局是CSS中最强大的布局系统,与flexbox的一维布局系统不同,CSS Grid是一个二维布局系统,它可以同时处理行和列.</p></blockquote><h3 id="第一个Grid布局"><a href="#第一个Grid布局" class="headerlink" title="第一个Grid布局"></a>第一个Grid布局</h3><p>css Grid布局由两个核心组成部分,warpper(父元素)和items(子元素).warpper是实际的grid(网格),items是网格的内容.</p><p>下面是一个warpper元素,内部包含了6个items:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"warpper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要把warpper元素变成一个grid(网格),只需要把它的<code>display</code>属性设置为<code>grid</code>即可.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warpper</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们还没有写任何样式,他会简单的将6个div堆叠在一起.</p><h3 id="Columns-列-和rows-行"><a href="#Columns-列-和rows-行" class="headerlink" title="Columns(列)和rows(行)"></a>Columns(列)和rows(行)</h3><p>为了使其成为二维的网格容器,我们需要定义行和列.让我们创建两行三列,使用<code>grid-template-cloumns</code>和<code>grid-template-rows</code>属性.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warpper</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">grid-template-cloumns</span>: <span class="number">100px</span> <span class="number">80px</span> <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为<code>grid-template-cloumns</code>写入了3个值,这样我们就得到了3列,每列的值代表列的宽度.而<code>grid-template-rows</code>代表行数及行的高度.</p><h3 id="放置items-子元素"><a href="#放置items-子元素" class="headerlink" title="放置items(子元素)"></a>放置items(子元素)</h3><p>为了帮助理解,我们在每个items(子元素)加上单独的class.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"warpper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item4"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item5"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item6"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在我们来创建一个 3*3的grid:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warpper</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-cloumns</span>:<span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只在页面上看到3-2的grid,而我们定义的是3-3的grid.这是因为我们只有6个items来填充这个网格.我们我们再追加3个items,name最后一行也会被填满.</p><p>要定位和调整items大小,可以使用grid-cloumn和grid-row属性来设置.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">  <span class="attribute">grid-cloumn-start</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-cloumn-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的样式表示,我们希望item1占据从第一个网格线开始,到第四条网格线结束.换句话说它将独占一行.而剩下的items都推到了下一行.</p><p>这种形式也可以缩写为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">  <span class="attribute">grid-cloumn</span>: <span class="number">1</span>/<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span>&#123;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>/<span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ol><li>网格容器(Grid):应用<code>display:grid</code>的元素,items的直接父级元素.</li><li>网格项(items): 网格容器的直接子元素,后代元素不是.</li><li>网格线(Grid-line):构成网格结构的分界线.</li><li>网格轨道(Grid-Track):两条相邻网格线之间的空间.</li><li>网格单元格(Grid-cell):两个相邻行与相邻列之间的空间.</li><li>网格区域(Grid-Area):四条网格线包围的总空间.</li></ol><h3 id="父元素-网格容器属性"><a href="#父元素-网格容器属性" class="headerlink" title="父元素 网格容器属性"></a>父元素 网格容器属性</h3><h5 id="display"><a href="#display" class="headerlink" title="display"></a>display</h5><p>将元素定义为网格容器,并为其建立新的网格式上下文.</p><ul><li>grid : 生成一个块级网格</li><li>inline-grid: 生成一个内联网格</li><li>subgrid: 嵌套的子网格.</li></ul><p><strong>在网格容器中使用float,clear,column,vertical-align不会产生任何效果.</strong></p><h5 id="grid-template-cloumns-rows"><a href="#grid-template-cloumns-rows" class="headerlink" title="grid-template-cloumns/rows"></a>grid-template-cloumns/rows</h5><p>使用空格分割值列表,用来定义网格的行和列.可以是长度值和百分比,和自动分配(auto)或网格线名称<line-name>.</line-name></p><h5 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h5><p>指定Grid Area名称来定义网格模板.一个<code>.</code>号代表一个空的单元.你可以使用任意数量的<code>.</code>只要这些<code>.</code>之间没有空隙隔开就表示一个个的单元格.</p><ul><li><grid-area-name>:由items的grid-area指定的区域名称</grid-area-name></li><li>.(点号):代表一个空网格单元</li><li>none:不定义网格区域</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>:auto;</span><br><span class="line">  <span class="attribute">grid-template-cloumns</span>:<span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">"header header header"</span></span><br><span class="line">    <span class="string">"main main . sidebar"</span></span><br><span class="line">    <span class="string">"footer footer footer footer"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-a</span>&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>:header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-b</span>&#123;</span><br><span class="line">  <span class="attribute">grid-area</span>:main;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当你命名网格区域后,该区域两端的网格线实际上是自动命名的,如果你的网格区域名字是foo,则起始行网格线和列网格线是foo-statrt,最后的网格线是foo-end.则意味着一个网格线可能有很多名称.</p><h5 id="grid-template"><a href="#grid-template" class="headerlink" title="grid-template"></a>grid-template</h5><p>用于定义<code>grid-template-rows</code>,<code>grid-template-cloumns</code>,和<code>grid-template-areas</code>的缩写.</p><ul><li>none:将所有的属性设置为初始值.</li><li>subgrid:将rows和cloumns设置为subgrid,areas设置为初始值.</li><li><grid-template-rows>/<grid-template-cloumns>:将rows和cloumns设置为特定值,areas为none.</grid-template-cloumns></grid-template-rows></li></ul><h5 id="grid-column-gap-grid-row-gap"><a href="#grid-column-gap-grid-row-gap" class="headerlink" title="grid-column-gap/grid-row-gap"></a>grid-column-gap/grid-row-gap</h5><p>指定网格线的大小,可以把它想象为设置列/行之间间距的宽度.值为长度值.</p><h5 id="grid-gap"><a href="#grid-gap" class="headerlink" title="grid-gap"></a>grid-gap</h5><p>grid-column-gap/grid-row-gap的缩写语法</p><h5 id="justify-items"><a href="#justify-items" class="headerlink" title="justify-items"></a>justify-items</h5><p>网格容器的水平对其方式,这些行为也可以通过items的justify-self属性设置:</p><ul><li>start 左侧对其</li><li>end 右侧对其</li><li>center 居中对齐</li><li>stretch 填满区域宽度</li></ul><h5 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h5><p>网格容器的垂直对齐方式:</p><ul><li>start 顶部对齐</li><li>end 底部对齐</li><li>center 垂直居中</li><li>stretch 填满区域高度</li></ul><h5 id="justify-content-align-content"><a href="#justify-content-align-content" class="headerlink" title="justify-content/align-content"></a>justify-content/align-content</h5><p>有时,网格容器的内容小于整体容器的大小,可以设置内容在容器中的对齐方式.</p><ul><li>start 左对齐</li><li>end 右对齐</li><li>center 居中</li><li>stretch 填充</li><li>space-around 左右两边都有空间,空格之间距离相等</li><li>space-between 左右两边没有空间,空格之间距离相等</li><li>space-evenly 左右和每个空间距离相等</li></ul><h5 id="grid-auto-columns-grid-auto-rows"><a href="#grid-auto-columns-grid-auto-rows" class="headerlink" title="grid-auto-columns/grid-auto-rows"></a>grid-auto-columns/grid-auto-rows</h5><p>指定自动生成隐式网格轨道,但定义行和列自动超出网格范围时,隐式网格轨道创建.值为长度,百分比等等.</p><h5 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h5><p>如果你有一些未明确放置的网格,自动放置算法会自动放置这些项.</p><ul><li>row: 依次填充每行</li><li>column:依次填充每列</li><li>dense: 出现较小的网格项时,尝试填充网格中较早的空缺.但它可能导致你的网格项出现混乱.</li></ul><h3 id="子元素-网格项items属性"><a href="#子元素-网格项items属性" class="headerlink" title="子元素 网格项items属性"></a>子元素 网格项items属性</h3><h5 id="grid-column-start-end"><a href="#grid-column-start-end" class="headerlink" title="grid-column-start/end"></a>grid-column-start/end</h5><p>通过指定网格线来确定网格在容器中的列的起始位置</p><h5 id="grid-row-start-end"><a href="#grid-row-start-end" class="headerlink" title="grid-row-start/end"></a>grid-row-start/end</h5><p>通过指定网格线来确定网格在容器中的行的起始位置</p><h5 id="grid-column-grid-row"><a href="#grid-column-grid-row" class="headerlink" title="grid-column/grid-row"></a>grid-column/grid-row</h5><p>上面两者的缩写</p><h5 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h5><p>为网格项提供一个名词,一遍容器grid-template-areas属性创建模板进行引用.也可以作为<code>grid-row</code>和<code>grid-cloumn</code>的缩写.</p><h5 id="justify-self-align-self"><a href="#justify-self-align-self" class="headerlink" title="justify-self/align-self"></a>justify-self/align-self</h5><p>items的水平/垂直对其方式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;CSS Grid 布局是CSS中最强大的布局系统,与flexbox的一维布局系统不同,CSS Grid是一个二维布局系统,它可以同时处理行和列.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第一个Grid布局&quot;&gt;&lt;a href=&quot;#第一个G
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端 css" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF-css/"/>
    
  </entry>
  
  <entry>
    <title>vue项目中的小总结</title>
    <link href="http://yoursite.com/2017/05/21/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/21/vue项目中的小总结/</id>
    <published>2017-05-21T06:45:23.000Z</published>
    <updated>2017-11-22T08:06:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单文件组件中data必须是一个函数-然后返回一个对象-避免多个组件数据混乱"><a href="#单文件组件中data必须是一个函数-然后返回一个对象-避免多个组件数据混乱" class="headerlink" title="单文件组件中data必须是一个函数,然后返回一个对象.避免多个组件数据混乱."></a>单文件组件中data必须是一个函数,然后返回一个对象.避免多个组件数据混乱.</h3><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            a: <span class="string">"123"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="列表循环时-尽量使用key-避免元素复用"><a href="#列表循环时-尽量使用key-避免元素复用" class="headerlink" title="列表循环时,尽量使用key,避免元素复用"></a>列表循环时,尽量使用key,避免元素复用</h3><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in array"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="在vue中使用less"><a href="#在vue中使用less" class="headerlink" title="在vue中使用less"></a>在vue中使用less</h3><pre><code>安装less及less-loader依赖<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader --save-dev</span><br></pre></td></tr></table></figure>修改webpack配置文件在单文件组件中使用<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure></code></pre><h3 id="nextTick的用法"><a href="#nextTick的用法" class="headerlink" title="$nextTick的用法"></a>$nextTick的用法</h3><pre><code>异步更新队列:Vue在观察到数据变化时不会直接更新Dom,而是开启一个队列,并缓冲在同一事件循环中发生的所有数据变化,然后去除重复数据,避免重复计算和dom操作,然后在下一个事件循环tick中,刷新队列并执行实际(已去重)的工作.$nextTick就是用来知道什么时候dom更新完成的.<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span>这是一段文本<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getText"</span>&gt;</span>获取div内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当我们点击按钮时,获取div的文本 --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getText: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.isShow = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> text = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>).innerText;</span><br><span class="line">        <span class="built_in">console</span>.log(text);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="webpack打包上传服务器后项目图片路径的问题"><a href="#webpack打包上传服务器后项目图片路径的问题" class="headerlink" title="webpack打包上传服务器后项目图片路径的问题"></a>webpack打包上传服务器后项目图片路径的问题</h3><pre><code>1. 解决方式一:    修改config文件中index.js里assetsPublicPath为&apos;./&apos;,    然后修改webpack.base.conf.js里的url-loader的limit,根据文件大小相应的修改.    但是修改后打包的文件比较大,影响页面加载.2. 解决方式二:    修改config文件中index.js里assetsPublicPath为&apos;./&apos;,然后修改源代码中css的图片路径为绝对路径,    静态资源由之前的src下的assets文件转移到src同级的static文件下新建一个img文件.    如果该项目有两级以上的域名,就在绝对路径前加上该子域名,如&apos;/XXX/static/img/a.png&apos;</code></pre><h3 id="scoped下尽量不要使用标签选择器"><a href="#scoped下尽量不要使用标签选择器" class="headerlink" title="scoped下尽量不要使用标签选择器"></a>scoped下尽量不要使用标签选择器</h3><pre><code>scoped下尽量不要使用标签选择器,会影响页面性能.</code></pre><h3 id="vue组件添加原生事件"><a href="#vue组件添加原生事件" class="headerlink" title="vue组件添加原生事件"></a>vue组件添加原生事件</h3><pre><code>vue组件添加原生事件,必须在事件后添加.native修饰符,否则事件不会生效.     </code></pre><h3 id="在vue中使用TypeScript"><a href="#在vue中使用TypeScript" class="headerlink" title="在vue中使用TypeScript"></a>在vue中使用TypeScript</h3><pre><code>在vue中使用TypeScript1. 安装依赖    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-class-component vue-property-decorator --save</span><br><span class="line">npm i ts-loader typescript tslint tslint-loader tslint-config-standard --save-dev</span><br></pre></td></tr></table></figure>2. 配置webpack    -  找到&apos;./build/webpack.base.conf.js&apos;添加        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;<span class="attr">extensions</span>: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>, <span class="string">'.ts'</span>],&#125;</span><br></pre></td></tr></table></figure>    -  找到module.rules,添加对.ts的解析        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    enforce: <span class="string">'pre'</span>,</span><br><span class="line">    loader: <span class="string">'tslint-loader'</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">    loader: <span class="string">'ts-loader'</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        appendTsSuffixTo: [<span class="regexp">/\.vue$/</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>    - 添加根路径tsconfig.json文件        <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 编译选项</span><br><span class="line">    "compilerOptions": &#123;</span><br><span class="line">        // 输出目录</span><br><span class="line">        "outDir": "./output",</span><br><span class="line">        // 是否包含可以用于 debug 的 sourceMap</span><br><span class="line">        "sourceMap": true,</span><br><span class="line">        // 以严格模式解析</span><br><span class="line">        "strict": true,</span><br><span class="line">        // 采用的模块系统</span><br><span class="line">        "module": "esnext",</span><br><span class="line">        // 如何处理模块</span><br><span class="line">        "moduleResolution": "node",</span><br><span class="line">        // 编译输出目标 ES 版本</span><br><span class="line">        "target": "es5",</span><br><span class="line">        // 允许从没有设置默认导出的模块中默认导入</span><br><span class="line">        "allowSyntheticDefaultImports": true,</span><br><span class="line">        // 将每个文件作为单独的模块</span><br><span class="line">        "isolatedModules": false,</span><br><span class="line">        // 启用装饰器</span><br><span class="line">        "experimentalDecorators": true,</span><br><span class="line">        // 启用设计类型元数据（用于反射）</span><br><span class="line">        "emitDecoratorMetadata": true,</span><br><span class="line">        // 在表达式和声明上有隐含的any类型时报错</span><br><span class="line">        "noImplicitAny": false,</span><br><span class="line">        // 不是函数的所有返回路径都有返回值时报错。</span><br><span class="line">        "noImplicitReturns": true,</span><br><span class="line">        // 从 tslib 导入外部帮助库: 比如__extends，__rest等</span><br><span class="line">        "importHelpers": true,</span><br><span class="line">        // 编译过程中打印文件名</span><br><span class="line">        "listFiles": true,</span><br><span class="line">        // 移除注释</span><br><span class="line">        "removeComments": true,</span><br><span class="line">        "suppressImplicitAnyIndexErrors": true,</span><br><span class="line">        // 允许编译javascript文件</span><br><span class="line">        "allowJs": true,</span><br><span class="line">        // 解析非相对模块名的基准目录</span><br><span class="line">        "baseUrl": "./",</span><br><span class="line">        // 指定特殊模块的路径</span><br><span class="line">        "paths": &#123;</span><br><span class="line">        "jquery": [</span><br><span class="line">            <span class="string">"node_modules/jquery/dist/jquery"</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br><span class="line">        // 编译过程中需要引入的库文件的列表</span><br><span class="line">        "lib": [</span><br><span class="line">        "dom",</span><br><span class="line">        "es2015",</span><br><span class="line">        <span class="string">"es2015.promise"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    - 添加根路径tslint.json文件        <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"extends"</span>: <span class="string">"tslint-config-standard"</span>,</span><br><span class="line">    <span class="attr">"globals"</span>: &#123;</span><br><span class="line">        <span class="attr">"require"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    - 在src下创建vue-shim.d.ts        <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> "*.vue" &#123;</span><br><span class="line">    <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>        之后再代码中引入.vue文件时需要加上.vue后缀,因为ts默认只识别*.ts文件    - 改造APP.vue文件        <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    @Component(&#123;&#125;)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>    - 修改main.js为main.ts,并修改&apos;./build/webpack.base.conf.js&apos;中的entry为 `{app: &apos;./src/main.ts&apos;}`</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单文件组件中data必须是一个函数-然后返回一个对象-避免多个组件数据混乱&quot;&gt;&lt;a href=&quot;#单文件组件中data必须是一个函数-然后返回一个对象-避免多个组件数据混乱&quot; class=&quot;headerlink&quot; title=&quot;单文件组件中data必须是一个函数,
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue 前端" scheme="http://yoursite.com/tags/vue-%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>学习React</title>
    <link href="http://yoursite.com/2017/01/14/%E5%AD%A6%E4%B9%A0React/"/>
    <id>http://yoursite.com/2017/01/14/学习React/</id>
    <published>2017-01-14T03:12:17.000Z</published>
    <updated>2017-12-14T03:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>​    creat-react-app 脚手架安装</p><p>​    <code>npm install -g creat-react-app</code></p><p>​    初始化安装</p><p>​    <code>creat-react-app hello-react</code></p><p>​    启动</p><p>​    <code>cd hello-react</code></p><p>​    <code>npm start</code></p><h3 id="使用jsx"><a href="#使用jsx" class="headerlink" title="使用jsx"></a>使用jsx</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;hello React&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">&lt;header/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>jsx在编译时会变成相应的js对象描述.</p><p>react-dom负责把这个js对象描述变成dom元素并渲染.</p><h3 id="Reader方法"><a href="#Reader方法" class="headerlink" title="Reader方法"></a>Reader方法</h3><p>我们在编写组件时,需要继承react的Component,一个组件类必须实现一个render方法,这个方法返回一个jsx对象,需要注意的是,必须用一个外层的元素把所有内容包裹起来,而不能是几个元素.</p><h5 id="表达式插入"><a href="#表达式插入" class="headerlink" title="表达式插入"></a>表达式插入</h5><p>在jsx中可以插入js表达式,表达式返回的结果会渲染在页面上,表达式用{}包裹,如果包裹的是一个对象,在对象的外面也要加上{}.</p><p>{}内可以放任何js的代码.不仅仅可以放在标签内部,也可以放在标签属性上.</p><p><code>&lt;a className={className}/&gt;</code></p><p>因为class,和for是js关键字,所以在react中用className和htmlFor代替.</p><h5 id="条件返回"><a href="#条件返回" class="headerlink" title="条件返回"></a>条件返回</h5><p>我们可以根据不同的条件返回不同的jsx.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">const</span> isGood = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">    &#123;</span><br><span class="line">              isGood</span><br><span class="line">              ?<span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>isGood<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line">              :<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>is bad<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想要隐藏一个元素,返回一个null即可.</p><h5 id="jsx元素变量"><a href="#jsx元素变量" class="headerlink" title="jsx元素变量"></a>jsx元素变量</h5><p>jsx元素就是js对象,那么jsx元素其实可以像js对象一样赋值给变量,作为函数参数传递或作为函数返回值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为变量</span></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">const</span> isGood = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> good = <span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>isGood<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">const</span> bad = <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>isBad<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">    &#123;isGood?good:bad&#125;</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//作为函数参数传递</span></span><br><span class="line">renderGood(good,bad)&#123;</span><br><span class="line">  <span class="keyword">const</span> isGood = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> isGood?good:bad</span><br><span class="line">&#125;</span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;<span class="keyword">this</span>.renderGood(<span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>isGood<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span>,&lt;span&gt;isBad&lt;<span class="regexp">/span&gt;)&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件的组合-嵌套和组件树"><a href="#组件的组合-嵌套和组件树" class="headerlink" title="组件的组合,嵌套和组件树"></a>组件的组合,嵌套和组件树</h3><p>自定义的组件必须用大写字母开头,普通html标签用小写字母开头.</p><p>组件之间可以组合,嵌套.就像普通的html标签一样使用就可以,这样组合嵌套最后构成一个组件树,来表示它们之间的关系.</p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>在react中监听事件甚至需要给监听的元素加上类似于<code>onClick</code>和<code>onKeyDown</code>这样的属性,紧跟的是一个表达式插入,这个表达式返回一个实例方法.</p><p>在react中不需要调用浏览器原生的addEventListener进行事件监听,react帮我们封装好了一系列的on*的属性,而且不用考虑不同浏览器之间的兼容问题.如果需要用到事件对象event,在函数中传入e参数即可,react把event对象也做了封装.</p><p>一般在某个类的实例方法中,this指的就是这个实例本身,但在react中,调用你传给它方法的时候,并不是通过对象方法的方式调用(this.handleclick),而是通过函数调用(handleClick),所以在事件监听函数中的this是null或undefined.<strong>当你想在函数中使用当前实例的时候,需要手动将实例方法bind到当前实例再传给react,这种方式在react中非常常见.</strong></p><p><strong>这些on*事件只能用在普通的html元素上,不能用在组件标签上</strong></p><h3 id="组件的state和setState"><a href="#组件的state和setState" class="headerlink" title="组件的state和setState"></a>组件的state和setState</h3><p>一个组件的显示形态是由它的数据状态和配置参数决定的.一个组件可以拥有自己的状态,就像一个点赞按钮,有点赞状态和未点赞状态,并可以再这两种状态之间来回切换.state就是存储这种可变化的状态的.改变状态时不能直接赋值,可以使用setState方法来改变状态.<strong>当我们调用setState时,react会更新组件状态,重新调用render方法,然后再把render方法所渲染的最新内容显示到页面上.state方法接受一个对象或函数作为参数</strong>如果我们用<code>this.state=XXX</code>,React就没办法知道你修改了组件的状态.</p><h5 id="state接收对象参数"><a href="#state接收对象参数" class="headerlink" title="state接收对象参数"></a>state接收对象参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">  <span class="keyword">super</span>(props)</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    name: <span class="string">'tom'</span>,</span><br><span class="line">    isLicked: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">handleClick()&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">isLicked</span>: !<span class="keyword">this</span>.state.isLicked&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="state接收函数作为参数"><a href="#state接收函数作为参数" class="headerlink" title="state接收函数作为参数"></a>state接收函数作为参数</h5><p><strong>再调用setState时,react不会马上修改state,而是把这个对象放到一个更新队列中,稍后才回从多个队列中把新状态计算合并提取出来合并到state,再触发更新</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象作为参数</span></span><br><span class="line">handClick()&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:<span class="number">0</span>&#125;)<span class="comment">//this.state.count还是undefined</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;)<span class="comment">//undefined+1=NaN</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">2</span>&#125;)<span class="comment">//NaN+2=NaN</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数作为参数可以接受一个参数作为上次setState的返回值</span></span><br><span class="line">handClick()&#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;<span class="comment">//0</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>: prevState.count +<span class="number">1</span>&#125;<span class="comment">//0+1=1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>: prevState.count+<span class="number">2</span>&#125;<span class="comment">//1+2=3</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行3次setState,但组件只会渲染一次.因为react会把所有事件循环中的消息队列中的state合并再渲染.</span></span><br></pre></td></tr></table></figure><h3 id="配置组件的props"><a href="#配置组件的props" class="headerlink" title="配置组件的props"></a>配置组件的props</h3><p>一个组件可能在不同的地方用到,所以组件要有一定的可配置性.每个组件都可以接收一个props参数,他是一个对象,包含你对这个组件的配置.</p><p>组件内部是通过this.props的方式来获取组件的参数,如果this.props有需要的属性就采用,没有的话就默认.</p><p>再使用一个组件的时候,可以把参数放在标签中的属性中,所以属性都会作为props对象的键值.</p><h5 id="默认配置defaultProps"><a href="#默认配置defaultProps" class="headerlink" title="默认配置defaultProps"></a>默认配置defaultProps</h5><p>我们可以通过||操作符来实现默认配置,<code>const word = this.props.like || &#39;已赞&#39;</code>React也提供了一种方式defaultProps来配置默认配置.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikeBtn</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    like: <span class="string">'取消'</span>,</span><br><span class="line">    unlike: <span class="string">'点赞'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line"><span class="keyword">this</span>.state = &#123;<span class="attr">isLike</span>: <span class="literal">false</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="props不可变"><a href="#props不可变" class="headerlink" title="props不可变"></a>props不可变</h5><p>props一旦传入进来就不能改变.如果我们使用<code>this.props.like=&#39;取消&#39;</code>控制台会直接报错.</p><p>你不能改变一个组件被渲染时传进来的props,因为如果渲染过程中可以改变会导致组件的显示形态和行为变得不可预测.</p><p>但这并不意味这props永远不能修改,组件的使用者可以主动的通过重新渲染的方式把新的props传入到组件中.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line"> &lt;LikeBtn like=&#123;<span class="keyword">this</span>.state.like&#125;&gt; </span><br><span class="line">    &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在这里,我们把state中的数据传给props,但我们点击按钮时,我们使用setState改变state的值,并导致页面重新渲染,改变后的state会传给新的props.</p><h3 id="state-VS-props"><a href="#state-VS-props" class="headerlink" title="state VS props"></a>state VS props</h3><p>state的主要作用是用于组件保存,控制,修改自己的状态.state在组件内部初始化,可以被自身修改,但不能被外界访问和修改.可以把state当做一个局部的只能被自身控制的数据源.通过this.setState进行更新,该方法会导致组件重新渲染.</p><p>props主要作用是可以传入参数来配置该组件,组件内部无法控制和修改,除非外部主动传入新的props,否则组件的props永远保持不变.</p><p>一个组件的state中的数据可以传给子组件的props,一个组件也可以使用外部传入的props来初始化自己的state.但他们职责非常清晰<strong>state是让组件控制自己的状态,props是让外部对组件自己进行配置,尽量少的用state,尽量多的使用props</strong></p><h5 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HelloWorld = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sayHi = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    alert(<span class="string">"helloWorld"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">  &lt;div onClick=&#123;sayHi&#125;&gt;helloWorld&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>以前的一个组件时通过继承Component来构建,一个子类就是一个组件,而用函数式编写方式是一个函数就是一个组件,你可以和之前使用<helloworld>使用该组件.不同的是,函数式组件只能接受props而无法和类组件一样在constructor里面初始化state.函数式组件就是一种只接受props和提供render方法的类组件.</helloworld></p><h3 id="渲染列表数据"><a href="#渲染列表数据" class="headerlink" title="渲染列表数据"></a>渲染列表数据</h3><h5 id="渲染存放jsx元素的数组"><a href="#渲染存放jsx元素的数组" class="headerlink" title="渲染存放jsx元素的数组"></a>渲染存放jsx元素的数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;[</span><br><span class="line">     &lt;span&gt;<span class="number">1</span>&lt;<span class="regexp">/span&gt;,</span></span><br><span class="line"><span class="regexp">     &lt;span&gt;2&lt;/</span>span&gt;,</span><br><span class="line">     &lt;span&gt;<span class="number">3</span>&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">     ]&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你往{}里放一个数组,react会把数组中的元素依次渲染出来.</p><h5 id="使用map渲染列表数据"><a href="#使用map渲染列表数据" class="headerlink" title="使用map渲染列表数据"></a>使用map渲染列表数据</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123;<span class="attr">userName</span>:<span class="string">'tom'</span>,<span class="attr">age</span>:<span class="number">21</span>,<span class="attr">gender</span>:<span class="string">'male'</span>&#125;,</span><br><span class="line"> &#123;<span class="attr">userName</span>:<span class="string">'jerry'</span>,<span class="attr">age</span>:<span class="number">23</span>,<span class="attr">gender</span>:<span class="string">'male'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">userName</span>:<span class="string">'lily'</span>,<span class="attr">age</span>:<span class="number">41</span>,<span class="attr">gender</span>:<span class="string">'male'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">userName</span>:<span class="string">'lucy'</span>,<span class="attr">age</span>:<span class="number">31</span>,<span class="attr">gender</span>:<span class="string">'male'</span>&#125;,</span><br><span class="line">]</span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">const</span> userEle = []<span class="comment">//保存渲染后的jsx数组</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> user <span class="keyword">of</span> users)&#123;</span><br><span class="line">    userEle.push(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;user.userName&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span&gt;&#123;user.age&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;span&gt;&#123;user.gender&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">  &lt;div&gt;&#123;userEle&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/但我们一般不会手动写循环来构建jsx结构,而是用es6 的map方法</span></span><br><span class="line"><span class="regexp">render()&#123;</span></span><br><span class="line"><span class="regexp">  return(</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &#123;</span></span><br><span class="line"><span class="regexp">      users.map((user,index,arr)=&gt;&#123;</span></span><br><span class="line"><span class="regexp">      return(</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span&gt;&#123;&#123;user.userName&#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;user.age&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;&#123;&#123;user.gender&#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你会发现,react报错了,因为<strong>对于用表达式套数组罗列到页面上的元素,都要为每个元素加上key属性,这个key必须是每个元素的标识</strong></p><h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><p>在编写组件时,当有别的组件依赖或影响某个组件的某个状态state时,我们通常将这种组件之间共享的状态交给组件最近的公共父节点保管,然后通过props把状态传递给子组件,这样就可以在组件之间共享数据了.这种方式在React中被称为<strong>状态提升</strong>.</p><p>如果这个公共的分组件只是组件树下很小的一个子树,我们需要一直把状态提升上去,一旦发生提升,就需要修改原来保存状态以及传递数据的所有代码,这种无限制的提升并不是一个好的方案.</p><p><strong>如何更好的管理被多喝组件依赖的状态?</strong>React并没有提供更好的解决方案,我们可以引入Redux状态管理工具来帮助我们解决这种共享状态.对于不会被外界依赖和影响的状态,一般只保存在组件内部即可,不需要做提升.</p><h3 id="挂载阶段组件的生命周期"><a href="#挂载阶段组件的生命周期" class="headerlink" title="挂载阶段组件的生命周期"></a>挂载阶段组件的生命周期</h3><p>我们来看看下面这段代码发生了什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">&lt;Header/&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">//1.实例化一个Header</span></span><br><span class="line"><span class="keyword">const</span> header = <span class="keyword">new</span> Header(props,children)</span><br><span class="line"><span class="comment">//2.调用header.render</span></span><br><span class="line"><span class="keyword">const</span> headerJsx = header.render()</span><br><span class="line"><span class="comment">//3.构建真正的DOM元素</span></span><br><span class="line"><span class="keyword">const</span> headerDom = createDOM(...)</span><br><span class="line"><span class="comment">//4. 把DOM元素追加到页面上</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'root'</span>).appendChild(headerDOm)</span><br></pre></td></tr></table></figure><p>上面这个过程称为<strong>组件的挂载,这是一个从无到有的过程</strong></p><p>React为了更好的掌握组件的挂载过程,提供了一系列等生命周期函数.包括了两个挂载函数.</p><p><code>componentWillMount</code>和<code>componentDIdMount</code>.当我们在页面渲染后删除了某个元素后,也有对应的函数<code>componentWillUnmount</code>.</p><p>他们之间的顺序为</p><pre><code>1. constructor  (指向prototype对象所在的构造函数,关于组件自身状态的初始化)2. component will mount (组件将要挂载,一般组件启动的动作,包括ajax数据的拉取,设置定时器等等在此进行)3. render (返回jsx元素)4. component did mount (组件已经挂载,当组件的启动工作依赖dom时,例如动画,就可以放在这里.)5. component will unmount (组件将要移除,在组件销毁时清除该组件定时器和其他数据清理工作)</code></pre><h3 id="更新阶段的组件生命周期"><a href="#更新阶段的组件生命周期" class="headerlink" title="更新阶段的组件生命周期"></a>更新阶段的组件生命周期</h3><p>除了挂载阶段,还有一种更新阶段.setState导致react重新渲染组件就是一个组件的变化过程.</p><ol><li><code>shouldComponentUpdate(nextProps,nextState)</code>: 你可以通过这个方法控制组件是否重新渲染,如果返回false就不重新渲染,该生命周期在性能优化上非常有用.</li><li><code>componentWillReceiveProps(nextProps)</code>:组件从父组件接收到新的<code>props</code>之前调用.</li><li><code>componentWillUpdate()</code>:组件重新渲染之前调用.</li><li><code>componentDIdUpdate()</code>:重新渲染后调用.</li></ol><h3 id="ref-和-React-中的-DOM-操作"><a href="#ref-和-React-中的-DOM-操作" class="headerlink" title="ref 和 React 中的 DOM 操作"></a>ref 和 React 中的 DOM 操作</h3><p>React中我们很少和打交道,有一系列的on*方法帮我们进行事件监听,我们不再需要调用addEventListener的DOM API,我们通过setState重新渲染组件,渲染时把新的props传给子组件达到页面更新效果,而不再借用jQuery进行页面更新.</p><p>但React并不能满足所有的DOM操作,比如进入页面自动focus到某个输入框,.比如你想获取某个元素的尺寸在做后续动画等等.所以它提供了<code>ref</code>属性帮助我们获取已经挂在的dom节点,你可以给某个JSX元素加上ref属性.</p><p><code>&lt;input ref={(input)=&gt;{this.input = input}}&gt;</code></p><p>我们给input加了一个ref属性,该属性是一个函数,该元素在页面上挂载完毕后调用这个函数,并把这个挂载后的dom节点传给这个函数.我们把元素赋值给组件实例的一个属性,这样就可以通过this.input获取这个DOM元素.</p><p>如果给组件挂载ref,那么我们获取的是这个组件在react内部初始化的实例,这并不常用,不建议这样做.</p><h3 id="props-children-和容器类组件"><a href="#props-children-和容器类组件" class="headerlink" title="props.children 和容器类组件"></a>props.children 和容器类组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">&lt;Card&gt;</span><br><span class="line">  &lt;h1&gt;I<span class="string">'m H1&lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;div&gt;I'</span>m Div&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Card&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">      &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">    &#123;<span class="keyword">this</span>.props.children[<span class="number">0</span>]&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在使用自定义组件时,可以再组件内部嵌套jsx结构.嵌套的结构可以再组件内部通过props.children获取到,这种组件编写方式在编写容器类型的组件当中非常有用,而在实际React项目中,我们几乎每天都需要用这种方式编写组件.</p><h3 id="dangerouslySetHTML-和-style-属性"><a href="#dangerouslySetHTML-和-style-属性" class="headerlink" title="dangerouslySetHTML 和 style 属性"></a>dangerouslySetHTML 和 style 属性</h3><p>#####dangerouslySetHTML</p><p>出于安全因素(XSS攻击),React会把所有表达式插入的内容都自动转义.类似于jQuery的text().</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> header = <span class="string">'&lt;h1&gt;helloWorld&lt;/h1&gt;'</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line"> &#123;header&#125; </span><br><span class="line"> &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/因为react的自动转义,并不会渲染&lt;h1&gt;元素,而是显示文本形式</span></span><br></pre></td></tr></table></figure><p>如何做到动态设置HTML效果呢?我们可以给元素设置一个<code>dangerouslySetHTML</code>属性传入一个对象,这个对象的<code>__html</code>属性值就相当于<code>innerHTML</code>,就可以动态渲染元素结构了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div </span><br><span class="line">dangerouslySetHTML=&#123;&#123;<span class="attr">__html</span>:<span class="string">'&lt;h1&gt;helloworld&lt;/h1&gt;'</span>&#125;&#125;</span><br><span class="line">className=<span class="string">"container"</span>&gt;</span><br><span class="line">&lt;div&gt;</span><br></pre></td></tr></table></figure><p>之所以搞这么复杂是因为设置这个属性可能会导致跨站脚本攻击,不必要的情况就不要使用.</p><h5 id="style"><a href="#style" class="headerlink" title="style"></a>style</h5><p>普通DOM元素中的style</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">"font-size:14px;color:red;"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>React中需要把css属性变为对象再传给元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style=&#123;&#123;<span class="attr">fontSize</span>:<span class="string">'14px'</span>,<span class="attr">color</span>:<span class="string">'red'</span>&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>style接收一个对象,里面是css属性键值对,原来css带’-‘的属性都需要换成驼峰命名法.我们可以用props或者state中的数据生成样式对象再传给元素,再用setState修改样式,非常灵活.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style=&#123;&#123;<span class="attr">fontSize</span>:<span class="string">'14px'</span>,<span class="attr">color</span>:<span class="keyword">this</span>.state.color&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">color</span>:<span class="string">'blue'</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="PropTypes和组件参数验证"><a href="#PropTypes和组件参数验证" class="headerlink" title="PropTypes和组件参数验证"></a>PropTypes和组件参数验证</h3><p>React提供一种机制,可以给组件的配置参数加上类型验证.我们需要安装React提供的第三方库<code>prop-types</code></p><p><code>npminstall --save prop-types</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    text: PropTypes.string.isRequired</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropTypes提供的参数有:array,bool,func,number,object,string,node,element…</p><h3 id="react规范组件和方法命名"><a href="#react规范组件和方法命名" class="headerlink" title="react规范组件和方法命名"></a>react规范组件和方法命名</h3><pre><code>1. static开头的类属性,如`defaultProps`,`propTypes`2. 构造函数,constructor3. getter/setter4. 组件生命周期5. _开头的私有方法6. 事件监听方法,handle**7. render*()表示不同render()内容的函数</code></pre><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><p>高阶组件就是一个函数,传给它一个组件作为函数的参数,它返回一个新的组件.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (OldComponent,name)=&gt;&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">NewComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">      <span class="keyword">super</span>()</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;<span class="attr">data</span>:<span class="literal">null</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">      <span class="keyword">let</span> data = localStorage.getItem(name)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;data&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">OldComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">OldComponent</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NewComponent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么使用这个高阶组件呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> NewComponent <span class="keyword">from</span> <span class="string">'./NewComponent'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputName</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;this.props.data&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">InputName = NewComponent(InputName,'username')</span></span><br><span class="line"><span class="xml">export default InputName</span></span><br></pre></td></tr></table></figure><p>其实高阶组件就是为了组件之间的代码复用.组件可能有着相同的逻辑,把这些逻辑抽取出来,放在高阶组件里进行复用.高阶组件内部包装的组件和被包装的组件通过props传递数据.</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>context(上下文)是React中一个比较特殊的东西.某个组件只要往自己的context里面放一些状态,这个组件下的所有子组件都可以直接访问而不用通过中间组件一层层传递,它的父组件则不能访问到.</p><p>context打破了组件之间通过props传递数据的规范,增强了组件间的耦合性.就像全局变量一样,每个组件都能随意访问和修改,这会让程序运行不可预料.</p><p>一些第三方状态管理的库就是充分利用了这种机制给我们提供了极大地便利,所以我们一般不手写context,也不要用它,需要时用这些第三方的应用状态管理库即可.</p><p>本文参考<a href="http://huziketang.com/books/react/lesson1" target="_blank" rel="external">胡子大哈的React小书,详情请点击</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;​    creat-react-app 脚手架安装&lt;/p&gt;
&lt;p&gt;​    &lt;code&gt;npm install -g creat-reac
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端 React" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF-React/"/>
    
  </entry>
  
  <entry>
    <title>用NodeJS写一个爬虫</title>
    <link href="http://yoursite.com/2016/12/05/%E7%94%A8NodeJS%E5%86%99%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2016/12/05/用NodeJS写一个爬虫/</id>
    <published>2016-12-05T07:45:03.000Z</published>
    <updated>2017-12-05T07:51:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>用NodeJS下一个爬虫,用来获取简书首页的文章,然后保存以txt文件的形式保存在本地,数量为20篇.</p><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>​   npm init || yarn init</p><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>​   npm install superagent cheerio —save || yarn add superagent cheerio</p><h4 id="页面数据下载"><a href="#页面数据下载" class="headerlink" title="页面数据下载"></a>页面数据下载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">"superagent"</span>)</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">"cheerio"</span>)</span><br><span class="line"><span class="keyword">let</span> reptileUrl = <span class="string">"http://www.jianshu.com/"</span></span><br><span class="line"></span><br><span class="line">request</span><br><span class="line">    .get(reptileUrl)</span><br><span class="line">    .end(<span class="function"><span class="keyword">function</span>(<span class="params">err,res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> $ = cheerio.load(res.text,&#123;<span class="attr">decodeEntities</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">            <span class="comment">//每页有20篇文章,找到标题及其href的值</span></span><br><span class="line">            $(<span class="string">"#list-container .note-list li"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,value</span>)</span>&#123;</span><br><span class="line">              <span class="keyword">let</span> url = $(v).find(<span class="string">".title"</span>).attr(<span class="string">"href"</span>)</span><br><span class="line">              <span class="comment">//url即文章的链接,需要和reptileUrl拼接起来</span></span><br><span class="line">              getContent(url)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h4 id="获取文章内容-保存在本地"><a href="#获取文章内容-保存在本地" class="headerlink" title="获取文章内容,保存在本地"></a>获取文章内容,保存在本地</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getContent</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> adress = reptileUrl + url</span><br><span class="line">  request</span><br><span class="line">    .get(adress)</span><br><span class="line">    .end(<span class="function"><span class="keyword">function</span>(<span class="params">err,res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> $ = cherrio.load(res.text,&#123;<span class="attr">decodeEntities</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">          <span class="comment">//文章标题</span></span><br><span class="line">          <span class="keyword">let</span> title = $(<span class="string">".article .title"</span>).text()</span><br><span class="line">          <span class="comment">//文章内容</span></span><br><span class="line">          <span class="keyword">let</span> content = <span class="string">''</span></span><br><span class="line">          $(<span class="string">".article .show-content p"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">i, v, a</span>) </span>&#123;</span><br><span class="line">             content += $(v).text();</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">//要写入的数据</span></span><br><span class="line">          <span class="keyword">let</span> data = &#123;</span><br><span class="line">            title: title,</span><br><span class="line">            content: content</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//本地保存</span></span><br><span class="line">          fs.writeFile(<span class="string">'../data/'</span> + title + <span class="string">'.txt'</span>, <span class="built_in">JSON</span>.stringify(data), <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">"It's OK !"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;用NodeJS下一个爬虫,用来获取简书首页的文章,然后保存以txt文件的形式保存在本地,数量为20篇.&lt;/p&gt;
&lt;h4 id=&quot;初始化项目&quot;
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="node 爬虫" scheme="http://yoursite.com/tags/node-%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>重温&lt;&lt;计算机操作系统&gt;&gt;</title>
    <link href="http://yoursite.com/2015/10/18/%E9%87%8D%E6%B8%A9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2015/10/18/重温-计算机操作系统/</id>
    <published>2015-10-18T07:19:25.000Z</published>
    <updated>2017-11-14T06:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>并行是指两个或多个事件在同一时刻发生,而并发是两个或多个事件在同一时间间隔内发生.在多道程序环境下,并发性是指在一段时间内宏观上有多个程序在同时运行,但在单处理机系统中,每一时刻却仅能有一道程序执行,故微观上这些程序只能是分时的交替执行.倘若在多处理机,这些可以并发执行的程序便可分配到多个处理机上,实现并行执行.</p><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>如果某个系统支持两个或多个动作<strong>同时存在</strong>,name这个系统就是一个并发系统.如果某个系统支持两个或多个动作<strong>同时执行</strong>,那么这个系统就是一个并行系统.并发系统与并行系统这两个定义之间的关键差异在于<strong>存在</strong>这个词.  在并发程序中可以同时拥有两个或多个线程,这意味着,如果程序在单核处理器上运行,那么这两个线程将交替换入或换出内存.这些线程是同时<strong>存在</strong>的,每个线程都处于执行过程中的某个状态.如果程序能够并行执行,那么就一定是运行在多核处理器上的.此时,程序中的每个线程都将分配到一个独立的处理器核上,因此可以同时运行.  我相信你已经能够得出结论:”并行概念是并发概念的一个子集”.也就是说,你可以编写一个拥有多个线程或进程的并发程序,但如果没有多核处理器来执行这个程序,那么就不能以并行的方式来运行代码.因此,凡是在求解单个问题涉及多个执行流程的编程模式或执行行为,都属于并发编程的范畴.  摘自:&lt;&lt;并发的艺术&gt;&gt;-[美]布雷谢斯 </p><p>Erlang 之父 Joe Armstrong 用一张5岁小孩都能看懂的图解释了并发与并行的区别.<br><img src="http://oy299xjr2.bkt.clouddn.com/v2-674f0d37fca4fac1bd2df28a2b78e633_r.jpg" alt="并发与并行图解"><br>从图中可以看出,并发是两个队列交替使用一台咖啡机,并行是两个队列同时使用两台咖啡机.如果串行,一个队列使用一台咖啡机.并发和并行都可以是多个线程,就看这些线程能不能同时被多个CPU执行,如果可以说明是并行,而并发是多个线程被一个CPU轮流切换着执行.</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>对进程较为经典的定义有:</p><pre><code>1. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动.2. 进程是程序在一个数据集合上运行的过程,它是系统进行资源分配和调度的一个独立单位.3. 系统为每个进程定义了一个数据结构-进程控制块(PCB).OS根据PCB来对并发执行的进程进行控制和管理.</code></pre><p>线程和进程的比较: </p><pre><code>1. 再引入线程的操作系统中,通常一个进程都拥有若干个线程,至少有一个线程.2. 进程为资源拥有的最小单位,而线程作为调度和分派的基本单位,线程不拥有系统资源,可以访问资源.</code></pre><h4 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h4><p>进程和线程的主要差别在于他们是不同的操作系统资源的管理方式.进程有独立的地址空间,一个进程崩溃后,在保护模式下不会对其他进程产生影响,而线程只是一个进程中的不同执行路径.线程有自己的堆栈和局部变量,但线程没有单独的地址空间,一个线程死掉就等于整个进程死掉,所以在进程切换时,耗费资源较大,效率变差.但对于一些要求同时进行并且又要共享某些变量的并发操作,只能用进程,不能用线程.</p><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>生产者消费者问题是一个经典的多进程同步问题,也叫缓存绑定问题.  既有两个进程:一组生产者进程和一组消费者进程共享一个初始值为空固定大小为n的缓存区.生产者的工作是制造一段数据,只要缓存没满就放入缓存区,否则必须等待,如此反复.同时,只要缓存区不为空,消费者才能从中取出消息,一个取出一段数据,否则只能等待.由于缓存区是临界资源,它只允许一个生产者放入消息,或一个消费者从中取出消息.  问题的核心是要保证不让生产者在缓存满的时候还要向内写数据,不让消费者试图从空的缓存中取出数据.</p><h4 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h4><p>生产者和消费者对缓存区互斥访问是互斥关系,同时又是相互协作关系,即同步关系.那么需要解决的是互斥和同步PV操作的位置.使用”进程间通信”即可解决唤醒问题:  我们使用了两个信号标:full和empty.信号量mutex作为互斥信号量.用于控制互斥访问缓存池,互斥信号量初始值为1.信号量full用于记录当前缓冲池中”满”缓冲区数,初始值为0.信号量empty用于记录当前缓存区”空”缓存区数,初始值为n.新的数据增加后,full增加,empty减少.如果生产和试图在empty为0时减少其值,生产者就会被”催眠”.下一轮中有数据消费掉时,empty就会增加,生产者就会被”唤醒”.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//临界区互斥信号量</span></span><br><span class="line">semaphore empty = n;<span class="comment">//空闲缓存区</span></span><br><span class="line">semaphore full = <span class="number">1</span>;<span class="comment">//缓存区初始化为空</span></span><br><span class="line">produce()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        produce an item in dextp;<span class="comment">//生产数据</span></span><br><span class="line">        P(empty);<span class="comment">//获取空缓存区单元</span></span><br><span class="line">        P(mutex);<span class="comment">//进入临界区</span></span><br><span class="line">        add nextp to buffer;<span class="comment">//将数据放入缓存区</span></span><br><span class="line">        V(mutex);<span class="comment">//离开临界区,释放互斥信号量</span></span><br><span class="line">        V(full)<span class="comment">//满缓存区加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consume()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full);<span class="comment">//获取满缓存区单元</span></span><br><span class="line">        P(mutex);<span class="comment">//进入临界区</span></span><br><span class="line">        remove an item from buffer;<span class="comment">//拿走数据</span></span><br><span class="line">        V(mutex);<span class="comment">//离开临界区</span></span><br><span class="line">        V(empty);<span class="comment">//空缓存区单元加1</span></span><br><span class="line">        consume the item<span class="comment">//消费数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发与并行&quot;&gt;&lt;a href=&quot;#并发与并行&quot; class=&quot;headerlink&quot; title=&quot;并发与并行&quot;&gt;&lt;/a&gt;并发与并行&lt;/h2&gt;&lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概
      
    
    </summary>
    
      <category term="理解计算机" scheme="http://yoursite.com/categories/%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="计算机基础 操作系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
