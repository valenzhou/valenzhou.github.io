<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.喵的网络日志</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-08-31T03:51:19.126Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ValenZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读&lt;&lt;穷爸爸富爸爸&gt;&gt;</title>
    <link href="http://yoursite.com/2021/10/19/%E8%AF%BB%3C%3C%E7%A9%B7%E7%88%B8%E7%88%B8%E5%AF%8C%E7%88%B8%E7%88%B8%3E%3E/"/>
    <id>http://yoursite.com/2021/10/19/读&lt;&lt;穷爸爸富爸爸&gt;&gt;/</id>
    <published>2021-10-19T03:47:30.000Z</published>
    <updated>2021-08-31T03:51:19.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读-lt-lt-穷爸爸富爸爸-gt-gt"><a href="#读-lt-lt-穷爸爸富爸爸-gt-gt" class="headerlink" title="读&lt;&lt;穷爸爸富爸爸&gt;&gt;"></a>读&lt;&lt;穷爸爸富爸爸&gt;&gt;</h1><h3 id="第一课-富人不为钱工作"><a href="#第一课-富人不为钱工作" class="headerlink" title="第一课 富人不为钱工作"></a>第一课 富人不为钱工作</h3><p>生活推着我们所有的人，有些人放弃了，有些人在抗争。少数人学会了这门课程，取得了进步，他们欢迎生活来推动他们，对他们来说，这种推动意味着他们需要并愿意去学习一些东西。他们学习，然后取得进步。但大多数人放弃了，还有一部分人像你一样在抗争。</p><p>有些人因为他们和他们的家庭需要钱而接受这份工资。但他们所做的也只是等待，等待加薪，因为他们认为更多的钱能解决问题。大部分人接受这样的工资，还有一些人会再找一份工作，仍旧干得很努力，但仍只能得到很少的报酬。</p><p>正是出于恐惧的心理，人们才想找一份安稳的工作。这些恐惧有：害怕付不起账单，害怕被解雇，害怕没有足够的钱，害怕重新开始。为了寻求保障，他们会学习某种专业，或是做生意，拼命为钱而工作。大多数人成了钱的奴隶，然后就把怒气发泄在他们老板身上。</p><p>大多数人都希望有一份工资收入，因为他们都有恐惧和贪婪之心。一开始，没钱的恐惧会促使他们努力工作，得到报酬后，贪婪或欲望又让他们想拥有所有用钱能买到的好东西。于是就形成了一种模式。起床，上班，付账，再起床，再上班，再付账他们的生活从此被这两种感觉所控制：恐惧和贪婪。给他们更多的钱，他们就会以更高的开支重复这种循环。</p><p>当你长大后，你想要的玩具会更贵，会变成要让你的朋友羡慕的汽车、游艇和大房子，恐惧把你推出门外，欲望又开始召唤你，诱惑你去触礁。这就是陷阱。钱就是驴子面前的胡萝卜，是幻象。如果驴子能了解到全部事实，它可能会重新想想是否还要去追求胡萝卜。</p><p>你们越快忘记你们的工资，你们未来的生活就会越轻松，继续用你们的头脑思考，不求回报地工作，很快就会发现比拿工资更挣钱的方法。你们会看到别人看不见的东西。机会就摆在人们面前，但大多数人从来看不到这些机会，因为他们忙着追求金钱和安定，所以只能得到这些。如果你们能看到一个机会，就注定你们会在一生中不断地发现机会。</p><h3 id="第二课：为什么要学习财务知识"><a href="#第二课：为什么要学习财务知识" class="headerlink" title="第二课：为什么要学习财务知识"></a>第二课：为什么要学习财务知识</h3><p>我想有太多人过多地关注钱，而不是关注他们最大的财富——所受的教育。如果人们能灵活一些，保持开放的头脑不断学习，他们将在时代的变化中一天天地富有起来。如果人们认为钱能解决一切问题，恐怕他们的日子就不会太好过。只有知识才能解决问题并创造财富，那些不是靠财务知识挣来的钱也不会长久。从长远来看，重要的不是你挣了多少钱，而是你能留下多少钱，以及能够留住多久。</p><p>你必须明白资产和负债的区别，并且购买资产。这就是第一条规则，也是唯一一条规则。</p><p>资产是能把钱放进你口袋里的东西。负债是把钱从你口袋里取走的东西。<br>富爸爸和穷爸爸在对待房子问题上的不同观念，一个认为他的房子是资产，另一个则认为是负债。拥有房子后带来的附属支出,房子越大支出就越大，现金就会通过支出不断地流出。我很清楚那不是资产，而是负债，因为它把钱从我们口袋中掏走了。</p><ol><li>对于房子，我要指出大多数人一生都在为一所他们从未真正拥有的房子而辛苦地工作。</li><li>即使人们住房按揭贷款的利息是免税的，他们还是要先还清各期贷款后，才能以税后收入支付各种开支。</li><li>财产税。</li><li>房子的价值并不总是在上升。</li><li>最大的损失是致富机会的损失。如果你所有的钱都投在了房子上，你就不得不努力工作，因为你的现金正不断地从支出项流出，而不是流入资产项，这是典型的中产阶级现金流模式。</li><li>失去了用其他资产增值的时机。</li><li>本可以用来投资的资本将用于支付房子高额的维修和保养费用。</li><li>失去受教育的机会。</li></ol><p>为什么富人会越来越富。资产项产生的收入足以弥补支出，还可以用剩余的收入对资产项进行再投资。资产项不断增长，相应的收入也会越来越多。弄清资产与负债的区别，一旦你明白了这种区别，你就会竭尽全力只买入能带来收入的资产，这是你走上致富之路的最好办法。坚持下去，你的资产就会不断增加。同时还要注意降低负债和支出，这也会让你有更多的钱投入资产项。很快，你就会有钱来考虑进行一些投资了，这些投资能给你带来100%，甚至是无限的回报。</p><h3 id="第三课：关注自己的事业"><a href="#第三课：关注自己的事业" class="headerlink" title="第三课：关注自己的事业"></a>第三课：关注自己的事业</h3><p>存在财务问题的人经常耗费一生为别人工作，其中许多人在他们不能工作时就变得一无所有。请注意，你的职业和你的事业有很大的差别。我经常问人们：你的事业是什么？他们会说：我在银行工作。接着我问他们是否拥有一家银行，他们通常回答：不是的，我只在那儿工作。</p><p>对成年人而言，把支出保持在低水平、减少借款并勤劳地工作会帮你打下一个稳固的资产基础。</p><p>富人与穷人一个重要的区别就是：富人最后才买奢侈品，而穷人和中产阶级会先买下诸如大房子、珠宝、皮衣、宝石、游艇等奢侈品，因为他们想让自己看上去很富有。真正的奢侈品是对投资和积累真正资产的奖励。例如，当我通过房地产生意获得了额外的收入时，去买了辆奔驰汽车。这不是因为增加工作量或是冒着风险才买下的，是在房地产生意上的收益支付了这辆车。</p><h3 id="第四课：税收的历史和公司的力量"><a href="#第四课：税收的历史和公司的力量" class="headerlink" title="第四课：税收的历史和公司的力量"></a>第四课：税收的历史和公司的力量</h3><p>事实上富人并未被征税，是中产阶级尤其是受过良好教育的高收入的中产阶级在为穷人支付税金。税收的初衷是惩罚有钱人，而现实却是它惩罚了对它投赞同票的中产阶级和穷人。政府对钱的胃口越来越大，以致中产阶级也要被征税，且税收的范围不断向穷人扩展。</p><p>财商是由4个方面的专门知识构成的：<br>第一是会计，也就是我说的财务知识。<br>第二是投资，我把它称为钱生钱的科学。<br>第三是了解市场，它是供给与需求的科学。这要求了解受感情驱动的市场的技术面。<br>第四是法律。例如：了解减税优惠政策和公司法的人会比雇员和小业主更快致富。</p><h3 id="第五课：富人的投资"><a href="#第五课：富人的投资" class="headerlink" title="第五课：富人的投资"></a>第五课：富人的投资</h3><p>我意识到过分的害怕和自我怀疑是毁掉我们才能的最大因素。看到有些人明明知道该做什么，却缺乏勇气付诸实际，我就感到十分悲哀。在现实生活中，人们往往是依靠勇气而不是智慧去取得领先的位置的。</p><p>300年前，土地是一种财富，所以，谁拥有土地，谁就拥有财富。后来，美国依靠工厂和工业产品上升为世界头号强国，工业家占有了财富。今天，信息便是财富。问题是，信息以光一样的速度在全世界迅速传播，这种新的财富不再像土地和工厂那样具有明确的范围和界限。变化会越来越快，越来越显著，百万富翁的人数会极大地增加，同样，也会有许多人被远远地抛在后面。</p><p>如果你清楚自己在做什么，就不是在赌博；如果你把钱投进一笔交易然后只是祈祷，才是在赌博。在任何一项投资中，成功的办法都是运用你的技术知识、智慧以及对于这个游戏的热爱来减少意外、降低风险。当然，风险总是存在的，但你的财商可以提高你应付意外的能力。常常有这样的情况，对一个人来说是高风险的事情，对另一个人来说则可能是低风险的。这就是我不断鼓励人们多关注财商教育而不只是投资股票、房地产或其他市场的原因。你越精明，就越能应付意外情况。</p><h3 id="第六课：学会不为钱工作"><a href="#第六课：学会不为钱工作" class="headerlink" title="第六课：学会不为钱工作"></a>第六课：学会不为钱工作</h3><p>一位药品贸易的商务顾问曾经告诉我，有许多医生、牙医和按摩师在财务上困难重重。以前我总是认为他们一毕业，美元就会滚滚而来。这位商务顾问还跟我说了一句话：他们只有一项技能，所以挣不到大钱。这句话的意思是说，大部分人需要学习和掌握不止一项技能，只有这样他们的收入才能获得显著增长。以前我提到过，财商是会计、投资、市场和法律等各方面知识和能力的综合。将上述4种技能结合起来，以钱生钱就会容易得多。当涉及钱的时候，只有一项技能的人不得不努力工作。</p><p>一种可怕的管理理论是这样说的：工人付出最大努力以免于被解雇，而雇主提供最低工资以防止工人辞职。如果你看一看大部分公司的工资支付额度，就会明白这一说法确实在某种程度上道出了真相。最终的结果是大部分人从不敢越雷池一步，他们按照别人教他们的那样去做：找一份稳定的工作。</p><h3 id="克服困难"><a href="#克服困难" class="headerlink" title="克服困难"></a>克服困难</h3><p>掌握财务知识的人有时候还是不能积累丰厚的资产项，其主要原因有5个：</p><ol><li>对可能亏钱的 恐惧心理。</li></ol><p>如果你讨厌冒险，担心会亏钱，就早点动手积累资产吧。如果你有致富的愿望，就必须集中精力。把你大部分的鸡蛋放在较少的篮子里，别像穷人和中产阶级那样：把很少的鸡蛋放在许多篮子里。</p><ol><li>愤世嫉俗。</li></ol><p>我认为疑虑和愤世嫉俗的心态使大多数人安于贫困。生活等着你去致富，可就是这些疑虑使人们无法摆脱贫穷。未经证实的怀疑和恐惧会使人们成为愤世嫉俗者。愤世者抱怨现实，而成功者分析现实。<br>如果大多数人懂得股票市场上横盘（预定低点抛售）是什么意思的话，就会有更多的人为了赢利而投资，而不是为了避免损失而投资。横盘好比一个计算机指令，当股价开始下跌时自动卖出股票，帮助你将损失最小化、收益最大化。对于那些害怕受到损失的人来说，这是一项极好的工具。</p><ol><li>懒惰。</li></ol><p>我可付不起带来的悲哀和无助感会使人们失望、迟钝以至意志消沉。我怎样才能付得起则打开了充满可能性的快乐和梦想之门。<br>世界之所以发展是因为我们都渴望生活得更好，新发明的诞生是因为我们渴望更好的东西，我们努力学习也是因为我们想要了解更好的东西。因此，每当你发现自己在逃避你内心清楚应该去做的事情时，就应该问问自己：我还能得到什么？稍稍贪婪一点，这是治愈懒惰的灵丹妙药。</p><ol><li><p>不良习惯。</p></li><li><p>自负。</p></li></ol><h3 id="开始行动"><a href="#开始行动" class="headerlink" title="开始行动"></a>开始行动</h3><p>我建议你采取以下步骤来开发上帝赐予你的才能，这种才能只有你才可以控制：</p><ol><li><p>你需要一个超现实的理由</p></li><li><p>每天作出自己的选择</p></li></ol><p>从理财的角度来说，我们每挣到一美元，就得到了一次选择自己是成为富人、穷人还是中产阶级的机会。我们花钱的习惯反映了我们是什么样的人，穷人之所以贫穷是因为他们有着不良的消费习惯。</p><ol><li>慎重地选择朋友</li></ol><p>首先，我不会把理财状况作为挑选朋友的标准。我既有穷困潦倒的朋友，也有每年都有数百万美元进账的朋友，因为我相信三人行，必有我师，我愿意努力向他们学习。<br>不要听贫穷的或是胆小的人的话。他们总会告诉你一件事为什么不可行。<br>在积累财富的过程中，最困难的事情莫过于坚持自己的选择而不盲目从众。因为在竞争激烈的市场上，群体往往会反应迟钝，成为被宰割的对象。</p><ol><li>掌握一种模式，然后再学习一种新的模式——快速学习的力量。</li></ol><p>如果你对自己所做的工作感到厌倦或是你挣的钱不够多，那么很简单，改变你的挣钱模式吧。在今天这个快速变化的社会中，你学到的东西再多都不算多，因为当你学到时往往就已经过时了。问题在于你学得有多快，这种技能是无价之宝。如果你想赚钱，寻找一条捷径是非常关键的。</p><ol><li>首先支付自己——自律的力量。</li></ol><p>如果你控制不了自己，就别想着致富。能否自律是将富人、穷人和中产阶级区分开来的首要因素。<br>不要背上数额过大的债务包袱。要保持低支出。首先增加自己的资产，然后，再用资产项产生的现金流来消费.储蓄只能用于创造更多的收入，而不是用来支付账单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;读-lt-lt-穷爸爸富爸爸-gt-gt&quot;&gt;&lt;a href=&quot;#读-lt-lt-穷爸爸富爸爸-gt-gt&quot; class=&quot;headerlink&quot; title=&quot;读&amp;lt;&amp;lt;穷爸爸富爸爸&amp;gt;&amp;gt;&quot;&gt;&lt;/a&gt;读&amp;lt;&amp;lt;穷爸爸富爸爸&amp;gt;&amp;gt;
      
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Vite 使用教程</title>
    <link href="http://yoursite.com/2021/02/22/Vite%20%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%20/"/>
    <id>http://yoursite.com/2021/02/22/Vite 使用教程 /</id>
    <published>2021-02-22T05:39:21.000Z</published>
    <updated>2021-08-30T09:54:36.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vite-教程"><a href="#vite-教程" class="headerlink" title="vite 教程"></a>vite 教程</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init @vitejs/app <span class="comment"># npm 安装</span></span><br><span class="line">yatn create @vitejs/app <span class="comment"># yarn 安装</span></span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p>热启动快</p></li><li><p>模块热重载<br>vite 提供一套原生 ESM 的 HMR(即时热更新 hot module replacement) API 实现热重载,无需重新加载页面和应用.</p></li><li><p>按需编译</p></li></ol><p>Vite 要求项目完全由 es module 模块组成,因此不能再生产环境使用,打包依旧由 rollup 打包工具,目前vite 更像是一个类似于 webpack-dev-server 的开发工具.</p><h3 id="es-module-和-commonJs"><a href="#es-module-和-commonJs" class="headerlink" title="es module 和 commonJs"></a>es module 和 commonJs</h3><p>es modules 是浏览器支持的一种模块化方案.<br><code>import HelloWorld from &#39;./Helloworld.vue&#39;</code>,当浏览器解析这条语句的时候会往当前域名发送一个请求获取对应的资源.<br>我们平时在 webpack 上写的 esmodule 代码会被打包成 commonJs 的方式运行,所以运行速度较慢.<br>目前 90% 的浏览器都已支持 基于 web 标准的 es module.<br>浏览器对于带有type=”module”的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的defer属性。有多个该标签会依次执行.</p><p>CommonJs 是 NodeJs 中的规范,每个模块都有一个 exports 私有变量,exports 指向 module.exports.require 命令可以读入并执行一个 js 文件然后返回该文件的 exports 对象.require 被导出的值的拷贝.commonJs 是动态分析,动态加载.先整体加载模块,再从对象上读取里面的方法,因为只有运行中才能得到对象所以没有办法在静态编译时做静态优化.</p><p>esModule 的导入和导出都是声明式的,必须位于模块的顶层作用域,在 es6 代码编译阶段就可以分析模块依赖.通过静态分析未被调用的模块不会被执行和打包,确保模块之间传递的值和接口类型正确.import 导入的模块是只读的,不允许在导入后直接对其修改.如果是一个对象,可以对对象的属性进行修改.由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><p>不同: cjs 输出的是值拷贝,mjs 输出的是值引用. cjs 是运行时加载,mjs 是编译时记载.cjs 中 this 指向顶层对象,mjs 指向 undefined.</p><p>esModule 如果想要动态记载,可以使用 2020 提案中的 import()函数.该函数的参数可以是动态的.与 commonJS 中 require 的区别就是 require 是异步加载,import()是同步加载.加载成功后使用 then 方法从参数中获取模块.</p><p>node 要求 es6 模块使用 mjs 后缀,如果不想改后缀需要在 package.json 中加 <code>&#39;type&#39; : &#39;module&#39;</code>,这时 commonjs 需要加 cjs 后缀了.两者尽量不要混用.</p><p>esModule 加载路径必须给出脚本的完整路径,不能省略后缀名. 而使用webpack时 由于在<code>resolve.extensions: [&#39;.js&#39;,&#39;.jsx&#39;,&#39;.vue&#39;]</code>配置过,可省略后缀名.而vite可以通过<code>resolve.extensions :[&#39;.mjs&#39;, &#39;.js&#39;, &#39;.ts&#39;, &#39;.jsx&#39;, &#39;.tsx&#39;, &#39;.json&#39;]</code>配置.</p><h3 id="webpack-VS-vite"><a href="#webpack-VS-vite" class="headerlink" title="webpack VS vite"></a>webpack VS vite</h3><p>我们经常会遇到我们改动一小行代码,webpack 会耗时数秒来重新打包.因为 webpack 需要将所有模块打包成一个或多个模块.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'a.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;b&#125; <span class="keyword">from</span> <span class="string">'b.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getNumber = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打包成 bundle.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> getNumber = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;getNumber&#125;;</span><br></pre></td></tr></table></figure><p>当我们修改一个子模块 bJs,整个 bundleJs 都需要重新打包.随着项目增大,重新打包的时间越来越长.热更新的速度越来越慢.<br>webpack 之所以慢,是因为 webpack 会将很多资源构成一个或多个 bundle.如果跳过打包过程,当需要某个模块的时候再通过请求去获取就完美的解决了这个问题.Vite 做到了.</p><h3 id="Vite-实现原理"><a href="#Vite-实现原理" class="headerlink" title="Vite 实现原理"></a>Vite 实现原理</h3><ol><li>请求拦截.<br>Vite 的基本原理就是启动一个 node 服务器拦截浏览器请求 es module 的请求,通过 path 找到对应文件做一定的处理,然后以 es module 的方式返回给浏览器.</li></ol><ol><li><p>esbuild.<br>Vite 对 js/ts 的处理没有经过 gulp/rollup 等传统打包工具,而是使用 esbuild,esbuild 是一个全新的 js 打包工具,支持如 babel,压缩等功能,它要比 rollup 等传统工具快上几十倍.原因是它使用了 go 语言作为底层语言.</p></li><li><p>node_modules 模块的处理<br>当我们在日常开发时引用 node_modules 的时候,我们会这样引用.<code>import vue from &#39;vue&#39;;</code>然后 webpack 等打包工具会帮我们找到模块的路径.<br>但是浏览器只能通过相对路径去找,vite 为了解决这个问题,对其做了一些特殊处理.当浏览器请求<code>vue.js</code>时,请求路径是<code>@modules/vue.js</code>.在 vite 中约定若 path 的请求路径满足<code>/^\/@modules\//</code>格式时,就被认为是 node_modules 模块.那么如何将代码中的<code>vue.js</code>变为<code>/@modules/vue</code> 呢? Vite 对 es module 形式的 js 文件模块处理使用了 Es module lexer 处理, Lexer(词法分析器)会返回 js 文件中导入模块以数组形式返回.然后通过该数组判断是否为一个 node_modules 模块,若是则重写其 path. 然后当浏览器发生 path 为<code>/@modules/xx</code>的对应请求时,会被 Vite 服务端做一层拦截,最终找到对应模块进行返回.<br>Vite 对 script 标签导入的模块也会有对应的处理.</p><ol><li><p>vue 文件的处理<br>当 Vite 遇到 vue 文件时,它会被拆分成 template,css,script 三个模块进行处理.最后会对 script,template,css 发送多个请求获取.比如 App.vue?type=template 获取 template,type=style 获取 css.</p></li><li><p>静态文件的加载<br>当请求的路径符合 imageRE,mediaRE,fontsRE 或 JSON 格式时会被认作静态资源.然后处理成 es module 模块返回.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/node/utils/pathUtils.ts</span></span><br><span class="line"><span class="keyword">const</span> imageRE = <span class="regexp">/\.(png|jpe?g|gif|svg|ico|webp)(\?.*)?$/</span></span><br><span class="line"><span class="keyword">const</span> mediaRE = <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span></span><br><span class="line"><span class="keyword">const</span> fontsRE = <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/i</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isStaticAsset = <span class="function">(<span class="params">file: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> imageRE.test(file) || mediaRE.test(file) || fontsRE.test(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HMR(即时热更新 hot module replacement)的原理<br>Vite 的热更新原理就是在客户端和服务端建立了一个 websocket 链接,当代码修改时服务端发送消息通知客户端重新请求信代码,完成更新.</p></li></ol><ul><li>服务端原理 websocket</li><li>客户端原理<br>vite 在处理 html 时写入 websocket相关代码.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> clientPublicPath = <span class="string">`/vite/client`</span></span><br><span class="line"><span class="keyword">const</span> devInjectionCode = <span class="string">`\n&lt;script type="module"&gt;import "<span class="subst">$&#123;clientPublicPath&#125;</span>"&lt;/script&gt;\n`</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">rewriteHtml</span>(<span class="params">importer: string, html: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> injectScriptToHtml(html, devInjectionCode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// Listen for messages</span></span><br><span class="line">socket.addEventListener(<span class="string">'message'</span>, <span class="keyword">async</span> (&#123; data &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> payload = <span class="built_in">JSON</span>.parse(data) <span class="keyword">as</span> HMRPayload | MultiUpdatePayload</span><br><span class="line">  <span class="keyword">if</span> (payload.type === <span class="string">'multi'</span>) &#123;</span><br><span class="line">    payload.updates.forEach(handleMessage)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handleMessage(payload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleMessage</span>(<span class="params">payload: HMRPayload</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123; path, changeSrcPath, timestamp &#125; = payload <span class="keyword">as</span> UpdatePayload</span><br><span class="line">  <span class="built_in">console</span>.log(path)</span><br><span class="line">  <span class="keyword">switch</span> (payload.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'vue-reload'</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="Vite-的一些优化"><a href="#Vite-的一些优化" class="headerlink" title="Vite 的一些优化"></a>Vite 的一些优化</h3><p>es module 如果包含相互依赖的话,页面初始化会发送大量请求. Vite 为了优化这个问题,给了一个 optimize 指令.它类似于 webpack 的 dll-plugin 插件,提前将 package.json 中的依赖打包成一个 esmodule 模块,这样在页面初始化就能减少大量请求.</p><p>Vite 只是一个用于开发环境的工具,上线仍会打包成一个 commonJs 文件进行调用.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vite-教程&quot;&gt;&lt;a href=&quot;#vite-教程&quot; class=&quot;headerlink&quot; title=&quot;vite 教程&quot;&gt;&lt;/a&gt;vite 教程&lt;/h1&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vite" scheme="http://yoursite.com/tags/Vite/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 迁移指南</title>
    <link href="http://yoursite.com/2020/09/29/Vue3%20%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2020/09/29/Vue3 迁移指南/</id>
    <published>2020-09-29T05:42:05.000Z</published>
    <updated>2021-08-30T09:57:27.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue3-0-迁移指南"><a href="#vue3-0-迁移指南" class="headerlink" title="vue3.0 迁移指南"></a>vue3.0 迁移指南</h3><ol><li>全局 api 更改为 应用程序实例.<br>vue2.0 有很多全局的 api 和配置,比如 Vue.component 创建全局组件,Vue.directive 创建全局指令,Vue.mixins 和 Vue.use 等等..<br>因为Vue2.0 通过 new Vue(…)来创建根 Vue 实例,从同一个 Vue 构造函数创建的根实例共享相同的全局配置.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这会影响两个根实例</span></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app1 = <span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#app-1'</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> app2 = <span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#app-2'</span> &#125;)</span><br></pre></td></tr></table></figure></li></ol><p>vue3.0 提供了 一个全新的全局 API - creatApp,调用它返回一个应用实例.应用实例拥有当前全局 API 的子集.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;&#125;)</span><br><span class="line"><span class="comment">// app.component,app.directive,app.mixin,app.use...</span></span><br><span class="line">app.mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure></p><ol><li>全局和内部 api 以及重构为可 tree-shaking (删除无用代码,不打包到 bundle)<br>vue2.0 时再用 Vue.nextTick() 或它的简单包装形式$nextTick()时,webpack 的 tree-shaking 不可摇动.<br>Vue3.0 对全局和内部 api 进行了重构,考虑到 tree-shaking 的支持,全局 api 现在只能作为 es 模块侯建的命名导出进行访问.例如:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;nextTick&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">nextTick(...);</span><br></pre></td></tr></table></figure></li></ol><p>受影响的 api 有:</p><ul><li>Vue.nextTick</li><li>VUe.observable(用 Vue.reactive 替代)</li><li>Vue.version</li><li>Vue.compile</li><li>Vue.set</li><li>Vue.delete</li></ul><ol><li>v-model 用法更改<br>在 vue2.0 中,v-model 用来双向绑定数据,但一个组件只能用于一个 v-model,如果需要多个双向绑定只能用.sync.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.x</span></span><br><span class="line">&lt;ChildComponent :title=<span class="string">"pageTitle"</span> @update:title=<span class="string">"pageTitle = $event"</span> /&gt;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">&lt;ChildComponent :title.sync=<span class="string">"pageTitle"</span> /&gt;</span><br><span class="line"><span class="comment">// 子组件内部触发</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:title'</span>, newValue)</span><br></pre></td></tr></table></figure></li></ol><p>在 vue3.0 中,v-model 通过后面要绑定的属性名来实现绑定多个值.<br>原理: vue2.0 的 v-model 通过绑定一个 value 属性和 input 事件,将输入e.target.value映射到  绑定的变量 值上.<br>而 vue3.0 相当于传递了modelValue 的 prop 并接收了抛出的 update 事件.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 用在组件上</span><br><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">"searchText"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line">// 组件内部的 input 必须将属性绑定在 modelValue 上且 事件触发通过 update:modelValue 抛出.</span><br><span class="line">app.component('custom-input', &#123;</span><br><span class="line">  props: ['modelValue'],</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:value</span>=<span class="string">"modelValue"</span></span></span><br><span class="line"><span class="tag">      @<span class="attr">input</span>=<span class="string">"$emit('update:modelValue', $event.target.value)"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ol><li><p>key 属性用法更改<br>对于 v-if,v-else,v-else-if 的 key 不再必须,Vue3.0 会自动生成 唯一的key,不建议手动赋予 key 值.<br>vue2.0 中 template 标签不能有 key 值,通常在它的子节点设置 key.在 Vue3.0 中,key 值应该设置在 template 标签中.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 2.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"item.isVisible"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Vue 3.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"item.isVisible"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-if 和 v-for 优先级调整.<br>vue2.0 中,v-for 的优先级最高.而在 Vue3.0 中,v-if 的优先级最高. 但都建议避免他们在同一元素上使用.</p></li><li><p>v-for 中的 ref 数组.<br>vue2.0 中 v-for 使用 ref 会用 ref 数组填充相应的 $refs.当 v-for 存在嵌套 v-for 时,这是不明确和效率低下的.<br>Vue3.0 中.这样的用法将不再自动创建数组,需要将 ref 绑定到一个灵活地函数上.</p></li><li><p>只能使用普通函数创建功能组件(函数式组件).<br>vue2.0 函数式组件示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Vue 2 函数式组件示例</span><br><span class="line">export default &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  props: [&apos;level&apos;],</span><br><span class="line">  render(h, &#123; props, data, children &#125;) &#123;</span><br><span class="line">    return h(`h$&#123;props.level&#125;`, data, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 或者</span><br><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;component</span><br><span class="line">    :is=&quot;`h$&#123;props.level&#125;`&quot;</span><br><span class="line">    v-bind=&quot;attrs&quot;</span><br><span class="line">    v-on=&quot;listeners&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&apos;level&apos;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p>Vue3.0 不需要定义 functional,接收两个参数,props 和 context.(同 setup)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> DynamicHeading = <span class="function">(<span class="params">props, context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">`h<span class="subst">$&#123;props.level&#125;</span>`</span>, context.attrs, context.slots)</span><br><span class="line">&#125;</span><br><span class="line">DynamicHeading.props = [<span class="string">'level'</span>]</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> DynamicHeading</span><br></pre></td></tr></table></figure></p><ol><li>异步组件<br>Vue2.0 通过将组件定义为返回 promise 的函数来创建的.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncPage = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./NextPage.vue'</span>)</span><br></pre></td></tr></table></figure></li></ol><p>Vue3.0 由于函数式组件被定义为纯函数,因此异步组件需要包装在新的 defineAsyncComponent 方法显示定义.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> asyncPage = defineAsyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./NextPage.vue'</span>))</span><br></pre></td></tr></table></figure></p><ol><li><p>h 渲染函数更改.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.x 语法 render 函数接收 h 之类的参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render(h) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">'div'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.x 语法 h 函数全局导入,不作为参数传递,可以用作 setup 的返回值函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">'div'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>slot 统一<br>在 3.x 中，将所有 this.$scopedSlots 替换为 this.$slots</p></li><li><p>自定义指令<br>自定义指令的钩子函数更改为与组件声明周期统一的事件钩子.<br>bind =&gt; beforeMount, inserted =&gt; mounted, 新增 beforeUpdate, update 与 componentUpdated =&gt; updated, 新增 beforeUnmounte, unbind =&gt; unmounted.</p></li><li><p>watch 和 $watch 不再支持.分隔符字符串路径,请改为计算函数作为参数.</p></li><li><p>destroyed 重命名为 unmounted, beforeDestroy 重命名为 beforeUnmount</p></li><li><p>prop 默认值函数中不再能访问 this,可以把组件接收到的原始 prop 作为参数传递给默认函数.或使用 inject.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    theme: &#123;</span><br><span class="line">      <span class="keyword">default</span> (props) &#123;</span><br><span class="line">        <span class="comment">// `props` 是传递给组件的原始值。</span></span><br><span class="line">        <span class="comment">// 在任何类型/默认强制转换之前</span></span><br><span class="line">        <span class="comment">// 也可以使用 `inject` 来访问注入的 property</span></span><br><span class="line">        <span class="keyword">return</span> inject(<span class="string">'theme'</span>, <span class="string">'default-theme'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>data 组件选项不再接受纯 js Object,而必须是 function.而组件和 mixins 或 extends 基类合并是,现在将浅层次合并.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Mixin = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        name: <span class="string">'Jack'</span>,</span><br><span class="line">        id: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> CompA = &#123;</span><br><span class="line">  mixins: [Mixin],</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        id: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// vue 2.0 合并后是</span></span><br><span class="line"> &#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    name: <span class="string">'Jack'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Vue 3.0 合并后是</span></span><br><span class="line">&#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    id: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>迁移建议: 对于依赖 mixin 的深度合并行为的用户，我们建议重构代码以完全避免这种依赖，因为 mixin 的深度合并非常隐式，这让代码逻辑更难理解和调试。</p><ol><li><p>过渡 class 名更改<br>过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from。.</p></li><li><p>移除功能</p></li></ol><ul><li>不再支持使用数字键吗作为 v-on 的修饰符</li><li><p>不再支持 config.keyCodes</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes = &#123;</span><br><span class="line">  f1: <span class="number">112</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 键码版本 --&gt;</span><br><span class="line">&lt;input v-on:keyup<span class="number">.112</span>=<span class="string">"showHelpText"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Vue <span class="number">3</span> 在 v-on 上使用 按键修饰符, 建议对任何要用作修饰符的键使用 kebab-cased (短横线) 大小写名称 --&gt;</span><br><span class="line">&lt;input v-on:keyup.delete=<span class="string">"confirmDelete"</span> /&gt;</span><br></pre></td></tr></table></figure></li><li><p>$on，$off 和 $once 实例方法(全局事件侦听器)已被移除，应用实例不再实现事件触发接口。<br>$emit 仍然是现有 API 的一部分，因为它用于触发由父组件以声明方式附加的事件处理程序</p></li><li><p>Fileter 已删除,不再受支持,建议使用计算属性替代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; accountBalance | currencyUSD &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default&#123;</span></span><br><span class="line"><span class="regexp">filters: &#123;</span></span><br><span class="line"><span class="regexp">      currencyUSD(value) &#123;</span></span><br><span class="line"><span class="regexp">        return '$' + value</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>删除 inline-template 内联属性</p></li><li>删除$destroy 实例方法,用户不应再手动管理 Vue 组件的生命周期</li></ul><h3 id="vue3新特性"><a href="#vue3新特性" class="headerlink" title="vue3新特性"></a>vue3新特性</h3><ol><li><p>setup<br>setup是Vue3.0提供的一个新的属性，可以在setup中使用Composition API.setup函数有两个参数，分别是props和context。props 是组件外部传入进来的属性,contextcontext是一个对象，里面包含了三个属性attrs,slots,emit.<br>attrs 与 vue2.0 的 this.$attrs 一样,是外部传入未在 props 中定义的属性.<br>slots 对应 vue2.0 的 this.$slots 代表组件插槽.<br>emit 对应 vue2.0 的 this.$emit,对外暴露的事件.<br>setup 返回一个对象,对象中包含了组件使用到的 data 与一些函数或事件,也可以返回一个函数,对应 vue2.0 的 render 函数在里面可以使用 jsx.<br>不要在 setup 中使用 this,通过 props 和 content 基本可以满足开发需求.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>composition API<br>在 vue2.0 中,我们在 data()函数中定义数据,在 methods,computed,watch 等等地方使用数据,书写逻辑.但随着功能增加,代码越来越难阅读和理解,因为现有的 api 迫使我们通过选项写代码,但有时候通过逻辑写代码更有意义.但 vue2.0 缺少一种简介的机制来提取和重用多个组件间的逻辑.</p></li></ol><p>了解 composition api 前,想了解下 reactive 和 ref.</p><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><p>在 vue2.6 中有一个 新的 api, Vue.observer,通过这个 api 可以创建一个响应式对象.而 reactive 和 observer 功能基本一样.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; state.name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  setup() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 通过reactive声明一个可响应式的对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> state = reactive(&#123;</span></span><br><span class="line"><span class="javascript">      name: <span class="string">"test"</span></span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      state.name = <span class="string">"test123"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;, 1000 * 5);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">      state</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>vue2.x 时,经常出现更改数据后页面没有刷新,需要使用 Vue.set()来解决.vue3.0 抛弃了 2.0 使用的 Object.defineProperty .使用 proxy 来监听.我们可以直接在reactive声明的对象上添加新的属性.<br>reactive 返回的不是原对象,而是 proxy 实例的一个全新对象.</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>假如现在我们需要在一个函数里面声明用户的信息，那么我们可能会有两种不一样的写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">let</span> version = <span class="string">'3.0'</span></span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">let</span> info = &#123;</span><br><span class="line">  name: <span class="string">'vue'</span>,</span><br><span class="line">  version: <span class="string">'3.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于写法1我们直接使用变量就可以了，而对于写法2，我们需要写成info.name的方式。我们可以发现info的写法与reactive是比较相似的，而Vue3.0也提供了另一种写法，就像写法1一样，即ref。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>名称:&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  setup() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> name = ref(<span class="string">"vue"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'名称'</span>,name.value)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 5秒后修改name为  react</span></span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      name.value = <span class="string">"react"</span>;</span></span><br><span class="line"><span class="undefined">    &#125;, 1000 * 5);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">      name</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>reactive传入的是一个对象，返回的是一个响应式对象，而ref传入的是一个基本数据类型（其实引用类型也可以），返回的是传入值的响应式值.<br>reactive获取或修改属性可以直接通过state.xxx来操作，而ref返回值需要通过xxx.value的方式来修改或者读取数据。但是需要注意的是，在template中并不需要通过.value来获取值，这是因为template中已经做了解套。</p><ul><li>toRefs会把一个响应式对象的每个属性都转换为一个ref,在 setup 返回值中…roRefs(data),在模板中引用不需要再加上 data 前缀,可以直接使用变量.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">let</span> data = reactive(&#123;</span><br><span class="line">            count: <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...toRefs(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>watch<br>vue2.0 中使用 watch 来监听结果的变化</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">watch:&#123;</span><br><span class="line">name: &#123;</span><br><span class="line">handler(newVal,oldVal)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line">deep: <span class="literal">true</span>,</span><br><span class="line">immediate: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或使用</span></span><br><span class="line"><span class="keyword">this</span>.$watch(<span class="string">'name'</span>,() =&gt; &#123;...&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>vue3.0 兼容 2.0 的写法,也提供了新的 api.分别是 watch 和 watchEffect.<br>watch 与2.0 $watch 用法一样.但可以监听单个值和函数的返回值,还可以监听多个数据源(放在一个数组中).<br>watchEffect会传入一个函数,然后立即执行这个函数,对函数中的响应式依赖进行监听,当依赖变化时,重新调用传入的函数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> id = ref(<span class="string">'0'</span>)</span><br><span class="line">    watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 先输出 0 然后两秒后输出 1</span></span><br><span class="line">      <span class="built_in">console</span>.log(id.value)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      id.value = <span class="string">'1'</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>vue2.0 中$watch 会返回一个函数用于停止监听.vue3.0 中 watch 和 watchEffect 也会返回一个用于 unwatch 的函数.</p><ol><li><p>computed<br>vue 3.0 中 computed 与 vue2.0 一样.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.0</span></span><br><span class="line">computed:&#123;</span><br><span class="line">getName()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="keyword">this</span>.lastName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vue3.0</span></span><br><span class="line"><span class="keyword">const</span> info = reactive(&#123;</span><br><span class="line">firstName: <span class="string">'xx'</span>,</span><br><span class="line">lastName: <span class="string">'xxx'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// getter</span></span><br><span class="line"><span class="keyword">const</span> getName = computed(<span class="function"><span class="params">()</span> =&gt;</span> info.firstName + info.lastName)</span><br><span class="line"><span class="comment">// 或 getter + setter</span></span><br><span class="line"><span class="keyword">const</span> getName = computed(&#123;</span><br><span class="line">get: <span class="function"><span class="params">()</span> =&gt;</span> info.firstName + info.lastName,</span><br><span class="line">set(val)&#123;</span><br><span class="line"><span class="keyword">const</span> name = val.split(<span class="string">'-'</span>)</span><br><span class="line">info.firstName = name[<span class="number">0</span>]</span><br><span class="line">info.lastName = name[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>readonly<br>获取一个对象 (响应式或纯对象) 或 ref 并返回原始代理的只读代理。只读代理是深层的：访问的任何嵌套 property 也是只读的。</p></li><li><p>provide 和 inject<br>provide 和 inject 启用依赖注入。只有在使用当前活动实例的 setup() 期间才能调用这两者。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vue3-0-迁移指南&quot;&gt;&lt;a href=&quot;#vue3-0-迁移指南&quot; class=&quot;headerlink&quot; title=&quot;vue3.0 迁移指南&quot;&gt;&lt;/a&gt;vue3.0 迁移指南&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;全局 api 更改为 应用程序实例.&lt;br&gt;vue2.0
      
    
    </summary>
    
      <category term="前端 Vue" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF-Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>认识基金</title>
    <link href="http://yoursite.com/2020/07/15/%E8%AE%A4%E8%AF%86%E5%9F%BA%E9%87%91/"/>
    <id>http://yoursite.com/2020/07/15/认识基金/</id>
    <published>2020-07-15T11:47:48.000Z</published>
    <updated>2021-08-30T11:49:57.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识基金"><a href="#认识基金" class="headerlink" title="认识基金"></a>认识基金</h1><h3 id="基金的种类"><a href="#基金的种类" class="headerlink" title="基金的种类"></a>基金的种类</h3><p>按照投资品种分类，可以分为：1.股票基金，2.债券基金，3.混合基金，4.货币基金</p><p>股票基金，他主要投资的品种是股票和债券，股票品种必须占总品种的80%以上，而债券则必须低于20%。<br>债券基金，一般投资的是股票和债券，他叫债券基金所以他投资品种的80%必须是债券，也就是说债券必须占大多数。货币型基金，一般对于投资的债券其实是没有要求的，他的投资产品一般为短期债券和银行收益比较稳定的债券等。我们常用的余额宝其实就是货币基金的一种。最后来说混合基金。一般混合型基金就是股票和债券的混合品种，由于是混合型，所以对股票和债券的占比并没有要求。基金经理可以随意自行买入不同比例的股票和债券。比如市场好的时候就买入多一点的股票来获取更多的利润，市场不好的时候就买入多一点的债券来分摊风险。当然啦，混合基金也分为偏股票型混合与偏债券型混合，按照名字来说他的股票和债券的占比也会有所不同。</p><p>按照交易渠道来分，又可以分为两种，分别是场内基金和场外基金。</p><p>场内基金说白了就是在证券公司内部才能购买的基金。购买这种基金一般来说需要去券商网点开通相应的证券账号。而场外基金呢，是由第三方的机构帮助你去购买基金。比如在支付宝或微信上都能购买基金，这就是所谓的场外基金。场外基金的好处是不用开户，也不用去下载app，并且还能给你自动设置投资的额度和周期。</p><p>按照运作方式来分可以分为开放式基金和封闭式基金。</p><p>我们市面上绝大部分基金都是开放式基金。所谓开放式基金，就会随拿随取的，一般来说没有任何的年限要求。而封闭式基金则有一定的年限要求</p><p>按照投资方式来分可以分为主动性基金和被动型基金两种。</p><p>主动基金一般由基金经理自行判断买入和卖出时间，还有自定决定买入哪些股票债券他们的持仓比例是多少，这都是由管理这只基金的基金经理来决定。因此这就很考验基金经理的投资和选择产品的水平了。<br>而被动型基金，也就是我们所天天念叨的指数型基金。他的买入卖出的时机和持仓的成分股等都跟基金经理的主观判断没关系，他只跟国家的经济和大盘的点数有关。</p><h3 id="辨识基金"><a href="#辨识基金" class="headerlink" title="辨识基金"></a>辨识基金</h3><p>公司名称 + 投资方向/基金特点 + 基金类型，基金的名字大多是由这3部分组成的。<br>国泰沪深 300 指数 A ，就是指 国泰基金管理有限公司 出品的 追踪“沪深 300”这个指数的 基金。<br>关于名字中的“优选”“灵活配置”“价值”“量化”,选基金的时候必须遵守一个原则，一切带有修饰词的名称都是纸老虎。</p><h4 id="基金名字中的ABC"><a href="#基金名字中的ABC" class="headerlink" title="基金名字中的ABC"></a>基金名字中的ABC</h4><p>货币基金 ABC 的区别在于申购门槛不同。A 的后缀的呢，一般申购门槛比较低，面向的是普通投资者. B 和 C的呢，一般申购门槛都比较高，主要面向的是资金量大的用户或者机构投资者。</p><p>债券基金的 ABC 主要在于收费方式的不同。债券基金中 A 类，一般是前端收取申购费，也就是在买的时候，不管你打算持有这只基金多长时间，都马上收取申购费。B 类呢，一般是后端收取申购费，就是买的时候先不扣你的申购费，等赎回的时候才一次性收取。那关于后缀为 C 的，一般会免去申购费,短期投资选 C,长期投资选A 或 B.</p><p>指数基金的 A和C,A 类不收销售服务费，但是会收申购费，赎回费，根据持有时长变化。C 类不收申购费，但要比 A 类多收一定的销售服务费，按日计提。持有时间大于7 天，赎回费率为 0。一般持有一年以内买 C，持有一年以上就买 A。</p><h4 id="场内基金和场外基金的具体区别"><a href="#场内基金和场外基金的具体区别" class="headerlink" title="场内基金和场外基金的具体区别"></a>场内基金和场外基金的具体区别</h4><p>1.费率的区别。场内交易费率更便宜一些。<br>2.基金购买或申购时价格的区别。场内基金购买的时候它的价格是实时波动的，就像股票一样。比如上午10点的时候它的价格是1块钱，这个时候你可以以1块钱的价格买入。到了下午2点，他的价格变成了2块钱的时候，你这时想买就必须花2块钱去买了。外基金他的价格是不受价格实时波动的。不管你如何波动，只要你是在下午三点收盘前申购，它都是以下午三点收盘的价格购入。<br>3.购买份数有区别。场内基金对购买份数有要求。跟股票一样，最少需要买1手，也就是100股。而场外就没有这个要求啦，最低好像是十块钱起投资，不管多少手都行，当然也没有多少手这个概念。<br>4.投资方式的区别。场外基金相比较场内基金在这块操作起来更便捷。比如，场外基金可以设置自动定投操作。<br>5.到账时间。场内基金买入后T+1日就可以卖出，而资金在成功交易后即可使用。场外基金一般申购后T+2日才可以赎回，资金到账时间一般为T+1到7个工作日。</p><h3 id="货币基金"><a href="#货币基金" class="headerlink" title="货币基金"></a>货币基金</h3><h4 id="货币基金的选择"><a href="#货币基金的选择" class="headerlink" title="货币基金的选择"></a>货币基金的选择</h4><p>1.成立时间；最好是在3-5年以上。首先他的历史收益没办法进行很有效的参考<br>2.基金的规模；规模适中的最好。最低不能低于20亿<br>3.流动性；一般来说有T+0和T+1两种交割方式。具体选择哪种看个人，我更倾向于选择T+0的方式。<br>4.收益率.正常的收益率情况，我们可以通过“万分收益率”和“7天年化收益率”来计算。万份收益了就是按照上一日或者上一个交易日的收益来算一万块本金能赚多少钱。而7天年化收益率则是，根据过去7天的收益总合计算出年化收益率。</p><h4 id="债券基金"><a href="#债券基金" class="headerlink" title="债券基金"></a>债券基金</h4><p>通常来说 1 年之内要用的钱，用货币基金打理是非常合适的，流动性好，安全性高，收益也远高于银行活期利息。<br>投资股票类基金，比如之后会讲到的指数基金，用的是 3 年以上用不到的闲钱。那么如果是 1-3 年用不到的钱怎么办？放货币基金有点太可惜啦，此时纯债基金就是非常好的选择，通常来说纯债基金可以有 6%-7%的年化收益率。还有一种情况，就是整个股票市场都涨疯了的牛市，此时低估的指数基金已经找不到了。但是我们的投资还是要继续呀，这时我们就可以卖出已经高估的指数基金，买入纯债基金。</p><h4 id="主动型基金的选取指标"><a href="#主动型基金的选取指标" class="headerlink" title="主动型基金的选取指标"></a>主动型基金的选取指标</h4><p>主动基金最大的好处其实也是他最大的毛病就是过于依赖了基金经理的个人能力。因为决定你购买的基金的成分股是哪些的，就是这个基金经理。如果这个基金经理个人能力牛逼，那么可能他选的成分股就厉害。就会使得这只基金涨的多，但是反之如果这只基金经理的能力一般般或者很水，那么他这一篮子股票尽选一些比较垃圾的股票作为成分股，那么可想而知你买的基金也够呛。这也说明一只基金经理的能力的重要性，他决定了这只基金业绩到底是牛逼还是垃圾。</p><p>到底该如何去挑选一只主动基金和如何去判断一只基金的基金经理到底如何。<br>第一，看收益率。一般来说看累积3年以上的收益率，然后选择收益率高的基金。<br>第二，看基金的成立时间。一般也是选成立3年以上的基金最好。<br>第三点，手续费。<br>第四点，基金经理的更换频率越低越好。<br>第五点，看基金公司的盈利能力。<br>最重要的是看该基金的持仓.</p><h3 id="指数基金"><a href="#指数基金" class="headerlink" title="指数基金"></a>指数基金</h3><p>在中国，主要的指数我们分为四大类型。上证50，中证500，沪深300和创业板指数。</p><p>上证50就是指在上海交易所，也称之为上交所上市的所有公司里面挑选市值最高的前50只股票，按照一定的权重比例和计算公式算出来的一个值。<br>而沪深300指的是在上海交易所和深圳交易所上市的所有公司中，挑选出市值和业绩最好的前300家公司，按照一定的权重比例和计算公式算出来的一个值。他反应的就是整个中国上市公司的一个总体表现。<br>接着中证500是由全部A股中剔除沪深300指数成份股及总市值排名前300名的股票后，总市值排名靠前的500只股票组成，综合反映中国A股市场中一批中小市值公司的股票价格表现。<br>创业板指数，就是以起始日为一个基准点，按照创业板所有股票的流通市值，一个一个计算当天的股价，再加权平均，与开板之日的“基准点”比较。</p><h4 id="ETF，ETF-联接，LOF"><a href="#ETF，ETF-联接，LOF" class="headerlink" title="ETF，ETF 联接，LOF"></a>ETF，ETF 联接，LOF</h4><p>ETF 基金。交易型开放式指数基金，通常又被称为交易所交易基金.特点一：跟踪指数的效果更好。特点二：相对场外的指数基金，购买成本更低。</p><p>ETF 联接。它其实就是为了方便我们普通投资者购买 ETF 基金而专门设计的。对于普通投资者而言，ETF 基金只能通过证券交易软件进行场内买卖，但又有 100份起售的限制。ETF 联接就是买 ETF 基金的基金，一般以不低于 90%的仓位投资于该标的 ETF 基金。</p><p>用一句话总结就是：ETF 是指数的跟屁虫，ETF 链接是 ETF 的跟屁虫。<br>LOF 基金是上市交易型开放式基金，大家看到名字里带 LOF 的指数型基金，就知道它既可以场内交易也可以场外交易了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识基金&quot;&gt;&lt;a href=&quot;#认识基金&quot; class=&quot;headerlink&quot; title=&quot;认识基金&quot;&gt;&lt;/a&gt;认识基金&lt;/h1&gt;&lt;h3 id=&quot;基金的种类&quot;&gt;&lt;a href=&quot;#基金的种类&quot; class=&quot;headerlink&quot; title=&quot;基金的种类&quot;&gt;
      
    
    </summary>
    
      <category term="基金" scheme="http://yoursite.com/categories/%E5%9F%BA%E9%87%91/"/>
    
    
      <category term="基金" scheme="http://yoursite.com/tags/%E5%9F%BA%E9%87%91/"/>
    
  </entry>
  
  <entry>
    <title>Truffle 框架开发区块链智能合约</title>
    <link href="http://yoursite.com/2020/07/07/Truffle%20%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%8C%BA%E5%9D%97%E9%93%BE%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    <id>http://yoursite.com/2020/07/07/Truffle 框架开发区块链智能合约/</id>
    <published>2020-07-07T11:33:27.000Z</published>
    <updated>2021-08-30T11:34:54.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Truffle-框架开发区块链智能合约"><a href="#Truffle-框架开发区块链智能合约" class="headerlink" title="Truffle 框架开发区块链智能合约"></a>Truffle 框架开发区块链智能合约</h1><p>Truffle是针对基于以太坊的Solidity语言的一套开发框架。本身基于Javascript。是基于 node.js 和 web3.js 的框架进行合约的编译,发布和调用.如果熟悉 node 开发,可以直接使用 web3.js 进行开发.如果擅长 java 语言,可以使用 web3j 开发.</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>开发及测试中需要安装Ethereum客户端，以支持JSON RPC API调用开发环境，推荐使用EthereumJS TestRPC。<br>如果使用 vscode 编辑器还可以安装 solidity 插件.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g truffle</span><br><span class="line">npm: npm install Web3</span><br><span class="line">npm install -g ganache-cli <span class="comment"># ethereumJs TestRPC</span></span><br></pre></td></tr></table></figure></p><p>以太坊有很多客户端,基于 Go 语言开发的以太坊客户端 Geth 提供了 js 的运行环境可以基于 console 和 script.<br>而 EthereumJS TestRPC 是一个完整运行在内存中的区块链 可以再开发设备上适时返回,快速验证.等测试完成后在使用真实客户端发布.</p><h3 id="EthereumJS-TestRPC"><a href="#EthereumJS-TestRPC" class="headerlink" title="EthereumJS TestRPC"></a>EthereumJS TestRPC</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g ethereumjs-testrpc</span><br><span class="line">testrpc <span class="comment"># 启动</span></span><br></pre></td></tr></table></figure><h3 id="搭建私有链"><a href="#搭建私有链" class="headerlink" title="搭建私有链"></a>搭建私有链</h3><p>编写创世区块配置文件,然后执行初始化操作,完成后就可以启动私有链了.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">touch geth/gensis.json <span class="comment"># 配置文件</span></span><br><span class="line">mkdir db</span><br><span class="line">geth --datadir <span class="string">"./db"</span> init gensis.json <span class="comment"># 执行初始化命令</span></span><br><span class="line">geth --datadir <span class="string">"./db"</span> --rpc --rpcaddr=0.0.0.0 --rpcport 8545 <span class="comment"># 启动</span></span><br><span class="line">geth --datadir <span class="string">"./db"</span> attach <span class="comment"># 进入 js 控制台</span></span><br></pre></td></tr></table></figure></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle init</span><br></pre></td></tr></table></figure><p>初始化之后会出现几个目录:</p><p>test 用来测试应用和合约文件.</p><p>truffle.js 是 truffle 的配置文件.</p><h3 id="contract-意为合同"><a href="#contract-意为合同" class="headerlink" title="contract(意为合同)"></a>contract(意为合同)</h3><p>contract 是默认合约文件存放的地址.合约后缀是.sol表示 solidity,执行 <code>truffle compile --compile-all</code>编译合约.文件名和代码中的合约名要一致,区分大小写.通过 import 来什么依赖,会安装正确顺序来依次编译和关联库.编译输出在 build/contracts 文件中.</p><h3 id="migrations-意为迁移"><a href="#migrations-意为迁移" class="headerlink" title="migrations(意为迁移)"></a>migrations(意为迁移)</h3><p>migrations存放发布脚本的地址.移植是由一些 js 文件协助发布到以太坊网络.主要目的是用来缓存你的发布任务,当你的工程发生了一些重要改变,你将创建新的移植脚本来讲这些变化移植到区块链上.之前运行移植的记录历史会通过一个特殊的 migrations 来记录到链上.<br><code>truffle migrate</code>命令会很自信所有该目录下的移植脚本.文件名以数字开头描述结尾比如<code>1_initial_migration.js</code>,deployer 是部署器,你可以按照一定顺序发布任务,会按照从上到下依次执行.或使用 promise 来做出一个队列.,要实现不同条件的不同部署,可以给脚本添加第二个参数 network.<br>部署器有很多函数,deploy 函数来发布指定合约或合约数组,如果合约依赖某个库应该先部署这个依赖库.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ZhouCoin = artifacts.require(<span class="string">"ZhouCoin"</span>); <span class="comment">// 类似于 node 中的  node 中的 commonJS</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>)</span>&#123;  </span><br><span class="line">  deployer.deploy(ZhouCoin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>link 函数用来连接一个已经发布的库或合约.<br>then 函数是 promise 语法糖.<br>exec 函数来执行外部脚本.</p><h3 id="构建应用"><a href="#构建应用" class="headerlink" title="构建应用"></a>构建应用</h3><p>app 目录是文件运行默认目录.truffle 默认构建有一些特性,在浏览器内自动初始化应用包括引入编译合约,部署合约,配置以太坊客户端信息.<br>包含常见的依赖如 web3 和 ether Pudding,内置 es6 和 jsx, sass 支持, uglifyjs 支持.<br>app</p><pre><code>- javascripts / app.js- stylesheets / app.css- images- index.html</code></pre><p>然后在配置文件中配置<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"build"</span>:&#123;</span><br><span class="line"><span class="string">"index.html"</span>: <span class="string">"index.html"</span>,</span><br><span class="line"><span class="string">"app.js"</span>: [</span><br><span class="line"><span class="string">"javascripts/app.js"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"app.css"</span>: [</span><br><span class="line"><span class="string">"stylesheets/app.scss"</span></span><br><span class="line">],</span><br><span class="line"><span class="string">"images/"</span>: <span class="string">"images/"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后<code>truffle build</code> 命令来创建前端工程.需要注意当前不支持 import 和 require,不能使用 webpack 和 commonJS 等工具来管理依赖.</p><h3 id="合约交互"><a href="#合约交互" class="headerlink" title="合约交互"></a>合约交互</h3><p>以太坊网络把数据的读写做了区分,写数据被称为 交易 Transaction, 读数据被称为 调用 Call.</p><p>交易:<br>    交易的接收地址如果是 合约地址会触发智能合约的函数运行,需要花费 gas.交易需要时间,函数执行后并不能立刻得到执行结果,大多数情况下很自信交易不会返回值,而是返回一个交易的 ID.</p><p>调用:<br>    调用可以再网络上执行代码,但不改变数据(也许仅仅是临时变量被更改).调用执行是免费的,典型行为就是读取数据,通过调用执行合约函数,你会立即得要结果.不花费 gas 也不改变网络化妆,立即执行且有返回结果.</p><p>接口(abstract)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"ConvertLib.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract MetaCoin &#123;</span><br><span class="line">  mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) balances;</span><br><span class="line"></span><br><span class="line">    event Transfer(address indexed _from, address indexed _to, uint256 _value);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MetaCoin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        balances[tx.origin] = <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendCoin</span>(<span class="params">address receiver, uint amount</span>) <span class="title">returns</span>(<span class="params">bool sufficient</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (balances[msg.sender] &lt; amount) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        Transfer(msg.sender, receiver, amount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBalanceInEth</span>(<span class="params">address addr</span>) <span class="title">returns</span>(<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConvertLib.convert(getBalance(addr),<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params">address addr</span>) <span class="title">returns</span>(<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balances[addr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>合约有三个方法和一个构造方法.三个方法都可以执行交易和调用.其中只有 sendCoin 函数对网络造成了更改,所以它作为一个交易来执行.getBanance 函数是一个典型的调用函数,从网路中读取数据.<br>合约可以触发事件,事件与 web3 一样.合约接口都有一个 deployed()方法,表示部署到网络合约对应的抽象接口实例.或者通过 at(‘0x..’) 由地址得要接口实例.new()函数用来部署一个全新的合约到网络中,这是一个交易会改变网络状态.</p><h3 id="测试合约"><a href="#测试合约" class="headerlink" title="测试合约"></a>测试合约</h3><p>truffle 使用 mocha 测试框架来做自动化测试,使用 Chai 来做断言.Truffle 只会运行js,es,es6,jsx 结尾的测试文件.<br>命令<code>truffle test xx.js</code>来测试某文件.</p><h3 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h3><p>在测试时与合约交互是很频繁的,Truffle 提供了一个交互式控制台可以用更简单的方式来和合约交互.<code>truffle console</code>来启动控制台,会自动连接到一个运行中的以太坊客户端,控制台支持 truffle 命令,<code>migrate --reset</code> 与外部执行<code>truffle migrate --reset</code>效果是一样的.</p><h3 id="外部脚本"><a href="#外部脚本" class="headerlink" title="外部脚本"></a>外部脚本</h3><p>你也行会经常使用外部脚本与你的合约进行交互,Truffle 提供了一个简单的方式进行这个<code>truffle exec xx.js</code>,为了外部脚本执行正常,truffle 需要他们能通过 js 的模块方式导出一个函数,且有一个回调函数作为参数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>truffle 提供<code>truffle watch</code>和<code>truffle serve</code>命令,一个是用作修改后重构合约,一个用做修改后重编译部署构建.</p><h3 id="truffle-js-配置文件"><a href="#truffle-js-配置文件" class="headerlink" title="truffle.js 配置文件"></a>truffle.js 配置文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">build: &#123;&#125;, <span class="comment">// 构建</span></span><br><span class="line">network: &#123;</span><br><span class="line">development:&#123;</span><br><span class="line"><span class="comment">// host,port,network_id: "*"</span></span><br><span class="line">&#125;,</span><br><span class="line">staging:&#123;</span><br><span class="line"><span class="comment">// host,port,network_id: "*"</span></span><br><span class="line">&#125;,</span><br><span class="line">ropsten: &#123;</span><br><span class="line"><span class="comment">// host,port,network_id: "*"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="comment">// 指定移植时使用哪个网络</span></span><br><span class="line">mocha: &#123;&#125; <span class="comment">// 测试框架的配置选项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DAPP前端交互"><a href="#DAPP前端交互" class="headerlink" title="DAPP前端交互"></a>DAPP前端交互</h3><p>为了在前端 js 代码中能后使用 Truffle 提供的合约抽象,我们需要 truffle-default-builder,它可以帮助我们在把合约抽象整合到 js 中.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save truffle-default-builder@2.0.0</span><br></pre></td></tr></table></figure></p><p>然后在 truffle.js 中增加配置 network.development 配置.然后执行 truffle build 命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Truffle-框架开发区块链智能合约&quot;&gt;&lt;a href=&quot;#Truffle-框架开发区块链智能合约&quot; class=&quot;headerlink&quot; title=&quot;Truffle 框架开发区块链智能合约&quot;&gt;&lt;/a&gt;Truffle 框架开发区块链智能合约&lt;/h1&gt;&lt;p&gt;Tr
      
    
    </summary>
    
      <category term="Truffle DAPP" scheme="http://yoursite.com/categories/Truffle-DAPP/"/>
    
    
      <category term="Truffle DAPP" scheme="http://yoursite.com/tags/Truffle-DAPP/"/>
    
  </entry>
  
  <entry>
    <title>搭建 MOCK 服务</title>
    <link href="http://yoursite.com/2020/06/30/%E6%90%AD%E5%BB%BA%20MOCK%20%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/06/30/搭建 MOCK 服务/</id>
    <published>2020-06-30T09:57:43.000Z</published>
    <updated>2021-08-30T09:59:14.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建-MOCK-服务"><a href="#搭建-MOCK-服务" class="headerlink" title="搭建 MOCK 服务"></a>搭建 MOCK 服务</h1><h3 id="安装-mock-js"><a href="#安装-mock-js" class="headerlink" title="安装 mock.js"></a>安装 mock.js</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run mockjs</span><br><span class="line">npm install supervisor -g</span><br></pre></td></tr></table></figure><p>supervisor是一个用来运行node程序监控程序。(类似于 pm2)它是Nodejs的一个很小的监控脚本。它运行在你的程序中，并且监控你的代码变化，所以你可以进行代码热更新，而不用担心内存泄漏和确保你清理所有模块间的引用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts":&#123;</span><br><span class="line">"mock": "supervisor -w mock ./xxx/http.js",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>Mock.mock(rurl,rtype,data)</p><ul><li>rurl: 表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\/domain\/list.json/、’/domian/list.json’</li><li>rtype: 可选.表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。</li><li>data: 对象,字符串, 函数.</li></ul><p>Mock.setup( settings )<br>配置拦截 Ajax 请求时的行为。支持的配置项有：timeout。Mock.setup({<br>    timeout: ‘200-600’<br>})</p><p>Mock.valid(template, data)校验真实数据 data 是否与数据模板 template 匹配。</p><p>Mock.toJSONSchema(template)把 Mock.js 风格的数据模板 template 转换成 JSON Schema。</p><p>Mock.Random是一个工具类，用于生成各种随机数据。<br>Mock.Random 的方法在数据模板中称为『占位符』，书写格式为 @占位符(参数 [, 参数]) 。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Random = Mock.Random</span><br><span class="line">Random.email()</span><br><span class="line"><span class="comment">// =&gt; "n.clark@miller.io"</span></span><br><span class="line">Mock.mock(<span class="string">'@email'</span>)</span><br><span class="line"><span class="comment">// =&gt; "y.lee@lewis.org"</span></span><br><span class="line">Mock.mock( &#123; <span class="attr">email</span>: <span class="string">'@email'</span> &#125; )</span><br><span class="line"><span class="comment">// =&gt; &#123; email: "v.lewis@hall.gov" &#125;</span></span><br></pre></td></tr></table></figure></p><p>提供的占位符有以下类型:<br>|type|method|<br>|Basic|boolean,interger,float,string,date,time,now…|<br>|Image|image,dataImage|<br>|Color|color|<br>|Text|parafraph,sentence,word,title,cparafraph…|<br>|Color|color|<br>|Name|first,last,name,cfirst,clast,cname|<br>|Web|url,email,ip,tld,domain|<br>|Address|area,region|<br>|Other|id,picl…|</p><h3 id="使用-node-的http模块"><a href="#使用-node-的http模块" class="headerlink" title="使用 node 的http模块"></a>使用 node 的http模块</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> Mock = <span class="built_in">require</span>(<span class="string">'mockjs'</span>)</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json;charset=utf-8'</span>,</span><br><span class="line">      <span class="string">'Access-Control-Allow-Origin'</span>: req.headers.origin || <span class="string">'*'</span>,</span><br><span class="line">      <span class="string">'Access-Control-Allow-Methods'</span>: <span class="string">'*'</span>,</span><br><span class="line">      <span class="string">'Access-Control-Allow-Headers'</span>: <span class="string">'*'</span>,</span><br><span class="line">      <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">'Cache-Control'</span>: <span class="string">'no-cache,no-store'</span>, <span class="comment">// clear cache</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">      res.end(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> postData = <span class="string">''</span></span><br><span class="line">      req.addListener(<span class="string">'data'</span>, (dataBuffer) =&gt; (postData += dataBuffer))</span><br><span class="line">      req.addListener(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">        postData = <span class="built_in">JSON</span>.parse(postData)</span><br><span class="line">        <span class="keyword">const</span> data = []</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          res.end(<span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">        &#125;, <span class="built_in">parseInt</span>((<span class="built_in">Math</span>.random() - <span class="number">0.5</span> + <span class="number">1</span>) * <span class="number">500</span>, <span class="number">10</span>)) <span class="comment">// 随机数</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">'GET'</span>) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        res.end(Mock.mock(<span class="string">'@cname'</span>))</span><br><span class="line">      &#125;, <span class="built_in">parseInt</span>((<span class="built_in">Math</span>.random() - <span class="number">0.5</span> + <span class="number">1</span>) * <span class="number">500</span>, <span class="number">10</span>)) <span class="comment">// 随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">1111</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'listening port 1111'</span>)</span><br></pre></td></tr></table></figure><h3 id="使用concurrently同时开启前端服务和后端服务"><a href="#使用concurrently同时开启前端服务和后端服务" class="headerlink" title="使用concurrently同时开启前端服务和后端服务"></a>使用concurrently同时开启前端服务和后端服务</h3><ul><li>安装<code>npm install concurrently --save-dev</code></li><li>更改 package.json 的 script `”xx”: “concurrently \”npm run xxx\”  \”npm run xxx2\”” </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;搭建-MOCK-服务&quot;&gt;&lt;a href=&quot;#搭建-MOCK-服务&quot; class=&quot;headerlink&quot; title=&quot;搭建 MOCK 服务&quot;&gt;&lt;/a&gt;搭建 MOCK 服务&lt;/h1&gt;&lt;h3 id=&quot;安装-mock-js&quot;&gt;&lt;a href=&quot;#安装-mock-js&quot;
      
    
    </summary>
    
      <category term="前端 Mock" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF-Mock/"/>
    
    
      <category term="Mock" scheme="http://yoursite.com/tags/Mock/"/>
    
  </entry>
  
  <entry>
    <title>JS 函数式编程指南</title>
    <link href="http://yoursite.com/2020/06/16/JS%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2020/06/16/JS 函数式编程指南/</id>
    <published>2020-06-16T05:19:21.000Z</published>
    <updated>2021-08-30T09:51:01.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-函数式编程"><a href="#JavaScript-函数式编程" class="headerlink" title="JavaScript 函数式编程"></a>JavaScript 函数式编程</h1><h3 id="第一章-走进函数式"><a href="#第一章-走进函数式" class="headerlink" title="第一章 走进函数式"></a>第一章 走进函数式</h3><ol><li>例子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#msg"</span>).innerHTML = <span class="string">'&lt;h1&gt;hello world&lt;/h1&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用函数封装这段代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMessage</span>(<span class="params">elementId,format,message</span>)</span>&#123;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;elementId&#125;</span>`</span>).innerHTML = <span class="string">`&lt;<span class="subst">$&#123;format&#125;</span>&gt;<span class="subst">$&#123;message&#125;</span>&lt;/<span class="subst">$&#123;format&#125;</span>&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line">printMessage(<span class="string">'msg'</span>,<span class="string">'h1'</span>,<span class="string">'hello world'</span>);</span><br><span class="line"><span class="comment">// 以上仍然不是一段可复用的代码,用函数式编程如下</span></span><br><span class="line"><span class="keyword">var</span> printMessage = run(addToDom(<span class="string">'msg'</span>),h1,echo);</span><br><span class="line">printMessage(<span class="string">'hello world'</span>);</span><br><span class="line"><span class="comment">// 将程序分解为多个函数,再将他们组合起来完成一系列的操作.</span></span><br><span class="line"><span class="comment">// 当需求更改为在控制台打印 3 遍文本信息,就可以改为一下代码</span></span><br><span class="line"><span class="keyword">var</span> printMessage = run(<span class="built_in">console</span>.log,repeat(<span class="number">3</span>),echo);</span><br><span class="line">printMessage(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure></li></ol><p>函数式编程的特征: 声明式编程,纯函数,引用透明,不可变性.</p><ol><li>声明式编程<br>目前更主流的是命令式编程和面向对象编程.我们来看一个命令式的例子.假设你需要计算一个数组中所有数的平方.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">array[i] = <span class="built_in">Math</span>.pow(array[i],<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">array; <span class="comment">// [0,1,4,9,16]</span></span><br></pre></td></tr></table></figure></li></ol><p>命令式编程是很具体的告诉计算机如何执行某个任务.而声明式编程是将程序的描述和求值分离开来.它关注与如何使用各种表达式来描述程序逻辑.你可以在 SQL 语句中找到声明式编程的例子.<br>可以将 es6 的 lambda 表达式和箭头函数将循环抽象成函数,减少代码的书写.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].map(<span class="function"><span class="params">num</span> =&gt;</span> <span class="built_in">Math</span>.pow(num,<span class="number">2</span>));  <span class="comment">// [0,1,4,9,16]</span></span><br></pre></td></tr></table></figure></p><p>为什么要去掉代码循环?因为循环是命令控制结构,很难重用,并且很难插入其他操作中.并且要尽量做到无副作用无状态变化,既纯函数.</p><ol><li>副作用带来的问题和纯函数<br>函数式编程基于一个前提,既使用纯函数构建具有不变形的程序.考虑以下函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ++counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上函数不是一个纯函数,它在读取外部资源时会产生副作用.还有一个例子 Date.now,它的输出是不可预见和不一致的.<br>另一个副作用是通过 this 关键字访问实例数据时,由于 js 语言的特性,它决定了一个函数在运行时的上下文,这往往导致很难去推理代码.<br>以下行为都可能导致副作用:</p><pre><code>- 改变一个全局的变量,属性,或数据结构- 改变一个函数参数的原始值- 处理用户输入- 抛出异常又被当前函数捕获- 屏幕打印或记录日志- 查询 html 文档,浏览器数据或访问数据库</code></pre><p>以下案例是一个命令式程序,它听过 SSN 号码找到一个学生的记录渲染到页面上.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showStudent</span>(<span class="params">ssn</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> student = db.get(ssn);</span><br><span class="line"><span class="keyword">if</span>(student != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;elementId&#125;</span>`</span>).innerHTML = <span class="string">`<span class="subst">$&#123;student.ssn&#125;</span> - <span class="subst">$&#123;student.name&#125;</span>`</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Erroe(<span class="string">'student not found!'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">showStudent(<span class="string">'444-44-4444'</span>);</span><br></pre></td></tr></table></figure></p><p>该函数副作用有: 访问外部数据 db,全局变量 elementId 可能随时会改变,直接修改可外部共享的全局资源 html,抛出的异常会导致整个程序栈回退并结束.<br>如何使用函数式编程应对这种情况呢? 首先将长函数分离成多个且单一的短函数,其次通过显式的将外部依赖都定义为函数参数来减少副作用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> find = curry(<span class="function"><span class="keyword">function</span>(<span class="params">db,id</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj = db.get(id);</span><br><span class="line"><span class="keyword">if</span>(obj === <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'object is not found'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> csv = (student)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;student.ssn&#125;</span> - <span class="subst">$&#123;student.name&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> append = curry(<span class="function"><span class="keyword">function</span>(<span class="params">elementId,info</span>)</span>&#123;</span><br><span class="line"><span class="built_in">document</span>.querySelector(elementId).innerHTML = info;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用以上函数</span></span><br><span class="line"><span class="keyword">var</span> student = run(append(<span class="string">'#student'</span>),csv,find(db));</span><br><span class="line">student(<span class="string">'444-44-4444'</span>);</span><br></pre></td></tr></table></figure><p>这个程序仍然有些问题,find 函数有一个检查 null 的分支.当一个函数能够确保有相同的返回值,它使得函数的结果一致且可预测,这就是纯函数的一个特质,引用透明.</p><ol><li>引用透明和可置换性<br>如果一个函数对于相同的输入始终产生相同的结果,它就是引用透明的.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> increment = <span class="function"><span class="params">counter</span> =&gt;</span> counter + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><p>它不仅能使代码易于测试,还更容易推理整个程序.</p><ol><li>储存不可变数据<br>不可变数据指那些创建后不能更改的数据,js 的所有基本类型本质上不可变,但数组或对象都是可变的.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortDesc = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> b-a;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">sortDesc(arr);<span class="comment">// [4,3,2,1]</span></span><br></pre></td></tr></table></figure></li></ol><p>乍一看这段代码正常,但是 array.sort 函数是有状态的,会导致排序过程中产生副作用,因为原始的引用被修改了.</p><ol><li>总结<br>函数式编程是指为创建不可变程序,通过消除外部可见的副作用,来对纯函数的声明式求值过程.</li></ol><h3 id="第二章-高阶-JavaScript"><a href="#第二章-高阶-JavaScript" class="headerlink" title="第二章 高阶 JavaScript"></a>第二章 高阶 JavaScript</h3><ol><li>一等函数<br>函数是函数式编程的工作单元和中心,函数只有在返回一个有价值的结果(而不是 null和 undefined)时才有意义.同时,我们需要区分表达式(返回一个值的函数)与语句(不返回值得函数).函数式编程完全依赖表达式,无值函数在函数式编程下没有意义.<br>在 js 中,任何函数都是 Function 类型的一个实例,函数 length 属性可以获取形参的长度,apply 和 call 可以调用函数并加入上下文,不同的是 apply 函数接收一个参数数组,而 call 接收一系列参数.但函数式编程不建议这样做,因为它永远不会依赖于函数的上下文状态.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个函数,接受一个函数参数,并返回取反其结果的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">negate</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(func.apply(<span class="literal">null</span>,<span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNull</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> val === <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isNotNull = negate(isNull);</span><br><span class="line">isNotNull(<span class="literal">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol><li>闭包和作用域<br>在 js 之前闭包只存在于函数式编程语言中,js 是第一个在主流开发中应用闭包的语言.<br>闭包是一种能后在函数声明过程中将环境信息和所属函数绑定在一起的数据结构.从本质上讲,闭包就是函数继承而来的作用域.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAddFunction</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line"><span class="comment">// add 函数可以通过词法作用域访问 amount</span></span><br><span class="line"><span class="keyword">return</span> number + amount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> addTenTo = makeAddFunction(<span class="number">10</span>);</span><br><span class="line">addTenTo(<span class="number">1</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure></li></ol><p>闭包会在其声明时记住其作用域内的所有变量,并防止他们被垃圾回收机制回收.<br>js 的作用域分为全局作用域,函数作用域,伪块作用域.</p><pre><code>- 全局作用域,window 或 global,会有副作用,尽量避免使用- 函数作用域,可以嵌套,由内而外向上查找,直到全局作用域,推荐使用.- 伪块作用域,如 for,while,id,switch 语句,with,try..catch..等.无法从块外部访问</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dowork</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!myVar)&#123;</span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myVar); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js 有一个内部机制,将所有变量和函数提取至作用域的顶部.<br>es6 提供了 let,const 等关键字定义的变量不会进行提升.</p><ol><li>闭包的实际应用</li></ol><p><strong>模拟私有变量</strong><br>js 并没有一个 private 修饰符来限定对象中私有变量和函数的访问,我们可以使用闭包来完成.<br>闭包还可以管理全局的命名空间,既模块模式,它采用立即执行函数表达式IIFE,在 封装内部变量的同时,有效减少了全局引用.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个模块框架的示例</span></span><br><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params">export</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 给 IIFE 一个名字方便栈追踪</span></span><br><span class="line"><span class="keyword">let</span> _myprivateVar = ...;<span class="comment">//无法从外部访问这个变量,但对内的方法可以访问.</span></span><br><span class="line"><span class="keyword">export</span>.method1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>.method2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">export</span>;</span><br><span class="line">&#125;(myModule || &#123;&#125;));</span><br></pre></td></tr></table></figure></p><p>对象 myModule 在全局作用域创建,之后传递给一个 IIFE 函数表达式并立即执行.由于 js 的函数作用域,变量_myprivateVar 和其他变量都是函数的局部变量,闭包使得返回的对象能够安全的访问模块中的所有内部属性.</p><p><strong>异步服务端调用</strong></p><p>js 中的函数可以作为回调函数传递给其他函数,假设需要对服务器发起一次请求,并在响应时得到通知,常用的方式就是提供一个回调函数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJson(<span class="string">'/student'</span>,(student) =&gt;&#123;</span><br><span class="line">getJson(<span class="string">'/students/grades'</span>,</span><br><span class="line">grades =&gt; processGrades(grades),</span><br><span class="line">error =&gt; <span class="built_in">console</span>.log(error)),</span><br><span class="line">error =&gt; <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>getJson 是一个高阶函数,它接收两个回调作为参数,一个处理成功的函数,一个处理失败的函数.如果需要多次请求很容易进入回调地狱.</p><h3 id="第三章-轻数据结构-重操作"><a href="#第三章-轻数据结构-重操作" class="headerlink" title="第三章 轻数据结构,重操作"></a>第三章 轻数据结构,重操作</h3><ol><li><p>理解程序的控制流<br>程序为实现业务目标进行的路径就是控制流.命令式程序需要通过暴露所有的必要步骤才能详细的描述其控制流,这里面通常涉及大量的循环和分支以及各种变量.然而函数式程序多使用简单拓扑链接的黑盒操作组合成较小的程序化控制流,这些链接在一起的操作只是一些能够将状态传递给下一个操作的高阶函数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opta().optb().optc()... <span class="comment">// 链式结构</span></span><br></pre></td></tr></table></figure></li><li><p>链接方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'function programing'</span>.substring(<span class="number">0</span>,<span class="number">10</span>).toLowerCase() + <span class="string">'is fun'</span>;</span><br></pre></td></tr></table></figure></li></ol><p>通过一系列变换后的结果与原字符串毫无引用关系,无副作用.如果用更加函数式的写法如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(toLowerCase(subString(<span class="string">'function programing'</span>,<span class="number">1</span>,<span class="number">10</span>)),<span class="string">'is fun'</span>);</span><br></pre></td></tr></table></figure></p><p>这样虽然跟复合函数式的定义,但是较难阅读,需要一层层剥离外部函数,就行剥离洋葱一样.</p><ol><li>函数链<br>面向对象将继承作为代码重用的主要手段,比如在 java 中有继承与基础接口 List 的 ArrayList,LinkedLise 等.<br>但在函数式编程中是使用如数组这样的普通类型并施加在一套高阶操作上,通常接收函数作为参数,减少副作用等等.</li></ol><p>lambda 表达式,也被称为箭头函数.源自函数式编程,可以用较简介的语法声明一个匿名函数.它总是返回一个值.且能够与 map,reduce 等高阶函数配合使用.我们在接下来用 lodash 函数库来演示,它为了能够替换 underscore 采用了和它一样的 API.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 map 做数据变换</span></span><br><span class="line">_.map([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],v=&gt; <span class="number">2</span>*v); <span class="comment">//2,4,6</span></span><br></pre></td></tr></table></figure><p>我们不需要再写循环的代码,也不用处理奇怪的作用域问题了.由于其不可变,因此输出一个全新的数组.<br>函数式库可以辅助我们开发,写出纯函数式的代码.<br>map是一个只会从左到右遍历的操作,对应重右到左遍历必须反转数组,但 js 中的 Array.reverse() 会改变原数组,所以我们可以配合 lodash 中的 reverse 配合 map 进行操作.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).reverse().map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="number">2</span>*v); <span class="comment">// 6,4,2</span></span><br></pre></td></tr></table></figure></p><p>高阶函数 reduce 将一个数组中的元素精简为一个值,该值是每个元素累计而得.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).reduce( <span class="function">(<span class="params">memo,v</span>) =&gt;</span> memo+v,<span class="number">0</span> )</span><br></pre></td></tr></table></figure></p><p>除此之外,lodash 还提供了 every,some,filter 等辅助函数.</p><ol><li>代码推理<br>函数式编程中每个函数只完成一部分功能,但组合在一起就可以解决很多问题,下面介绍一种能够连接一组函数来构建程序的方法(声明式惰性计算函数链).<br>假设需要对一组姓名进行读取,去重,排序等操作,命令式代码如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names =[<span class="string">'alozno church'</span>,<span class="string">'Jaskell cjrl'</span>,<span class="string">'Terjdf'</span>,<span class="string">'asdfgg'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleName</span>(<span class="params">names</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> result = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;names.length;i++)&#123; <span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">var</span> n = names[i]</span><br><span class="line"><span class="keyword">if</span>(n !== <span class="literal">null</span> &amp;&amp; n !== <span class="literal">undefined</span>)&#123; <span class="comment">// 检查是否合法</span></span><br><span class="line"><span class="keyword">var</span> ns = n.replace(<span class="regexp">/_/</span>,<span class="string">' '</span>).split(<span class="string">' '</span>) <span class="comment">// 规范数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt; ns.length;j++)&#123;</span><br><span class="line"><span class="keyword">var</span> p = ns[j] <span class="comment">// 处理数据</span></span><br><span class="line">p = p.charAt(<span class="number">0</span>).toUpperCase() + p.slice(<span class="number">1</span>);</span><br><span class="line">ns[j] = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result.indexOf(ns.join(<span class="string">' '</span>))&lt; <span class="number">0</span>) &#123; <span class="comment">// 去除重复元素</span></span><br><span class="line">result.push(ns.join(<span class="string">' '</span>)) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result.sort(); <span class="comment">// 数组排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>用函数式代码实现如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.chain(names)  <span class="comment">// 初始化函数链</span></span><br><span class="line">.filter(isValid) <span class="comment">// 去除非法值</span></span><br><span class="line">.map(<span class="function"><span class="params">s</span> =&gt;</span> s.replace(<span class="regexp">/_/</span>,<span class="string">' '</span>)) <span class="comment">// 规范数据</span></span><br><span class="line">.uniq() <span class="comment">// 去重</span></span><br><span class="line">.map(_.startCase) <span class="comment">// 大写首字母</span></span><br><span class="line">.sort() <span class="comment">// 排序</span></span><br><span class="line">.value(); <span class="comment">// 返回封装对象的最终值</span></span><br></pre></td></tr></table></figure></p><p>对一个对象使用 chain 方法会封装这个对象,并之后的每次方法调用都返回这个封装的对象,当完成计算使用 value()函数取得最终值.<strong>使用 chain 链式调用的好处是可以创建具有惰性计算能力的复杂程序,在调用 value()之前并不会真正的执行任何操作.</strong> 链中的每个函数都以一种不可变的方式来处理换上一个函数构建的新数组.这有助于过渡到 point-free 编程风格的理解.</p><p>类 SQL 的数据:函数即数据.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p.firstname,p.birthYear <span class="keyword">from</span> person <span class="keyword">where</span> p.birthYear &gt; <span class="number">1903</span> <span class="keyword">and</span> p.country <span class="keyword">IS</span> <span class="keyword">Not</span> <span class="string">'US'</span></span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> p.firstname,p.birthYear</span><br></pre></td></tr></table></figure></p><p>lodash 支持一种称为 mixins 的函数,可以为核心库拓展新的函数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_.mixin(&#123;</span><br><span class="line"><span class="string">'select'</span> : _.pluck,</span><br><span class="line"><span class="string">'from'</span>: _.chain,</span><br><span class="line"><span class="string">'where'</span>: _.filter,</span><br><span class="line"><span class="string">'groupBy'</span>: _.sortByOrder</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>应用此 mixin 对象后就可以编写类 sql 的程序<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.from(persons)</span><br><span class="line">.where(<span class="function"><span class="params">p</span> =&gt;</span> p.birthYear &gt; <span class="number">1903</span> &amp;&amp; p.country !== <span class="string">'US'</span>)</span><br><span class="line">.groupBy([<span class="string">'firstname'</span>,<span class="string">'birthYear'</span>])</span><br><span class="line">.select(<span class="string">'firstname'</span>,<span class="string">'birthYear'</span>)</span><br><span class="line">.value();</span><br></pre></td></tr></table></figure></p><ol><li>递归<br>递归是一种通过将问题分解为较小的自相似问题来解决问题本身的技术,递归函数主要包含两方面,一是终止条件,二是递归条件.<br>来解决一个简单的问题,对数组中所有的值进行求和.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老规矩,先命令式,再函数式.</span></span><br><span class="line"><span class="keyword">var</span> acc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">acc += nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数式</span></span><br><span class="line">_(nums).reduce(<span class="function">(<span class="params">acc,current</span>) =&gt;</span> acc + current, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ol><p>递归和迭代是一个硬币的两面,在不可变条件下递归提供了一种更强大的迭代替代方法.纯函数式语言甚至没有标准的循环结构,如 for,while 等,因为所有循环都是递归完成的.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归求和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(_.isEmpty(arr))&#123; <span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _.first(arr) + sum(_.rest(arr)); <span class="comment">// 递归条件</span></span><br><span class="line">&#125;</span><br><span class="line">sum([]); <span class="comment">// 0</span></span><br><span class="line">sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p><p>从底层看,递归调用会在栈中不断堆叠,但算法满足终止条件时,运行时会展开调用栈并执行加操作,因此所有返回语句都将被执行,递归就是通过这种机制代替循环.但是注意编译器在处理循环的优化问题是很强大的,比如 es6 带来了<strong>尾调用优化</strong>,可以使递归和迭代的性能更加接近.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">arr,acc=<span class="number">0</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(_.isEmpty(arr))&#123; <span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum(_.rest(arr),acc+_.first(arr));<span class="comment">//发生在尾部的递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 我们之前已经利用函数式技术解析过一些扁平化数据,比如数组.但这些操作对树形数据结构是无效的.<br> 因为 js 没有内置的树形对象,所以需要基于节点,创建一种简单的数据结构.节点包括当前值,父节点引用,以及子节点数组的对象.<br> 树是包含了一个根节点的递归定义的数据结构.<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(root)&#123;</span><br><span class="line"><span class="keyword">this</span>._root = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> map(node,fn,tree = <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">// 使用静态方法避免与 Array.prototype.map 混淆</span></span><br><span class="line">node.value = fn(node.value);</span><br><span class="line"><span class="keyword">if</span>(tree === <span class="literal">null</span>)&#123;</span><br><span class="line">tree = <span class="keyword">new</span> Tree(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node.hasChildren())&#123;</span><br><span class="line">_.map(node.children,<span class="function"><span class="keyword">function</span>(<span class="params">child</span>)</span>&#123;</span><br><span class="line">Tree.map(child,fn,tree);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line">get root()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>._root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第四章-模块化且可重用的代码"><a href="#第四章-模块化且可重用的代码" class="headerlink" title="第四章 模块化且可重用的代码"></a>第四章 模块化且可重用的代码</h3><p>Unix  的脚本程序的编写如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr <span class="string">'A-Z'</span> <span class="string">'a-z'</span> &lt; words.in | uniq | sort</span><br></pre></td></tr></table></figure></p><p>这行代码对字符进行可一系列的变换,大小写转换,去除排序等.管道操作符 | 用于连接这些命令.</p><ol><li>方法链接函数管道的比较<br>在 Haskell 中私有一种符号<code>::</code>来描述函数,如下:<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;function-name&gt; :: &lt;<span class="type">Input</span>*&gt; -&gt; &lt;output&gt;</span><br></pre></td></tr></table></figure></li></ol><p>在函数式编程中,函数是输入和输出类型之间的数学映射.如 isEmpty 函数接收一个字符串并返回一个布尔值,使用该符号表示为:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// haskell 描述</span></span><br><span class="line">isEmpty :: <span class="built_in">String</span> -&gt; <span class="built_in">Boolean</span></span><br><span class="line"><span class="comment">// js lambda 描述</span></span><br><span class="line"><span class="keyword">const</span> isEmpty = <span class="function"><span class="params">s</span> =&gt;</span> !s || !s.trim();</span><br></pre></td></tr></table></figure></p><p>链式调用<code>xxx.xxx().xxx()</code>虽然相比命令式代码提高了可读性,但是它与方法所属对象耦合在一起,只能使用由 Lodash 提供的操作,无法将不同函数库或自定义函数链接在一起.<br>而管道是松散结合的有向函数序列,一个函数的输出会作为下一个函数的输入.</p><ol><li>管道函数的兼容条件</li></ol><ul><li>类型: 函数的返回类型必须与接收函数的参数类型相匹配.</li><li>元数: 接收函数必须声明至少一个参数才能处理上一个函数的返回值.函数的参数长度和其复杂度成正比,只有一个单一参数的纯函数是最简单的,建议使用.但如何返回两个不同的值呢,函数式语言通过一个被称为元祖的类型达成.元组是不可变结构,将不同数据类型元素打包在一起,以便传递到其他函数中.如<code>(false,&#39;error message&#39;)</code>.但 js 并不原生的支持 tuple 类型,在 es6 的解构赋值特性下可以简明的键元祖值映射到变量中.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[first,last] = [<span class="literal">false</span>,<span class="string">'error message'</span>];</span><br><span class="line">first <span class="comment">// false</span></span><br><span class="line">last <span class="comment">// error message</span></span><br></pre></td></tr></table></figure></li></ul><p>元祖是减少函数元数的方式之一,但还可以引入函数柯里化来实现降低元数的同时,增强代码模块化和可重用性.</p><ol><li>柯里化的函数求值<br>js 允许在确实产生的情况下对常规或非柯里化函数进行调用,js 会将缺少的参数设置为 undefined ,这或许也是 js 并不原生支持柯里化的原因.如果不设置行参,仅仅依靠 arguments 对象问题会更糟糕.<br>再看柯里化函数,它要求所有参数都被明确定义,当使用部分参数调用时,它会返回一个新的函数,在真正运行之前等待外部提供剩余参数.柯里化是一种在所有参数提供之前,挂起或延迟函数执行,将多参函数转换为一元函数序列的技术.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具有三个参数的柯里化定义</span></span><br><span class="line">curry(f) :: (a,b,c) -&gt; f(a) -&gt; f(b) -&gt; f(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> y =&gt; <span class="function"><span class="params">z</span> =&gt;</span> x + y + z;</span><br></pre></td></tr></table></figure></li></ol><p>以上代码表明,curry 是一种从函数到函数的映射,将输入(a,b,c)分解为多个分离的单参数调用.<br>在纯函数式语言中,柯里化是原生特性,是任何函数定义中的组成部分.由于 js 不支持自动柯里化函数,需要编写一些代码来启用它.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二元参数的手动柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry2</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">firstArg</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">secondArg</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fn(firstArg,sencondArg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示,柯里化是一种词法作用域(闭包),其返回的函数只不过是一个接受后续参数的简单嵌套函数包装器.<br>像 lodash 一样,ramda.js 是一个函数式编程辅助库,之所以使用它是因为它很容易实现参数柯里化,惰性应用,和函数组合.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkType = curry2(<span class="function"><span class="keyword">function</span>(<span class="params">typeDef,actualType</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(R.is(typeDef,actualType))&#123;</span><br><span class="line"><span class="comment">// 使用 ramda 中 is()检查类型信息</span></span><br><span class="line"><span class="keyword">return</span> actualType;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'type  mismatch'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">checkType(<span class="built_in">String</span>)(<span class="string">'Curry'</span>); <span class="comment">// String</span></span><br><span class="line">checkType(<span class="built_in">String</span>)(<span class="number">42</span>); <span class="comment">// type  mismatch</span></span><br></pre></td></tr></table></figure></p><p>通过 R.curry 或 lodash 的curry 可以对任意数量参数的函数进行自动的柯里化.可以将自动柯里化想象为基于声明参数的数量而人工创建对应嵌套函数作用域的过程.</p><ol><li>部分应用(partial 偏函数)和函数绑定<br>部分应用是一种通过将函数的不可变参数子集初始化为固定值来创建更小元数函数的操作.简单说就是,如果存在一个具有五个参数的函数,给出三个参数后就会得到一个具有两个参数的函数.柯里化的函数本质上也是部分应用的函数.他们主要的区别在于参数传递的内部机制和控制.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//体积计算函数的部分应用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">volume</span>(<span class="params">l</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">w, h</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l * w * h</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>柯里化在每次分布调用时都会生成嵌套的一元函数,在底层函数的最终结果由这些一元函数逐步组合产生,所以可以完全控制函数求值的时间和方式.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partial 的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">this</span>, boundArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">let</span> placeholder = &lt;&lt;partialPlaceholderObj&gt;&gt; // 占位符,lodash 使用下划线对象作为占位符,其他实现使用 undefined 来表示应略过该参数</span><br><span class="line">let bound = function()&#123;</span><br><span class="line">// 使用部分参数创建新函数</span><br><span class="line">let position = 0,length= args.length;</span><br><span class="line">let args = Array(length);</span><br><span class="line">for(let i=0;i&lt; length;i++)&#123;</span><br><span class="line">args[i] = boundArgs[i] === placeholder ? arguments[position++]: boundArgs[i]</span><br><span class="line">&#125;</span><br><span class="line">while(positoion &lt; arguments.length)&#123;</span><br><span class="line">args.push(arguments[positoion++])</span><br><span class="line">&#125;</span><br><span class="line">return fn.apple(this,args)</span><br><span class="line">&#125;</span><br><span class="line">return bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>部分应用将函数的参数与一些预设值绑定(赋值),从而产生一个拥有更少参数的新函数.该函数的闭包中包含这些已经赋值的参数,在之后的调用中完全被求值.一种类似的 js 原生技术被称为函数绑定,即 Function.prototype.bind()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.partial(finc,[params...])</span><br><span class="line"><span class="comment">// 创建一个函数,该函数会调用 func,并传入预设的参数,与 _.bind 不同的是,它不会绑定 this.</span></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> greet = <span class="function"><span class="keyword">function</span>(<span class="params">greeting,name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> greeting + <span class="string">' '</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayHelloTo = _.partial(greet,<span class="string">'hello'</span>);</span><br><span class="line">sayHelloTo(<span class="string">'fred'</span>); <span class="comment">// hello fred</span></span><br></pre></td></tr></table></figure><ol><li><p>组合函数管道<br>我们来看一个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`we can only see a short</span></span><br><span class="line"><span class="string">distance</span></span><br><span class="line"><span class="string">three</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> explode = <span class="function"><span class="params">str</span> =&gt;</span> str.split(<span class="regexp">/\s+/</span>);</span><br><span class="line"><span class="keyword">const</span> count = <span class="function"><span class="params">arr</span> =&gt;</span> arr.length;</span><br><span class="line"><span class="keyword">const</span> countWords = R.compose(count,explode);</span><br><span class="line">countWords(str); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>这段程序有趣的地方在于,直到countWords被调用才会触发求值,用其名称传递的函数 explode 和 count 在组合中是静止的.这种<strong>将函数的描述和求值的行为分开</strong>正是函数式编程的强大之处.<br>我们来看一下 compose 的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"><span class="keyword">let</span> start = args.length <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> i = start;</span><br><span class="line"><span class="keyword">let</span> result = args[start].apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">while</span>(i --)&#123;</span><br><span class="line">result = args[i].call(<span class="keyword">this</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Ramda 这种函数库的好处就是所有函数都已经正确的柯里化,在组合函数管道时更具有通用性.<br>我们注意到 compose 函数是从参数最右到最左的顺序,而unix管道符 | 是从左到右执行的.我们可以使用 compose 的镜像函数 pipe 来获得 管道符一样的效果.不必像原来那样正式的声明参数来创建新的函数,函数式鼓励这种风格,它被称为 point-free.<br>point-free 使得 js 代码更接近 haskell 和 unix 的理念.柯里化能够灵活地定义一个只差最后一个参数的内联函数,这种编码风格被称为 Tacit 编程.</p></li><li><p>使用函数组合子来管理程序的控制流.<br>命令式代码能够加 if-else 和 for 语句这样的过程控制机制,而函数式则不能.<br>组合器是一些可以组合其他函数和组合子,作为控制逻辑运行的高阶函数.除了 compose 和 pipe,常见的组合子如下:</p></li></ol><ul><li>identity,意为身份,特性.它是返回与参数同值得函数.<br>  <code>identity :: a -&gt; a</code> 它广泛用于函数数学特性的检验</li><li>tap,意为轻拍.它能够将无返回值的函数嵌入到函数组合中,而无需创建其他代码.<br>  <code>tap:: (a -&gt; *) -&gt; a -&gt; a</code>该函数接受一个输入对象a 和一个对 a 执行操作的函数,使用提供的对象调用给定的函数,然后在返回该对象.</li><li><p>alternation,alt 组合子又叫 OR 组合子,能够在提供函数响应的默认行为时执行简单的条件逻辑.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alt = <span class="function"><span class="keyword">function</span>(<span class="params">func1,func2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> func1(val) || func2(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sequence,seq 组合子用于遍历函数序列,它以两个或以上的函数作为参数并返回一个新函数,会用相同的值顺序调用这些函数.实现如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seq = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> funcs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">funcs.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(val))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>seq 不会返回任何值,只会一个一个的执行一系列操作.</p><ul><li>fork(join) 组合子<br>fork 用于需要以两中不同的方式处理单个资源的情况,该组合子需要以单个函数作为参数,即以一个 join 函数和两个 fork 函数来处理提供的输入,两个分叉函数的结果传递给join 函数.</li></ul><h3 id="第五章-针对复杂应用的设计模式"><a href="#第五章-针对复杂应用的设计模式" class="headerlink" title="第五章 针对复杂应用的设计模式"></a>第五章 针对复杂应用的设计模式</h3><ol><li><p>命令式错误处理的不足<br>在命令式编程中,异常都是通过 try-catch 处理的.将可能出现问题的代码放在 try 代码块中,通过 catch 捕获异常.但是,这样的代码将不能组合或连在一起,这将严重影响代码设计.<br><strong>函数式程序不应抛出异常</strong>,因为抛出异常会导致难以与其他函数组合,违反了引用透明原则,会引起副作用.</p></li><li><p>一种更好的解决方案Functor(函子).<br>通常我们在判断 null 和 undefined 时会写啰嗦且重复的的判断代码.函数式以一种完全不同的方法应对软件系统的错误处理,其思想就是创建一个安全的容器来存放危险代码.<br>functor 和 map 很类似,它会首先打开容器,应用函数到值,最后把返回的值包裹到一个新的同类型容器中.这种函数类型被称为 functor.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 functor 完成 2 + 3 = 5</span></span><br><span class="line"><span class="keyword">const</span> plus = R.curry(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b);</span><br><span class="line"><span class="keyword">const</span> plus3 = plus(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 将 2 放到warp容器中</span></span><br><span class="line"><span class="keyword">const</span> two = warp(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 调用 functor 把 plus3 映射到容器上</span></span><br><span class="line"><span class="keyword">const</span> five = two.fmap(plus3); <span class="comment">// Warpper(5) 返回一个具有上下文包裹的值</span></span><br><span class="line">five.map(R.identity) ; <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// fmap 函数返回同类型的类型,可以链式调用</span></span><br><span class="line">two.fmap(plus3).fmap(R.tap(infoLogger)); <span class="comment">// 在控制台打印以下信息</span></span><br></pre></td></tr></table></figure><p>functor 是无副作用且可组合的,其实际目的只是创建一个上下文或一个抽象,以便可以安全的应用操作到值而不改变原始值.<br>函子是函数编程中最重要的数据类型,也是基本的运算单位和功能单元.一般约定,函子的标志就是容器拥有 map 方法,该方法将容器中的每一个值映射到另一个容器.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(val)&#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line">map(f)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Functor(f(<span class="keyword">this</span>.val))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Functor(<span class="number">2</span>)).map(<span class="function"><span class="keyword">function</span>(<span class="params">two</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> two + <span class="number">3</span>;</span><br><span class="line">&#125;) <span class="comment">// Functor(5)</span></span><br></pre></td></tr></table></figure></li></ol><p>还有一个更具体化的函数式数据类型 Monad,可以将电话代码中的错误处理,更流畅的进行函数组合,其实 Monad 就是 functor “伸入” 的容器.我们曾经写个这样的 jQuery 代码<code>$(&quot;#student&quot;).fadeIn(3000).text(student.fullname())</code>.jQuery 可以很安全的将 fadeIn 和 text 行为应用到 DOM 上,如果 student 的 id 不存在,方法会应用到空的 jQuery 对象上且什么也不发生,也不会抛出任何异常.Monad 在于安全的传送错误,这样代码才有较好的容错性.</p><ol><li>Monad 函数式的出路错误<br>我们来了解一下 functor 的局限性,当把两个 warp 包裹函数组合在一起的时候需要用两次 R.identity 函数来提取值,如果层数再多的话,monad 是更好的解决方案.</li></ol><p>假设有一个函数<code>half: number -&gt; number</code>,<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warpper(<span class="number">2</span>).fmap(half); <span class="comment">// warpper(1)</span></span><br></pre></td></tr></table></figure></p><p>functor只管应用到值并将结果包裹起来,并不能加额外的逻辑,如果想限制 half 只应用到偶数,而输入是一个奇数该怎么办.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">Number</span>.isFinite(n) &amp;&amp; (n%<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">val</span>) =&gt;</span> isEven(val) ? Wrap(val/<span class="number">2</span>) : empty();</span><br><span class="line"><span class="comment">// half 如果是一个奇数则返回一个空的容器</span></span><br></pre></td></tr></table></figure><p>Monad 用于创建一个带有一定规则的容器,而 Functor 不需要了解其容器内的值.使用 Monadic 类型需要了解以下定义:</p><ul><li>创建 Monadic 类型(类似于 Warpper的构造函数)</li><li>unit 函数,可将特点类型的值放入 Monadic 结构中,类似于 empty 函数.</li><li>bind 函数,可以链式操作,functor的 fmap</li><li>join 函数,将两层 monadic 结构合并为一层.用于逐层扁平化嵌套结构,无需多次提取.<br>Monad 函数的fmap 函数也叫 flatmap 函数,在大多数函数库里 flatmap 叫做 chain .</li></ul><p>下面来看丰富的 Monad 实例,maybe,Either 和 IO.<br>函数式编程通常使用 maybe 和 either 来隔离不纯,合并判空逻辑,避免异常,支持函数组合,中心化逻辑提供默认值.<br>简单说 maybe 函子的 map 方法里设置了空值检查.<br>Either 一般用来提供默认值.either 函子内部有两个值,left 和 right,right 是正常情况的值.left 是 right 不存在时的默认值.总之就是 right 有值用 right,否则用 left.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addOne = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">either.of(<span class="number">5</span>,<span class="number">6</span>).map(addOne); <span class="comment">// either(5,7)</span></span><br><span class="line">either.of(<span class="number">1</span>,<span class="literal">null</span>).map(addTOne); <span class="comment">// either(2,null)</span></span><br></pre></td></tr></table></figure></p><p>Either 另一个用途就是代替 try…catch,使用 left 表示错误.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseJson</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Either.of(<span class="literal">null</span>,<span class="built_in">JSON</span>.parse(json))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第六章-可测试的函数式"><a href="#第六章-可测试的函数式" class="headerlink" title="第六章 可测试的函数式"></a>第六章 可测试的函数式</h3><p>略</p><h3 id="第七章-函数式优化"><a href="#第七章-函数式优化" class="headerlink" title="第七章 函数式优化"></a>第七章 函数式优化</h3><ol><li><p>函数执行机制<br>js 中,每个函数调用都会在函数上下文堆栈中创建记录(帧),它负责管理函数执行以及关闭变量作用域.<br>全局的上下文帧永远在堆栈的底部,函数体声明的变量越多,就需要越大的堆栈帧.<br>函数柯里化过度使用会导致其占有大量的堆栈空间,进而导致程序运行速度显著降低.<br>递归也会导致堆栈的溢出.因为递归时函数调用自己也会创建新的函数上下文,如果你见过<code>range error: Maximum call stack exceeded or too much recursion</code>就知道是递归出问题了.堆栈大小跟硬件也有关系.<br>既然大量函数推入堆栈会增加程序的内存占用,为什么不避免不必要的调用呢?</p></li><li><p>使用惰性求值推迟执行<br>函数式语言 Haskell 内置了惰性函数求值,惰性求值的方法有很多,但目的都是尽可能的推迟求值,直到依赖的表达式被调用.<br>但是 js 使用的是更主流的函数求值策略 - 及早求值,它会在表达式绑定到变量时求值,不管结果是否用到,也称贪婪求值.</p></li></ol><p>2.1 使用函数式组合子避免重复计算.alt 组合子类似于 || 运算,先计算 func1 如果返回值为 假,在调用 func2.这是避免不必要计算的简单方法,还有一个更强大的方法 memoization.<br>2.2 函数式编程的 shortcut fusion(意为: 捷径 融合),是一种函数级别的优化,它通过合并函数执行,并压缩计算过程中使用的临时数据结构有效降低内存占用.之所以可以这样做事因为函数式编程引用透明带来的数学和代数的正确性.<br>比如 compose(map(f),map(g))可以由 map(compose(f,g))完全代替.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Math</span>.pow(x,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">x</span> =&gt;</span> x%<span class="number">2</span> === <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> numbers = _.range(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = _.chain(numbers)</span><br><span class="line">.map(square)</span><br><span class="line">.filter(isEven)</span><br><span class="line">.take(<span class="number">3</span>) <span class="comment">// 仅处理前三个</span></span><br><span class="line">.value() <span class="comment">// [0,4,16]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map 和 filter 可以通过 compose 融合在一起</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2.3 记忆化 memorization</span></span><br><span class="line"><span class="string">加快程序执行的方法之一就是避免计算重复值,在传统的面向对象中,通过将函数结果赋予给唯一的键值对并持久化到缓存中.</span></span><br><span class="line"><span class="string">而在函数式中记忆化是一种很好的方式.它基于函数的参数创建与之对应的唯一的键,将结果存储到键上,当再次遇到相同的参数的函数时,立即返回储存的结果.</span></span><br><span class="line"><span class="string">给 FUnction 添加记忆化</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="built_in">Function</span>.prototype.memoized = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> Key = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);<span class="comment">//将参数字符串化以获取当前函数调用的键值</span></span><br><span class="line"><span class="keyword">this</span>._chace = <span class="keyword">this</span>.cache || &#123;&#125;; <span class="comment">// 为当前函数实例创建一个内部缓存</span></span><br><span class="line"><span class="keyword">this</span>._chace[key] = <span class="keyword">this</span>._chace[key] || <span class="keyword">this</span>.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)<span class="comment">// 先试图读取缓存,通过输入判断是否计算过,找到就离开返回,没找到这开始计算</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>._chace[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.memoize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 激活函数记忆化</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span>(fn.length === <span class="number">0</span> || fn.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> fn; <span class="comment">// 只尝试记忆化一元函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fn.memoized.apply(fn,<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计多个参数的函数即使是纯函数也很难缓存,因为复杂度增加了,柯里化是解决方案之一.<br>递归和尾递归优化,es6 添加的尾部调用消除,可以再递归调用时不依赖当前帧,创建一个新的帧并回收旧的帧.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-函数式编程&quot;&gt;&lt;a href=&quot;#JavaScript-函数式编程&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 函数式编程&quot;&gt;&lt;/a&gt;JavaScript 函数式编程&lt;/h1&gt;&lt;h3 id=&quot;第一章-走进函数式
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript 函数式编程" scheme="http://yoursite.com/tags/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>读&lt;&lt;上帝的骰子&gt;&gt;</title>
    <link href="http://yoursite.com/2020/06/15/%E8%AF%BB%3C%3C%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%AA%B0%E5%AD%90%3E%3E/"/>
    <id>http://yoursite.com/2020/06/15/读&lt;&lt;上帝的骰子&gt;&gt;/</id>
    <published>2020-06-15T11:43:05.000Z</published>
    <updated>2021-08-30T11:46:55.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读-lt-lt-上帝的骰子-gt-gt"><a href="#读-lt-lt-上帝的骰子-gt-gt" class="headerlink" title="读&lt;&lt;上帝的骰子&gt;&gt;"></a>读&lt;&lt;上帝的骰子&gt;&gt;</h1><h3 id="量子力学的前夜"><a href="#量子力学的前夜" class="headerlink" title="量子力学的前夜"></a>量子力学的前夜</h3><p>中学时我们就学过牛顿三定律。<br>牛顿第一定律即惯性定律：不受外力的物体将在惯性系中保持静止或匀速直线运动的状态不变。接着，他又给出，说明力、质量和运动之间的定量关系：物体的加速度与它所受的外力成正比，与它的质量成反比。牛顿第三定律则指出：两个物体间的作用力和反作用力大小相等，方向相反，作用在一条直线上。也就是说，牛一定律说明了力是改变物体运动状态的原因；牛二定律指出了力使物体获得加速度；牛三定律揭示了力是物体间的相互作用。除了牛顿三定律，再加一个万有引力定律。牛顿完成了经典力学架构，统一了万物运行背后的道理。</p><p>大伙儿都相信牛顿定律就是宇宙的终极真理，宏观世界很快热闹了起来。科学家们真干实干加巧干，一直干到20世纪，终于建成了一座宏观物理学大厦。经典力学、热力学、光学、电磁学等在大厦里各司其职。<br>眼看科研经费一年比一年少，前途一片黯淡。这时，哥本哈根学派的一帮年轻科学家开始掀桌子。宏观世界是没什么活儿可以干了，但是还有微观世界啊！牛顿力学只适用于宏观世界，可一旦深入微观世界，比如原子级别，这套理论就完全找不着北了。那量子力学到底是怎样诞生的呢？人类在研究光的过程中偶然邂逅了无辜的量子。因此我们的故事得追溯到一个古老的问题——光是什么？</p><p>从光的本质说起很久很久以前，人类祖宗的祖宗就在思考：这世界到底是由什么构成的？古希腊哲人再一次展示出他们惊人的物理直觉：光由一粒一粒非常小的光原子所组成。就这样，微粒说一直统治着上古科学界。直到17世纪初，它才迎来宿敌——波动说。它率先由失恋的数学教授格里马第提出，这个失恋的男人躲在小黑屋里疯狂地做实验。让一束光穿过两个小孔后，他恍惚看到旧情人眼里水波的流动。一瞬间他顿悟了，这不正是一种衍射现象吗？最后，他哭闹着向全世界宣布：光是一种波。1663年左右，英国科学家胡克加入波动学说的阵营中。一开始波动派挺高兴，总算盼来一位猛将。一向视胡克为死对头的牛顿发话了：既然你胡克支持波动说，那——<br>1672年，牛顿发布光的色散实验，矛头直指波动说要害。1704年，他发大招出版《光学》一书。并在序言中写下：为了避免对这些论点的无谓争论，我推迟了这部书的公开发行。波动说阵营群龙无首，无人应战。</p><p>直到一个世纪后——才有一位少年天才敢站到牛顿的对立面，为波动说站台。托马斯·杨。作为物理学五大经典实验之一，在一个月黑风高之夜，天才杨开始了表演：他点燃了一支蜡烛。直接点燃了量子革命的火种，留下了一条历史性的干涉条纹……</p><h3 id="旧量子论的奠基"><a href="#旧量子论的奠基" class="headerlink" title="旧量子论的奠基"></a>旧量子论的奠基</h3><p>麦克斯韦预言光是电磁波的一种，迈出了史诗级的一步。可这预言是对是错，终究得有个人来给它证明。这个人，就是麦克斯韦的弟子—— 赫兹。1887年，赫兹通过一个高频振荡回路，证明了电磁波的存在。这个实验确认了光的波动性。电磁理论的一体化，标志着经典物理达到了顶峰。揭示电磁波存在的同时，赫兹的实验还出现了一个奇怪的现象：光电效应。</p><p>什么是光电效应？就是在高于某频率的电磁波的照射下，某些物质的电子会被光子激发出来，从而形成电流，即光生电。光能转化成电能，物质的电性质由此发生变化……宏观世界的理论无法解释光电效应，后来我们才知道：光电效应的背后，是科学家要研究的新方向。那是一个人类一直不曾进入的世界——微观量子世界。普朗克、爱因斯坦和玻尔这三位奠基者，也马上要登场了。</p><p>1900年，普朗克在研究黑体辐射时大胆假定：能量在发射和吸收时，不是连续不断的，而是一份一份的。这个不连续假设，正是量子理论最初的萌芽。就这样，普朗克稀里糊涂地提出了量子概念。它推翻了微积分几百年的连续基础，开始挖牛顿世界的墙角。大家普遍将1900年12月14日，普朗克发表《论正常光谱的能量分布定律的理论》的这一天当作量子物理学诞生的日子。然而，能量子的概念太激进了！面对这样一个骇人的真相，这个老派绅士被自己吓得魂飞魄散。但提出者无心，研究者有意。</p><p>1905年，听墙角的爱因斯坦开始收割普朗克的劳动果实。天才的直觉告诉爱因斯坦，对于光来说，量子化可能是一种必然的选择。他在普朗克的假设上提出，光以量子的形式存储能量，不累积。一般情况下，一个量子打出一个电子，这就是著名的光量子效应。按照爱因斯坦的理论，光又成了粒子，具有不连续性。但比起旗帜鲜明地站队光到底是微粒还是波，爱因斯坦更在乎自己的直觉。光具有波粒二象性。</p><p>对于20世纪初的科学家来说，你说光既是波又是粒子，这怎么可能？粒子是单个存在的个体，而波则是集体运动的结果，这两者根本不可能统一啊。借此机会，微粒说率先开始了绝地反击。1923年，康普顿看到了光，开始带领微粒军大举反攻。他大胆引入光量子假设，完成了X射线散射实验，光的粒子性被证实。可微粒派还没来得及露出得意的笑容。1923年，法国贵族王子德布罗意出场了。为了阻止微粒说和波动说一触即发的大战，德布罗意从光量子理论中顿悟到：正像光波可以表现为粒子一样，粒子也可以表现为波！不仅仅是光，一切物质都具有波粒二象性。这就是物质波理论。全世界的物理大师都保持沉默，只有爱因斯坦一个人点赞支持德布罗意。就这样，场面一度僵持。</p><p>结果，还没等大家从德布罗意的物质波理论冲击中回过神来——<br>1925年4月，戴维逊和革末进行的电子衍射实验发现：电子居然表现出波动性质！电子居然是个波！这下，波动和微粒双方阵营都炸开了锅。1925年，正当物理学陷入十字路口时，24岁的海森伯出现了，他被认为是微粒派的代表。他试图用数学来解释微观粒子运动。最后，他选择了一种不符合交换率的古怪矩阵来描述量子理论。在玻恩、约尔当和狄拉克的助攻下，很快，海森伯的矩阵力学就在旧量子系统废墟上建立了起来。可好景不长，薛定谔加入了战斗。他被认为是波动派的代表。他嫌矩阵力学太装，故弄玄虚让大家都看不懂。他认为，是微粒还是波，这根本没那么复杂，量子性不过是微观体系波动性的反映。只要把电子看成德布罗意波，用一个波动方程表示电子运动即可。</p><p>他就这样提出了名震20世纪物理学史的薛定谔波函数。看到熟悉的微分方程，那些被海森伯矩阵整得晕头转向的大佬，个个热泪盈眶。毫不犹豫，他们转身就把矩阵力学打入了冷宫。一边是骄傲的海森伯，一边是好胜的薛定谔。一边是以微粒说为基础的矩阵力学，一边是以波动说为基础的波函数。</p><p>矩阵力学和波动力学，从此成了生死天敌。尴尬的是，1926年4月，薛定谔、泡利、约尔当各自证明：两种力学在数学上来说是完全等价的！</p><p>搞了半天，不过是同一理论的不同表达形式而已。两座大厦其实建立在同一地基上：微观粒子的波粒二象性。但旧量子论真正的集大成者，不是普朗克，也不是爱因斯坦，而是来自丹麦的玻尔。1913年，他发表了三篇论文：《论原子和分子的构造》《单原子核体系》《多原子核体系》。这三篇论文成为物理学经典之作，被称为玻尔模型三部曲。用对应原理算出了氢原子能级。经过普朗克、爱因斯坦、玻尔三大先行者的接力，旧量子论终于从牛顿宏观理论的阴影里爬了出来。但这时的人们最多只是刚爬到微观世界的门口，新量子论（即真正意义上的量子力学）仍处于混沌之中。</p><h3 id="量子力学的建立"><a href="#量子力学的建立" class="headerlink" title="量子力学的建立"></a>量子力学的建立</h3><p>普朗克、爱因斯坦、玻尔三人接力救了旧量子论。但真正建立量子力学（新量子论）国度的开国元勋却来自哥本哈根学派。他们的主将有三个：玻恩、海森伯、玻尔（没错，又有玻尔）。</p><p>玻恩算是海森伯的半个老师。他是一名地地道道的物理教授，在哥廷根开了个理论班。海森伯就是在那里跟着玻恩搞科研的。1926年，海森伯哭着跑回家说，他被薛定谔欺负了。在矩阵力学和波动力学被证明等价后的尴尬中，他们两人表面休战，薛定谔却暗中使绊子，到处骂矩阵力学变态。本就高冷难追的矩阵力学，风头远远被薛定谔的波函数盖了过去。玻恩气得肝疼，发誓一定要替自家弟子报仇。他找上了远在哥本哈根的大哥玻尔，准备联合起来找回面子。1926年7月，薛定谔接受玻尔的邀请前往哥本哈根，正春风得意的薛定谔，并未察觉这是一场鸿门宴。</p><p>在他赞美着自己的波函数时，护徒心切的玻恩出手了——玻恩先假仁假义地夸赞了对方一番，再挖了个坑：阁下波函数中的ψ，代表什么？毫无警觉的他，笑呵呵地解释：ψ函数代表电子电荷在空间中的实际分布。玻恩反驳，不，电子本身不会像波那样扩展，而是它的概率分布像一个波。ψ函数代表的不是实际位置，而是电子在某个地点出现的一种随机概率。玻恩很淡定。他以子之矛，攻子之盾，用对方的一个波动实验给出了最好的证明：电子双缝干涉实验。</p><p>电子穿过两道狭缝后，便形成了一个明暗相间的图案，也就是干涉条纹。一个电子究竟出现在哪儿，我们无法确定。连这个世界都是以概率形式存在的，我们只能预言概率。一切都只是随机的？玻恩，你这是在挑战整个科学的决定论根基！借助电子双缝干涉实验，玻恩狠狠扇了薛定谔一个大耳光。但还没等玻恩开心多久，哥本哈根学派自家后院先着火了。 1927年，大哥玻尔改变了对波动力学的看法。当初为了赢薛定谔，他也没少研究波动说，可里里外外解剖完，玻尔突然觉得，这也是个好东西。</p><p>要不试试，把波动说当做量子论的基础，看能不能搞个新理论出来？1927年，闹别扭的海森伯还在跟矩阵较劲。他试图用矩阵来对抗薛定谔方程。在绞尽脑汁的思考过程中，他突然想起：矩阵其实是不符合小学的乘法交换律的！最后研究得出不确定性原理.玻恩的随机概率解释已经让人头大了。这次海森伯更狠，他直接否定了物理学。这是一种哲学上的原则问题。不仅是你波动说，不管你创立什么理论，都必须服从不确定性原理！</p><p>可外界还是不服气。照你们的说法，电子是波也是微粒，不确定性是电子在波和微粒之间的一种随机表现。可你们又没同时见过电子波和电子粒，谁能做证？玻尔急中生智，直接抢白：谁说电子是波又是微粒，就一定能同时观察到两种状态了？为了听上去更有说服力，玻尔还进行了官方陈词总结，这就是互补原理。波和粒子在同一时刻是互斥的.</p><p>概率解释、不确定性原理、互补原理就这样颠覆了人们对宇宙的终极认识。它们共同构成了量子论哥本哈根解释的核心。概率解释与不确定性原理摧毁了世界的因果性，不确定性原理和互补原理合力干掉了世界的绝对客观性。</p><h3 id="爱因斯坦和波尔的战争"><a href="#爱因斯坦和波尔的战争" class="headerlink" title="爱因斯坦和波尔的战争"></a>爱因斯坦和波尔的战争</h3><p>爱因斯坦认为，量子这熊孩子已经长歪了，哥本哈根学派的解释，根本就没有办法说服他。这个当初提出光量子理论的男人，是因果律和客观性的坚定拥护者，却对量子力学（新量子论）嗤之以鼻孔。哥本哈根学派欺负了自己的小弟薛定谔，爱因斯坦决定找个机会好好教训一下他们。哥本哈根派与爱因斯坦总共约架三次。正是这三次约架，奠定了量子力学在物理学上的重要地位，使它成为20世纪最伟大的两大理论之一。</p><p>1927年10月24日，第五届索尔维会议召开。这是他们的第一次约架。看热闹的不少，整个物理学界能排得上号的人基本都来了。爱因斯坦、玻尔、薛定谔、德布罗意、玻恩、普朗克、朗之万，狄拉克、居里夫人……29个人，其中有17个人是诺贝尔奖的获得者！这群人组成了一支物理学全明星梦之队，留下了堪称人类历史上智商巅峰的一张合影。就算不是绝后，也一定是空前的。这支全明星梦之队分为三个阵营：一个是哥本哈根学派，以玻尔为首。成员有海森伯、玻恩、泡利、狄拉克……第二个阵营是他们的老对手，以爱因斯坦为首的反对派。麾下有抱大腿的薛定谔、小王爷德布罗意等几员大将。还有一个闲云野鹤派，他们不在乎你们谁和谁打架，只关心实验结果。<br>最前头站着的是布拉格和康普顿，身后还站着居里夫人、德拜等一群看热闹不嫌事儿大的人。</p><p>德布罗意小王爷一马当先，提出导波的概念，试图推翻概率解释，用因果关系解释波动力学。他说，我虽然提出了物质波，但你们都没搞懂。粒子是波动方程的一个奇点，就像波上的一个包，它必须受波的引导。而这个波，其实就是物质的运动轨迹。导波没有物质波幸运，它遭到了泡利的猛烈反击。被称为上帝之鞭的泡利从小就是个暴脾气。身为海森伯的师兄，他对他们的老师也照样尖刻。极具个性的他，一言不合就丢出一个泡利不相容原理(在费米子组成的系统中不能有两个和两个以上的粒子处于完全相同的状态)如果波是物质的运动轨迹，那你倒是说说，这个运动到底是怎么回事，德布罗意小王爷羞红了脸，下不来台。薛定谔想来助阵，结果自身难保。他的电子云理论被玻恩和海森伯两师徒前后夹击。薛定谔认为，波是真实存在的，电子在空间中的实际分布如波般扩散，就像一团云。可海森伯很嚣张：对不起啊，从你的计算中，我看不到任何可以证明你理论的东西。薛定谔自知自己的计算还不完善，便硬着头皮还击，那你们提出的什么波本征态叠加更胡扯！以一敌二，薛定谔直接被玻恩、海森伯怼到怀疑人生。</p><p>眼看自己的两大亲兵节节败退，在一阵可怕的沉默中，爱因斯坦终于爆发了。他直接提出一个模型：一个电子通过一个小孔得到衍射图像。假设一片隔板中间有一条狭缝，朝着这隔板的狭缝发射一个电子，发射的方向垂直于隔板，电子穿过了狭缝，再移动一段距离后，抵达感应屏障。没错，你们的概率分布是比薛定谔的电子云完备。但你们说，电子在到达感应屏前都不确定，到达的一瞬间概率就变成了100%？这种随机性不是要以超距作用为前提吗？这是违背相对论的！爱因斯坦是神一般的人物，是大当家的玻尔的偶像。面对身为反方带头大哥的爱因斯坦，玻尔勇敢地站了出来。你这个模型，同样不能避免测量时仪器对电子不可控的相互作用，即电子与狭缝边沿的相互作用，电子在通过A缝时如果不超距怎么感知旁边没有其他的缝呢？</p><p>也就是说，其实你这个模型也是符合量子理论的，你还要反驳我们吗？玻尔出招，虽然重剑无锋，但直取对方致命弱点。爱因斯坦想反驳，可憋了半天，愣是没憋出一个字。会场鸦雀无声……第一个回合，哥本哈根学派胜出。低估了对手实力，爱因斯坦很不服气。他又提出一个模型：电子双缝干涉实验。若控制装置，让某一时刻只有一个粒子穿过，并分别关闭狭缝，就可以测出电子的准确路径和位置。而由干涉条纹又可计算电子波的波长，从而可精确确定电子的动量。怎么样，这下你们的测不准关系被否定了吧？爱因斯坦自以为这局一定稳胜，可玻尔却古怪地笑了：爱因斯坦先生，如果你关上其中任何一个狭缝，实验的状态就完全改变了！双缝开启干涉现象也不再出现，实验又回到了单缝状态，等于又多了一次不确定因素！这个实验，不但没反驳成功互补原理，反而用互补原理说明了波粒二象性！第二回合，还是哥本哈根学派胜！六天的会议，变成了这两个人的对台戏。爱因斯坦屡战屡败却越挫越勇。最后，他恼羞成怒，扔下了一句物理学名言：玻尔，上帝不掷骰子！玻尔此时也已经豁出去了，他毫不留情地回呛：爱因斯坦，别去指挥上帝该怎么做！第一次爱玻之战，以爱因斯坦的惨败告终。</p><p>1930年，第六届索尔维会议召开。这是他们的第二次约架。这次，爱因斯坦有备而来。他先发制人，快准狠地打出一张实验牌：光箱子。箱子里有n个光子，时间间隔Δt之后打开箱子，每次只放出一个光子，Δt确定。再用理想的弹簧秤测出箱子的质量，发现轻了Δm，将Δm代入质能方程E=mc2，ΔE也确定。既然ΔE和Δt都确定，那你们家不确定性原理，ΔEΔt＞h，也就不成立！玻尔毫无思想准备，当场蒙了。第二天一大早，一夜没合眼的玻尔，顶着两个浓重的黑眼圈出现在台上。好，你说一个光子跑了，箱子轻了Δm，这没问题。那怎么测量这个Δm呢？广义相对论中的红移效应，即光频率降低的现象。引力场可以使原子的频率变低，也就是红移，等效于时间变慢。你想要准确测量Δm或ΔE，可你其实根本没办法控制光子逃出的时间Δt，它测不准。爱因斯坦哑口无言。苦心孤诣三年，他和薛定谔、德布罗意在小黑屋反复沙盘推演，原以为万无一失、可以一招制敌。可自己精心设计的实验，又一次成了不确定性原理的一个绝佳例证。第二次约架，爱因斯坦又输了！</p><p>1933年，第七届索尔维会议召开。可彼时，爱因斯坦正被纳粹逼得在异国他乡流浪，他缺席了。缺了爱因斯坦，会议变得索然无味。丢了主心骨的薛定谔、德布罗意两人，在新量子论的喧闹中沉默不语。1935年，孤独的爱因斯坦又找到了两个同盟军，波多尔斯基和罗森，他们联合发表了一篇论文。论文的名字特别长，叫《量子力学对物理实在的描述可能是不完备的》。</p><p>这一次，是双方的第三次约架。爱因斯坦吸取了之前血的教训。他不再攻击量子力学的正确性，而准备改说它是不完备的。对于量子力学，爱因斯坦心理上有两个坎儿过不去。一个是，怎么可能有超光速信号的传播？爱因斯坦称之为定域性。另外一个是实在性：你不去看，难道天上的月亮就不存在了吗？爱因斯坦准备了一个实验，来说明量子力学违背了定域实在论，大意是：一个母粒子分裂成两个自旋方向相反的子粒子A和B。这两个粒子是互相影响的。如果粒子A为左旋，那B一定是右旋，以保持总体守恒，反之亦然。</p><p>按照量子力学的解释，这两个粒子相互之间是有联系的。那么，如果这两个粒子分开足够远——比如，粒子A在银河系的这头，粒子B在银河系的那头，相隔10万光年以上。你对粒子A吹口气，难道粒子B也会在一瞬时做出相对的反应吗？(这两个纠缠态的粒子,薛定谔成为量子纠缠,)因此，量子力学并不完备！</p><p>综上所述，这就是整篇论文的论据。这个思想实验，也被称为EPR佯谬，命名灵感来自三人名字的缩写。玻尔淡定地给出了反击——你二话不说就先假定了两个粒子在观察前，分别都有个客观的自旋状态存在。这两个客观存在的粒子是哪儿来的？根据量子力学的理论，在没有观测前，一个客观独立的世界并不存在，更不存在客观独立的两个粒子。它们本就是一个相互联系、相互影响的整体。在被观测之后，粒子A、粒子B才变成客观真实的存在。我们两个前提都不一样，量子力学仍然是完备、逻辑自洽的。不得不说，爱因斯坦是一个伟大的反对派。作为一代科学巨匠，他的反对成了量子力学最好的试金石，每一次他提出的问题，都推动量子力学前进了一大步。甚至有人怀疑他是量子力学派来的卧底。1962年，玻尔去世后的第二天——人们在他的黑板上，发现了当年爱因斯坦光箱子的实验草图。他对爱因斯坦的反对是如此眷恋，至死还萦绕于心。而此时的爱因斯坦，已经去世了7年。</p><h3 id="薛定谔的猫"><a href="#薛定谔的猫" class="headerlink" title="薛定谔的猫"></a>薛定谔的猫</h3><p>在爱因斯坦的光环下，薛定谔虽然只是小弟，但自身同样也是实力一流的大科学家。哥本哈根学派第一条核心原理——概率诠释，就是用薛定谔方程来描述量子行为。虽然不怎么喜欢他这个反对党，但哥本哈根派也不得不承认薛定谔是量子力学的奠基人之一。除此之外，薛定谔还是分子生物学的开山鼻祖，他写的《生命是什么》一书畅销至今。</p><p>薛定谔的猫是怎么来的呢？爱因斯坦落败后，老薛心里极度憋屈又扭曲。他又一次复习了EPR理论，觉得没毛病啊！薛定谔认为爱因斯坦没有错，错的是哥本哈根学派，这一派个个都是诡辩高手。他得再做一个实验，这个实验要让每个人一眼就看懂。正想着实验怎么做的薛定谔扫了一眼周围——他的猫正在撕咬他的论文《量子力学的现状》！气不打一处来的薛定谔灵光乍现：这么皮，把你拿去做实验好了！薛定谔把猫放进一个不透明的盒子里。<br>盒子连接到一个包含放射性原子核和有毒气体的实验装置中。可怜的猫被活生生关在里面。如果原子衰变了，毒气瓶会被打破，盒子里的猫会被毒死。要是原子没有衰变，猫就好好地活着。根据量子力学理论，原子核处于衰变和未衰变的叠加态。那么这只猫理所当然也随着原子核叠加进入一种又死又活的状态。这样一只猫，与我们的常识是如此相悖。</p><p>薛定谔得意地大笑：玻尔，你们见过一只又死又活的猫吗？薛定谔的猫思想实验的高超之处在于：它将看不见的微观世界与可视化的宏观世界联系了起来。这只猫，成了行走于宏观世界和微观世界的灵宠。你们不是欺负人们看不到吗？我现在就让全世界看到你们哥本哈根学派的丑陋！你们非要将我的波函数方程解释成粒子的一种叠加概率波。你看，现在搬起石头砸自己的脚了吧！叠加态不是微观世界量子论的核心吗？现在我将它带到宏观世界了，你们自己看看，它是多么可笑！薛定谔的猫实验否定的是哥本哈根学派的概率解释。如果量子力学的三大基石之一被毁掉了，那科学家进军微观世界的梦想将彻底破灭。</p><p>首先给出解释的，还是哥本哈根学派。哥本哈根学派其实心里也有点虚，但他们只能硬着头皮上：你的实验盒子里，有一个计数器是用来测量原子是否衰变的。从这一步测量开始，波函数的叠加态就已经坍缩了。后面的猫是生是死，完全是属于经典世界的，不存在叠加态。可不久，现代应用计算机鼻祖，年青的冯·诺伊曼就一针见血地指出：不对！计数器本身也是由微观粒子组成的！你用B去测量A，用C去测量B，只不过是A的叠加态转移到了B，B的不确定又转移到了C……到最后，整个大系统的波函数还是没有坍缩。到最后，波函数之所以坍缩，还是因为人的意识参与。只要没有被意识到，猫就是又死又活的。可究竟什么是意识？大脑？灵魂？思想？这种解释太唯心主义了。</p><p>暗中窥视的爱因斯坦一派伺机而动。看到量子力学大厦被意识决定论搞得摇摇欲坠，他们悄悄带来了第二种解释，也就是反哥本哈根学派的诠释。他们不反对量子力学，只想在量子力学的世界抢班夺权，掠取哥本哈根学派打下来的量子江山。它的代表人是玻姆。1952年，玻姆创立了一个完整的隐变量体系。在玻姆看来，哥本哈根学派含糊混淆的那些现象，主要是因为存在着一个隐形变量。为此，他用高超的数学手法复活了导波。写下了一个复杂得让许多科学家觉得生无可恋的隐函数。玻姆说，这个隐变量，就是爱因斯坦寻找的神秘力量。但因为我们还没有发现，也发现不了，所以微观粒子才表现出不确定，才会有叠加态。(奥拉姆剃刀原则,即简单有效原则,如果同一种现象有两种或多种不同的假说,我们应该采取最简单或可证伪的)虽然看上去特别有道理，但不能证伪，玻姆的隐函数同样难以服众！这明显违反了奥卡姆剃刀原则。</p><p>1957年，又一个不走寻常路的家伙出现了：埃弗莱特。他带来了荒谬又可笑的第三种解释。他大大咧咧地说，别多愁善感了，根本没有什么又死又活的叠加猫，猫也不是你看一眼就死了的。本来就有两只猫，一只是活着的，另一只死了。只不过这两只猫各自在两个世界里，两个你看到了不同的猫。埃弗莱特眼中有一个量子世界：整个宇宙是一个总体的波函数叠加系统，里面包含了很多个完全孤立、互不干涉的子世界。从宇宙大爆炸以来，这些世界就各自演化着，谁也看不到谁。这就是平行宇宙解释.（Many Worlds Interpretation，简称MWI）。</p><p>一群继承了多宇宙思想的科学家。他们在MWI基础上发展出了一种新的解释：退相干。这种新解释，就是第四种解释，也是目前的主流解释。它解释了MWI中为何平行世界没有在宏观中显示叠加态。通俗点来说，就是解释了为什么我们感受不到另外一个平行世界。退相干的理论研究者首先指出，不可能有同时又死又活的猫。如果猫是活的，那一步步反推回去，毒气瓶就没有碎，放射性原子也没有衰变，反之同理。也就是说，如果猫不生死叠加，那放射性原子也是不叠加的，波函数早就坍缩了。那波函数是什么时候坍缩的？又是什么东西导致它坍缩的？<br>这群人给出的答案是：无论是薛定谔的盒子，还是整个宏观世界，都是由无数微观粒子组成的。它们的叠加性其实也是一种相干性。但量子的相干性会因外部环境的干涉而逐渐消失。说白了，就是其他粒子影响了盒子里的放射性原子，最后变成宏观性质了。量子退相干是德国学者汉斯在1970年提出的。但和可怜的埃弗莱特一样，当时并没有多少人注意到它。直到1984年，哈特尔的关注才让退相干理论正式发展壮大起来。退相干历史认为在宇宙中世界只有一个，但历史有很多个，分为粗粒历史、精细历史。精细历史是量子历史，无法求解概率，粗粒历史是经典历史，在宏观上显示，类似于路径积分，可以计算概率。每一个粒子都处在所有精细历史的叠加中，比如放射性原子。但一旦涉及宏观物体，我们所能观察到的就是一些粗粒化的历史，比如打开盒子后看到的猫。因为量子退相干了，这些历史永久地失去了联系，只剩一种被我们感知到。本该是粒子叠加态的薛定谔实验，打开盒子后，就只能看到一种状态的猫（生/死）。虽然退相干并不是十全十美，但无论是从数学上还是哲学上，它都让三维世界的我们好受一点。现在它已经成为量子力学的主流理论之一。不少科学家正利用它来建立真正的现实应用。量子计算与量子通信就正在与退相干做斗争。</p><p>薛定谔本来想让他的猫恶心哥本哈根学派，嘲讽一下量子力学。结果他到死也没想到，他的猫竟然成了量子世界的鲇鱼。只能说，薛定谔不愧是爱因斯坦的小弟，连给量子力学送助攻，都和爱因斯坦一模一样。爱因斯坦提出的EPR佯谬像不可攻破的堡垒。尽管在量子风暴中饱受摧残，它的定域实在论仍然牢牢把守着经典世界的大门。哪怕爱因斯坦曾三次落败。可直到去世，他心底里其实也没被玻尔说服。这两个伟大科学家之间的较量，早就超越了个人之间的战争，是一场关于世界本质的辩论。</p><p>微观世界到底符合定域实在论（经典），还是量子不确定性？最终一定要做一个了断。1964年，爱因斯坦的信徒——贝尔，重温了EPR佯谬。把定域实在论转化为另一种令所有科学家心服口服的语言。他提出了一个不等式——(|pxz-pzy| &lt;= 1+pxy)这个不等式用超越了宇宙文明维度的数学语言铸就而成，被称为科学史上最深刻的发现。既然在物理世界没办法决出高下，我们就转战到更本质的数学领域，用数学来判断究竟谁对谁错。</p><h3 id="贝尔不等式"><a href="#贝尔不等式" class="headerlink" title="贝尔不等式"></a>贝尔不等式</h3><p>贝尔不喜欢量子力学听上去主观又唯心的一套。他想要的是一个确定的、客观的世界。贝尔有自己隐藏的绝招，那就是1952年玻姆提出的隐函数。在新一代大神冯·诺伊曼的禁锢中，隐变量举步维艰。可贝尔坚持认为，隐变量是反击哥本哈根学派的大杀器。玻姆的隐变量抛弃了定域性，但它至少恢复了世界的实在性。只要他在这基础上再证明一个定域隐变量的存在，就证明了量子力学的非定域性也是错的。他撸起袖子，研究起了爱因斯坦的老实验：EPR佯谬。在EPR佯谬理论中，一个母粒子分裂成了两个自旋方向相反的子粒子A和B。按照爱因斯坦一派关于隐变量的思想，两个子粒子A和B，就像南北极的两只手套。不管你观测不观测，它们是左手还是右手，从分开那时起就已经确定了。既然宇宙中不存在超距作用那么，在观测的一瞬间，两个纠缠的粒子必然在经典世界存在某种极限。假设Pxy是粒子A在x方向上和粒子B在y方向上的相关性，Pzy、Pxz同理，则可得出：(|pxz-pzy| &lt;= 1+pxy)，这个不等式对宇宙的本质做出了最后的裁决。</p><p>它意味着，如果我们的世界同时满足：1.定域的，也就是没有超光速信号的传播。2.实在的，也就是说，存在着一个独立于我们观察的外部世界。那么两个具有相反自旋方向的粒子，它们的运动，必定受限于不等式。简单来说，就是——如果微观世界是经典的，那么不等式成立。反之，则不成立。这个由隐变量理论推导出来的式子，它打破了一直以来的僵局，隐变量重见天日，一个定域又实在的世界近在眼前。物理学家开始骚动起来，他们按捺不住，想要亲身参与到大结局中。在数学与好奇心的撩拨下，他们纷纷动手改造起了EPR佯谬思想模型，做起了贝尔不等式实验。1972年，有个叫克劳泽的小厮成功实现了实验。这是史上第一个验证贝尔不等式的实验。不过，结果让贝尔魂飞天外——那两个纠缠的粒子，竟然突破了贝尔不等式？？！这意味着，真的存在鬼魅般的量子纠缠？贝尔心心念念的微观世界经典性竟然是错的。</p><p>1982年，在巴黎奥赛光学研究所，又一场惊心动魄、万众瞩目的实验正在进行，这一次所有人都屏住了呼吸。这次的实验领导人是正在读博士的阿斯派克特。不同于克劳泽的幼稚版装置，阿斯派克特的技术非常成熟。借助激光的强信号源，一对对光子从钙原子中冲出，朝着偏振器奔去，它们关乎整个量子力学的命运。在令人窒息的24个小时的等待后，结果 出来了：实验再一次与贝尔想要的结果相反，玻尔是对的，爱因斯坦又一次输了！世界再也不可能回到那个美好的经典时代了。</p><p>数学是物理学的基石，贝尔不等式用严谨的数学手段覆灭了整个爱因斯坦军团，EPR实验最终成了EPR佯谬。数学的降维打击助力量子力学取得了胜利。在克劳泽和阿斯派克特之后，还有一大批追求完美的科学家也进行了实验。从5倍偏差，到9倍偏差，再到30倍偏差……模型越来越完备，技术越来越精密，都证明了玻尔是对的。多年爱玻之争，终于在宇宙判决书贝尔不等式中画上了句号。</p><p>此后量子力学的追随者开始分成两拨继续探索。一拨是勤耕不辍的理论派。他们一直试图深入微观世界，甚至想统一整个宇宙。为了达成这个长期目标，理论派把宇宙划分为4种力：电磁作用力、强相互作用力、弱相互作用力、引力。通过这4种力，一切物理现象都可以得到解释。天才科学家们找到了一种大一统理论，先用它将前三种属于量子力学的基础作用力都装进去，剩下一种属于广义相对论的引力，他们寄希望于更前沿的弦理论。弦理论认为，自然界的基本单元不是传统意义上的点状粒子。而是很小很小的橡皮筋一样的线状弦。当我们用不同的方式弹橡皮筋，它就会振动，产生自然界中的各种粒子，可能是电子、光子，也可能是引力子。这样，引力就有望被微观量子化描述，和前三种力统一在一起。微观（量子力学）和宏观（广义相对论）也就有望统一了。<br>除了有着远大抱负的理论派外，另外一拨量子力学的追求者是实践派。这是一群实用主义者，他们挖掘出一项又一项伟大的量子应用。没有它，我们就不会有CD、DVD、蓝光影碟播放器；没有它，也不会有晶体管、智能手机、电脑、卫星导航；没有它，更不会有激光、电子显微镜、原子钟、核磁共振显示装置……</p><p>有了量子力学，人类便进入了一个新时代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;读-lt-lt-上帝的骰子-gt-gt&quot;&gt;&lt;a href=&quot;#读-lt-lt-上帝的骰子-gt-gt&quot; class=&quot;headerlink&quot; title=&quot;读&amp;lt;&amp;lt;上帝的骰子&amp;gt;&amp;gt;&quot;&gt;&lt;/a&gt;读&amp;lt;&amp;lt;上帝的骰子&amp;gt;&amp;gt;&lt;/h1
      
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="科普 物理 量子力学" scheme="http://yoursite.com/tags/%E7%A7%91%E6%99%AE-%E7%89%A9%E7%90%86-%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 插件开发指南</title>
    <link href="http://yoursite.com/2020/05/10/Chrome%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2020/05/10/Chrome 插件开发指南/</id>
    <published>2020-05-10T03:47:49.000Z</published>
    <updated>2021-08-30T09:48:58.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chrome-插件开发指南"><a href="#Chrome-插件开发指南" class="headerlink" title="Chrome 插件开发指南"></a>Chrome 插件开发指南</h1><h3 id="开发与调试"><a href="#开发与调试" class="headerlink" title="开发与调试"></a>开发与调试</h3><p>chrome插件没有严格的项目结构要求，只有保证本目录有一个 <code>manifest.json</code> 即可，从<code>浏览器菜单-更多工具-扩展程序</code>可以进入插件管理页面。或直接输入地址 <a href="https://www.notion.so/chrome-extensions-09ff4f8b5fb448d7addd8727b9fa90cb" target="_blank" rel="external">chrome://extensions</a>访问。</p><p>勾选开发者模式可以用文件夹的形式直接加载插件，否则只能安装.crx 格式的文件。<br>mac 系统下插件安装目录为: <code>~/Library/Application Support/Google/Chrome/Default/Extensions</code></p><h3 id="核心介绍"><a href="#核心介绍" class="headerlink" title="核心介绍"></a>核心介绍</h3><ol><li><p>manifest.json</p><p> 用来配置插件相关的配置信息，必须放在根目录。且以下属性是必不可少的。完整属性可以查看<a href="https://developer.chrome.com/extensions/manifest" target="_blank" rel="external">官方文档</a>。</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"manifest_version"</span> : <span class="number">2</span>,</span><br><span class="line"><span class="string">"name"</span> : <span class="string">"test"</span>,</span><br><span class="line"><span class="string">"version"</span> : <span class="string">"1.0.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>content-scripts    (插件与页面交互)</p><p> 是 chrome 插件向页面注入脚本的一种形式,我们可以通过manifest.json配置轻易的向页面注入 js 和 css,最常见的是广告屏蔽,页面样式定制等等.</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"content-scripts"</span> : [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"matches"</span> : [<span class="string">"http://*/*"</span>, <span class="string">"&lt;all_urls&gt;"</span>],</span><br><span class="line"><span class="string">"js"</span>: [<span class="string">"js/xxx.js"</span>,<span class="string">"....js"</span>],</span><br><span class="line"><span class="string">"css"</span>: [<span class="string">"css/xx.css"</span>],</span><br><span class="line"><span class="string">"run_at"</span>: <span class="string">"document_start"</span> <span class="comment">// 可选 document_start/end/idle(默认空闲)</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> content-scripts 与原始页面共享DOM，但不共享JS，如果想要访问页面JS某个变量，只能通过 injected js 来实现，content-scripts不能访问绝大部分chrome.xxx.api, 除了以下四种。</p><pre><code>- chrome.extension(getURL,inIncognitoContext, lastError,onRequest,sendRequest)- chrome.i18N- chrome.runtime(connect,getManifest,getURL,id, onConnect,onMessage,sendMessage)- chrome.storage</code></pre></li><li><p>background<br> 后台是一个常驻的页面,它随着浏览器的开关而开关.通常把需要一直运行的代码放在 background 里面.<br> 他的权限非常高,可以调用 chrome 的扩展 API(除了 devtools), 而且它可以无限制跨域.配置中,background 可以通过 page 指定一个页面,也可以通过 scripts 指定一个 js,chrome 会自动为这个 js 生成一个默认页面.</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"background"</span>:&#123;</span><br><span class="line"><span class="string">"page"</span>: <span class="string">"xxx.html"</span></span><br><span class="line"><span class="comment">// scripts: ["js/xxx.js"]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>event-pages<br> 鉴于 background 生命周期和浏览器同步,长时间挂载后台影响性能,而 event-pages 与 background 唯一的区别就是多了一个 persistent 参数,它会在需要时被加载,空闲时被关闭.一般 background 用的比较多.</p></li><li><p>popup<br> popup 是点击插件图标时打开的一个窗口网页,焦点离开网页就关闭,一般做一些交互使用.<br> popup 可以包含任意你想要的 HTML,并且会自适应大小,可以通过 default_popup 来指定页面,也可以调用 setPopup()方法.</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"browser_action"</span> : &#123;</span><br><span class="line"><span class="string">"default_icon"</span>: <span class="string">"img/xx.png"</span>,</span><br><span class="line"><span class="string">"default_title"</span>: <span class="string">"悬停时的标题"</span>,</span><br><span class="line"><span class="string">"default_popup"</span>: <span class="string">"xx.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> popup 的生命和周期很短,需要长时间运行的代码不要放在 popup 里.popup 中可以通过 chrome.extension.getBackgroundPage() 获取 background 的 window 对象.</p></li><li><p>injected-script<br> content-script 无法访问页面中的 js,虽然它可以操作 dom,但 dom 却不能调用它,也就是在 dom 的事件中无法调用 content-script 中的代码,但是在页面中添加一个按钮并调用插件的 api 是很常见的需求,我们可以再 content-script 中通过 DOM 方式向页面注入 inject-script.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// content-script</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectCustomJs</span>(<span class="params">jsPath</span>)</span>&#123;</span><br><span class="line">jsPath = jsPath || <span class="string">'js/inject.js'</span>;</span><br><span class="line"><span class="keyword">var</span> temp = <span class="built_in">document</span>.creatElement(<span class="string">"script"</span>);</span><br><span class="line">temp.src = chrome.extension.getURL(jsPath); <span class="comment">// 类似于 chrome-extension://xxxx/js/inject.js</span></span><br><span class="line">temp.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parentNode.removeChild(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  代码会报错,因为在 web 中直接访问插件中的资源必须显示声明才行,在配置文件中增加以下配置:</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 普通页面能够直接访问的插件资源列表,不设置无法直接访问.</span></span><br><span class="line"><span class="string">"web_accessible_resources"</span>: [<span class="string">"js/inject.js"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  inject-script 如何调用 content-script 中的代码,要用到消息通信.</p></li><li><p>homepage_url<br> 开发者网站</p></li></ol><h3 id="Chrome-插件的-8-种展示形式"><a href="#Chrome-插件的-8-种展示形式" class="headerlink" title="Chrome 插件的 8 种展示形式"></a>Chrome 插件的 8 种展示形式</h3><ol><li><p>browserAction 浏览器右上角图标</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"browser_action"</span> : &#123;</span><br><span class="line"><span class="string">"default_icon"</span>: <span class="string">"img/xx.png"</span>, <span class="comment">// 19*19 </span></span><br><span class="line"><span class="string">"default_title"</span>: <span class="string">"悬停时的标题"</span>,</span><br><span class="line"><span class="string">"default_popup"</span>: <span class="string">"xx.html"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 通过 setIcon 更改 icon, setTitle()更改鼠标 hover 时的标题.setBadgeText()来更改图标上的文本信息.</p></li><li><p>pageAction 地址栏右侧<br> 当某些特定页面打开时会在地址栏右边显示的图标.(新版吧位置放到了浏览器右边,可以把它看成置灰的 browserAction.<br> 例如当打开百度时才显示图标.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.runtime.onInstalled.addListener(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">chrome.declarativeContent.onPageChanged.removeRules(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">chrome.declarativeContent.onPageChanged.addRules([</span><br><span class="line">&#123;</span><br><span class="line">conditions: [</span><br><span class="line"><span class="comment">// 只有打开百度才显示pageAction</span></span><br><span class="line"><span class="keyword">new</span> chrome.declarativeContent.PageStateMatcher(&#123;<span class="attr">pageUrl</span>: &#123;<span class="attr">urlContains</span>: <span class="string">'baidu.com'</span>&#125;&#125;)</span><br><span class="line">],</span><br><span class="line">actions: [<span class="keyword">new</span> chrome.declarativeContent.ShowPageAction()]</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>右键菜单<br> 通过 chrome.contextMenus API,右键菜单可以出现在不同的上下文.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;<span class="string">"permissions"</span>: [<span class="string">"contextMenus"</span>]&#125;</span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.contextMenus.create(&#123;</span><br><span class="line">title: <span class="string">"测试右键菜单"</span>,</span><br><span class="line">onclick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'您点击了右键菜单！'</span>);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> <a href="https://developer.chrome.com/extensions/contextMenus" target="_blank" rel="external">常见 API 参考</a> </p></li><li><p>覆盖特定页面<br> 使用 override 页可以将 chrome 默认的一些特定页面替换掉.一个插件只能替代一个默认页.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"chrome_url_overrides"</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"newtab"</span>: <span class="string">"newtab.html"</span>,</span><br><span class="line"><span class="string">"history"</span>: <span class="string">"history.html"</span>,</span><br><span class="line"><span class="string">"bookmarks"</span>: <span class="string">"bookmarks.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>devtools(开发者工具)<br> 例如 vue.js devtools , chrome 可以再 devtools 上新增一个面板.<br> devtools 页面会随着开发者工具的开关而开关.可以访问 Devtools API ,而其他比如 background 无权访问.</p><ul><li>chrome.devtools.panels: 面板相关</li><li>chrome.devtools.inspectedWindow: 获取被审查窗口的信息</li><li><p>chrome.devtools.network: 获取有关网络请求的信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"devtools_page"</span>: <span class="string">"XXX.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 html 一般什么都没有,只有一个 script 标签引用 js 文件<code>&lt;script src=&#39;js/devtools.js&#39;&gt;&lt;/script&gt;</code>,<br>再看一下 devtools 的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建自定义面板，同一个插件可以创建多个自定义面板</span></span><br><span class="line"><span class="comment">// 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调</span></span><br><span class="line">chrome.devtools.panels.create(<span class="string">'MyPanel'</span>, <span class="string">'img/icon.png'</span>, <span class="string">'mypanel.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">panel</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'自定义面板创建成功！'</span>); <span class="comment">// 注意这个log一般看不到</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 创建自定义侧边栏</span></span><br><span class="line">chrome.devtools.panels.elements.createSidebarPane(<span class="string">"Images"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">sidebar</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// sidebar.setPage('../sidebar.html'); // 指定加载某个页面</span></span><br><span class="line">sidebar.setExpression(<span class="string">'document.querySelectorAll("img")'</span>, <span class="string">'All Images'</span>); <span class="comment">// 通过表达式来指定</span></span><br><span class="line"><span class="comment">//sidebar.setObject(&#123;aaa: 111, bbb: 'Hello World!'&#125;); // 直接设置显示某个对象</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 访问被检查的页面DOM需要使用inspectedWindow</span></span><br><span class="line">chrome.devtools.inspectedWindow.eval(<span class="string">"jQuery.fn.jquery"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result, isException</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> html = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span> (isException) html = <span class="string">'当前页面没有使用jQuery。'</span>;</span><br><span class="line"><span class="keyword">else</span> html = <span class="string">'当前页面使用了jQuery，版本为：'</span>+result;</span><br><span class="line">alert(html);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>选项页 option<br> 选项页是插件的设置页面,有两个入口,一个是右键图标菜单,一个是插件管理页面.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">//"options_page": "options.html" ,(老版本写法)</span></span><br><span class="line"><span class="string">"options_ui"</span>: &#123;</span><br><span class="line"><span class="string">"page"</span>: <span class="string">"optionxxx.html"</span>,</span><br><span class="line"><span class="string">"open_in_tab"</span>: <span class="literal">true</span>, <span class="comment">// 在当前 tab 打开</span></span><br><span class="line"><span class="string">"chrome_style"</span>: <span class="literal">true</span> <span class="comment">//  添加了一些默认样式</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不能使用 alert, 数据存储建议使用 chrome.storage, 因为会随用户自动同步</p></li><li><p>omnibox<br> 注册某个关键字触发插件自己的搜索建议界面.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span></span><br><span class="line"><span class="string">"omnibox"</span>: &#123; <span class="string">"keyword"</span> : <span class="string">"go"</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后在 background 注册监听事件:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">chrome.omnibox.onInputChanged.addListener(<span class="function">(<span class="params">text, suggest</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'inputChanged: '</span> + text);</span><br><span class="line"><span class="keyword">if</span>(!text) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(text === <span class="string">'xxx'</span>)&#123;</span><br><span class="line">suggest([</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">'百度搜索 '</span> + text, <span class="attr">description</span>: <span class="string">'百度搜索 '</span> + text&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">'谷歌搜索 '</span> + text, <span class="attr">description</span>: <span class="string">'谷歌搜索 '</span> + text&#125;,</span><br><span class="line">]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>桌面通知:<br> chrome 提供了一个 chrome.notification API 方便插件推送桌面通知.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrome.notifications.create(<span class="literal">null</span>,&#123;</span><br><span class="line">type: <span class="string">"basic"</span>,</span><br><span class="line">iconUrl: <span class="string">"img/xx.ping"</span>,</span><br><span class="line">title: <span class="string">"标题"</span>,</span><br><span class="line">message: <span class="string">"内容"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="消息通信"><a href="#消息通信" class="headerlink" title="消息通信"></a>消息通信</h3><ul><li><p>popup 和 background<br>  popup 可以直接调用 background 的 js 方法,也可以访问 background 的 DOM.</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// background.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"background"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// popup.js</span></span><br><span class="line"><span class="keyword">var</span> bg = chrome.extension.getBackgroundPage();</span><br><span class="line">bg.test();</span><br><span class="line">bg.document.body.innerHTML; <span class="comment">// dom</span></span><br></pre></td></tr></table></figure></li><li><p>popup 或 bg 向 content 发消息</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bg,popup.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessageToContent</span>(<span class="params">message,callback</span>)</span>&#123;</span><br><span class="line">chrome.tabs.query(&#123;<span class="attr">active</span>:<span class="literal">true</span>,<span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span>&#123;</span><br><span class="line">chrome.tabs.sendMessage(tabs[<span class="number">0</span>].id,message,<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(callback) callback(res);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// content-script.js 接收</span></span><br><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">req,send,res</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(req.cmd == <span class="string">'test'</span>) alert(req.value);</span><br><span class="line">send(<span class="string">"我收到了你的消息"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>content 向 bg/popup 主动发消息</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// content-script.js</span></span><br><span class="line">chrome.runtime.sendMessage(&#123;</span><br><span class="line">greeting: <span class="string">"hello"</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"收到回复"</span> + res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// bg 或 popup.js</span></span><br><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">req,send,res</span>)</span>&#123;</span><br><span class="line">send(<span class="string">"我收到了你的消息"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>injected script 和 content script<br>  content-script 和页面内 脚本(injected-script)之间唯一共享的就是页面 DOM 元素.有两种方式实现通信,一是通过 window.postMessage 和 window.addEventListener 实现消息通信(推荐),二是通过 自定义 dom 事件.</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// injected - script</span></span><br><span class="line"><span class="built_in">window</span>.postMessage(&#123;<span class="string">"test"</span>: <span class="string">'hello'</span>&#125;,<span class="string">'*'</span>);</span><br><span class="line"><span class="comment">// content- script</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(e.data)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li><li><p>长连接和短连接<br>chrome 插件中有两种通信方式,一种是短连接(chrome.tabs.sendMessage和 chrome.runtime.sendMessage),一个是长连接(chrome.tabs.connect 和 chrome.runtime.connect).</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长连接</span></span><br><span class="line"><span class="comment">// popup.js</span></span><br><span class="line"><span class="keyword">var</span> port = chrome.tabs.connect(tabId,&#123;<span class="attr">name</span>: <span class="string">'test-connect'</span>&#125;);</span><br><span class="line">port.postMessage(&#123;<span class="attr">xxx</span>:<span class="string">'xxx'</span>&#125;);</span><br><span class="line">port.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">alert(<span class="string">'收到消息'</span> + msg.answer)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// content-script</span></span><br><span class="line">chrome.runtime.onConnect.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">port</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(port === <span class="string">'test-connect'</span>)&#123;</span><br><span class="line">port.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"收到长连接"</span>,msg)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li><p>获取当前窗口 id</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chrome.windows.getCurrent(<span class="function"><span class="keyword">function</span>(<span class="params">cw</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(cw.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>获取当前标签页 id</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentTabId</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">chrome.tabs.query(&#123;<span class="attr">active</span>:<span class="literal">true</span>,<span class="attr">currentWindow</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(callback) callback(tabs.length ? tabs[<span class="number">0</span>].id : <span class="literal">null</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定期执行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置</span></span><br><span class="line"><span class="string">"permissions"</span>: [<span class="string">"alarms"</span>]</span><br><span class="line"><span class="comment">// 创建方法</span></span><br><span class="line">chrome.alarms.create(name,info);<span class="comment">// name 为任务名, info 包含以下属性 when 何时,dalayInMinutes 延迟时间, periodInMinutes 非 null表示时间间隔,单位 min</span></span><br><span class="line">chrome.alarms.onAlarm.addListener(xxx); <span class="comment">// 触发事件</span></span><br></pre></td></tr></table></figure></li><li><p>本地存储<br>chrome.storage 是针对插件全局的,即使在 background 中保存的数据,在 content-script 也能获取到.chrome.storage.sync 可以跟随当前登录用户自动同步.需要声明 storage 权限,有 sync 和 local 两种方式选择.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据,第一个参数是要读取的 key 以及默认值</span></span><br><span class="line">chrome.storage.sync.get(&#123;<span class="attr">color</span>: <span class="string">'red'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">items</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(items)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">chrome.storage.sync(&#123;<span class="attr">color</span>:<span class="string">'blue'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'save success'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>快捷键唤醒 popup</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"commands"</span>: &#123;</span><br><span class="line"><span class="string">"_execute_browser_action"</span>:&#123;</span><br><span class="line"><span class="string">"suggested_key"</span>:&#123;</span><br><span class="line"><span class="string">"default"</span>: <span class="string">"Alt+Shift+J"</span>  <span class="comment">// 快捷键唤醒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>webRequest<br>通过 webrequest API 可以对 HTTP 请求进行修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//权限申请</span></span><br><span class="line"><span class="string">"permissions"</span>: [</span><br><span class="line"><span class="string">"webRequest"</span>, <span class="comment">// web请求</span></span><br><span class="line"><span class="string">"webRequestBlocking"</span>, <span class="comment">// 阻塞式 web 请求</span></span><br><span class="line"><span class="string">"storage"</span>,<span class="comment">// 插件本地储存</span></span><br><span class="line"><span class="string">"http://*/*"</span> <span class="comment">//可以通过 executeScript 或 insertCss 访问的网站</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// web 请求监听</span></span><br><span class="line">chrome.webRequest.onBeforeRequest.addListener(<span class="function"><span class="params">details</span> =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">let</span> showImage = <span class="literal">false</span> ; <span class="comment">// 不展示图片</span></span><br><span class="line"><span class="keyword">if</span>(!showImage &amp;&amp; details.type === <span class="string">'image'</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">cancel: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(details.type === <span class="string">'media'</span>)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,&#123;<span class="attr">urls</span>: [<span class="string">"&lt;all_urls&gt;"</span>]&#125;,[<span class="string">"blocking"</span>]);</span><br></pre></td></tr></table></figure></li><li><p>国际化<br>插件根目录新建一个_locales 的文件夹,在新建一些语言文件夹如 en,zh_CN,zh_TW,然后在每个语言文件夹放入一个 messages.json,同时在文件中设置 default_locale.测试时，通过给chrome建立一个不同的快捷方式chrome.exe –lang=en来切换语言</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// en/message.json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"pluginDesc"</span>: &#123;<span class="string">"message"</span>: <span class="string">"A simple chrome extension demo"</span>&#125;,</span><br><span class="line"><span class="string">"helloWorld"</span>: &#123;<span class="string">"message"</span>: <span class="string">"Hello World!"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// zh_CN/message.json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"pluginDesc"</span>: &#123;<span class="string">"message"</span>: <span class="string">"一个简单的Chrome插件demo"</span>&#125;,</span><br><span class="line"><span class="string">"helloWorld"</span>: &#123;<span class="string">"message"</span>: <span class="string">"你好啊，世界！"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 manifest.json 和 css 文件中通过 __MSG_messagename__引入</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"description"</span>: <span class="string">"__MSG_pluginDesc__"</span>,</span><br><span class="line"><span class="comment">// 默认语言</span></span><br><span class="line"><span class="string">"default_locale"</span>: <span class="string">"zh_CN"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// js 中使用</span></span><br><span class="line">chrome.i18n.getMessage(<span class="string">"helloWorld"</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chrome-插件开发指南&quot;&gt;&lt;a href=&quot;#Chrome-插件开发指南&quot; class=&quot;headerlink&quot; title=&quot;Chrome 插件开发指南&quot;&gt;&lt;/a&gt;Chrome 插件开发指南&lt;/h1&gt;&lt;h3 id=&quot;开发与调试&quot;&gt;&lt;a href=&quot;#开发与调
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="chrome 插件" scheme="http://yoursite.com/tags/chrome-%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>solidity 区块链编程入门</title>
    <link href="http://yoursite.com/2020/04/11/solidity%20%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/04/11/solidity 区块链编程入门/</id>
    <published>2020-04-11T11:31:16.000Z</published>
    <updated>2021-08-30T11:32:44.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="solidity-区块链编程入门"><a href="#solidity-区块链编程入门" class="headerlink" title="solidity 区块链编程入门"></a>solidity 区块链编程入门</h1><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>Remix编译器 可以在线使用或离线使用.<br>使用 node 可以安装 solidity 编译器 solcjs<br>mac 可以通过homebrew 安装 编译器 solidity</p><h3 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h3><p><code>pragma solidity ^0.5.2;</code> 表示版本号及编辑器版本<br><code>import * as symbolName from &quot;filename&quot;;</code>导入其他源文件</p><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><ol><li><p>整数类型分为 int/uint 定义. 可以显式设置占用空间大小,默认是 int256/uint256.</p></li><li><p>定长浮点类型: fixed/ufixed 表示各种大小有符号和无符号的定长浮点型.分别是 fixed128x19 和 ufixed128x19 的别名,第一个数字表示占用的位数,必须是 8 的倍数,第二个数字是可用的小数点位.</p></li><li><p>布尔型bool 分为 true 和 false</p></li><li><p>运算符与 javascript 相同,除 === 之外.</p></li><li><p>以太坊地址为 160 位即 20 字节大小.用 address 表示地址类型.地址有两种 address payable 可以接受以太币,而 address 则不行.前者可以隐式转换为普通地址,但普通地址要想转换为 payable 必须通过 payable()函数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">address public owner; <span class="comment">// 定义地址</span></span><br><span class="line">owner.balance; <span class="comment">//查看余额</span></span><br><span class="line">addressA.transfer(<span class="number">1</span> ether)<span class="comment">// 像 A 转 1 eth,地址无效或余额不足会抛出异常.</span></span><br><span class="line">addressA.transfer.gas(<span class="number">120000</span>)(<span class="number">1</span> ether) <span class="comment">// 转账 附带 gas 的写法</span></span><br><span class="line">owner.send(<span class="number">1</span> ether) <span class="comment">// send 是 transfer 的低级版本,有风险,合约失败返回 false,建议使用 transfer</span></span><br></pre></td></tr></table></figure></li><li><p>每一个 contract 合约都有自己的类型,可以显式的转换为 adress 类型,只有当合约具有 receive(接收) 函数或 payable 回退函数时,才能显式和 address payable 类型相互转换.转换仍然使用 address()执行,如果没有接收函数和回退函数需要用 payable(address(x))转换为 address payable.<br> 对于合约可以使用 type(xx) 来获取合约的类型信息. </p></li></ol><ol><li>固定长字节数组,以 bytes 加数字表示,如 bytes2 表示 两个字节长度的数组,数组范围为 1-32.默认是 1.<br> 动态长度字节数组分两种,bytes 和 string(不支持索引访问)</li></ol><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ol><li><p>如果使用引用类型,必须明确数据存储在哪个位置.<br>   变量的储存位置有三种,memory 修饰的变量储存在内存中仅在函数运行期有效不能外部调用, storage 修饰的变量存储在区块链上只有合约存在就有效,calldata 指调用数据,用来保存函数参数,是一个只读位置.<br>   函数返回值默认是 memory,函数局部变量的默认数据是 storage,状态变量的默认数据是 storage.</p></li><li><p>数组截图在声明时指定长度,也可以动态调整.push()添加一个元素,返回对它的引用. 同理还有 pop 函数.<br>   bytes 和 string 也是数组.string 不能使用索引, bytes 等同于 byte[] 但 gas 消耗更低.可以使用 new 关键字创建内存数组,但不能改变其内存数组的大小.<br>   solidity 提供数组切片 x[start:end],仅仅可用于 calldata</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint[][<span class="number">5</span>] x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">6</span>; <span class="comment">// x 为[6,2,3,4,5]</span></span><br><span class="line">x.length = <span class="number">5</span>;</span><br><span class="line">uint[] y = [<span class="number">1</span>,<span class="number">2</span>] <span class="comment">// 动态长度</span></span><br><span class="line">xxxtype[] public xxxx; <span class="comment">// 自定义 xx 类型数组</span></span><br><span class="line">bytes memory b = <span class="keyword">new</span> bytes(<span class="number">9</span>)</span><br><span class="line">uint[<span class="number">3</span>][<span class="number">5</span>] x; <span class="comment">//与大多数编程语言相反,为 5 行 3 列.</span></span><br></pre></td></tr></table></figure><ol><li>结构体是自定义数据类型,可以是字符串整型等基础类型,也可以是数组映射结构体等复杂类型.可以使用关键字 struct 定义.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">struct Bank&#123;</span><br><span class="line">address owner;</span><br><span class="line">uint balance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化方法一</span></span><br><span class="line">Bank b = Bank(&#123;</span><br><span class="line">owner: msg.sender,</span><br><span class="line">balance: <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 方法 2</span></span><br><span class="line">Bank c = Bank(msg.sender, <span class="number">7</span>)</span><br><span class="line"><span class="comment">// 重新赋值</span></span><br><span class="line">c.balance = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> b;<span class="comment">//重置 b 的所有值为 0,除了 mapping 类型.</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>映射/字典 定义方式为 mapping, key 值最好是基础类型.Solidity 没有提供其迭代的方法.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapping(<span class="function"><span class="params">string</span> =&gt;</span> uint) public balances; <span class="comment">// public 会自动创建一个 getter 函数.</span></span><br><span class="line">balances[<span class="string">'charles'</span>] = <span class="number">1</span>;</span><br><span class="line">balances[<span class="string">'ada'</span>]; <span class="comment">// 没有设置 key 的返回 0</span></span><br><span class="line"><span class="keyword">delete</span> balances[<span class="string">"John"</span>]; <span class="comment">// delete 不会删除元素,只会重置其初始值.</span></span><br></pre></td></tr></table></figure><p> delete 用来初始化类型的值,对映射无效.</p></li><li><p>枚举可用来创建一定数量的”常量值”够成的自定义数据类型,可以显式转为整型,但不能隐式转换.一般当做状态机使用.长度不能超过 256 位.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义状态机</span></span><br><span class="line"> enum State &#123;Created, Locked,Inactive&#125;;</span><br><span class="line"> <span class="comment">// 声明 state 变量</span></span><br><span class="line"> State public state;</span><br><span class="line"> <span class="comment">// 赋值</span></span><br><span class="line"> state = State.Created;</span><br><span class="line"> <span class="comment">// 显式转换</span></span><br><span class="line"> uint createdState = uint(State.Created);</span><br></pre></td></tr></table></figure></li><li><p>类型转换和类型推断<br> 隐式转换: int和 int,uint 和 uint 可以相互转换,但 int 和 uint 不能转换,整数类型可以转换为 bytes,但反过来不行,任何可以转换为 uint160 的变量都可以转换为 address 地址类型.<br> 显示转换: uint8(a)<br> 类型推断: var 会在第一次赋值时推断变量类型,不可以用于函数参数,使用时小心,有时候会推断出错误类型.</p></li></ol><h3 id="单位和全局变量"><a href="#单位和全局变量" class="headerlink" title="单位和全局变量"></a>单位和全局变量</h3><ol><li><p>货币单位<br> wei, gwei, ether,默认后缀是 wei. 1ether = 10 的 18 次方 wei.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> ether = <span class="number">10</span> ** <span class="number">18</span> wei;</span><br></pre></td></tr></table></figure></li><li><p>时间单位<br> seconds,minutes,hours,days,weeks 都可作为后缀,默认以 seconds 为单位.(years 因为闰年的原因已去除).<br> 这些单位不能直接用在变量后面,要用变量 乘 1seconds/其他单位 来使用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint a = <span class="number">1</span> * <span class="number">1</span> days; <span class="comment">// 值为 86400 秒</span></span><br></pre></td></tr></table></figure></li><li><p>全局变量<br>solidity 提供的通用函数或变量.</p></li></ol><ul><li>block 区块信息</li><li>msg 消息信息</li><li>tx 交易信息</li><li>abi 编码及解码函数</li><li>错误处理 throw 抛出异常,require检查由输入和外部引起的错误,assert检查内部错误,revert终止运行回撤状态并提供一个解释性字符串</li><li>数学密码学函数 addmod,mulmod,keccak256,sha256,repemd160,ecrecover</li><li>address 地址成员,包含 balance 余额,code 代码,transfer,send,call,delegatecall,staticcall</li><li>合约相关: this 表示当前合约,selfdestruct 销毁合约.</li><li>类型信息: type(x) 检索类型信息.属性包含 name,runtimeCode 等等…</li></ul><h3 id="表达式和控制语句"><a href="#表达式和控制语句" class="headerlink" title="表达式和控制语句"></a>表达式和控制语句</h3><p>Solidity 支持 js 中大部分语句 if,else,while,do,for,break,continue,return, 三元表达式,不支持 switch 和 goto 语句.tryCatch语句只能用于外部函数调用和合约创建调用.<br>Solidity 没有 js 中的非 boolean 类型自动转换的特性.<br>使用循环时注意 gas 的数量,防止合约失败.在合约中优先使用循环而不是递归,EVM 的最大调用栈的深度是 1024.<br>solidity 内部允许使用元祖(tuple)类型.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基于返回的元组来声明变量并赋值</span></span><br><span class="line">    (uint x, bool b, uint y) = f();</span><br><span class="line">    <span class="comment">//交换两个值的通用窍门——但不适用于非值类型的存储 (storage) 变量。</span></span><br><span class="line">    (x, y) = (y, x);</span><br><span class="line">    <span class="comment">//元组的末尾元素可以省略（这也适用于变量声明）。</span></span><br><span class="line">    (index,,) = f(); <span class="comment">// 设置 index 为 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>solidity 作用域规则可以参考 javascript.</p><h3 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h3><pre><code>合约类似于编程语言中的类,可以通过 new 关键字来创建一个新合约,在合约可以调用另一个合约的方法.调用另一个合约时会很自信一个 EVM 函数调用,这会切换执行时的上下文,这样前一个合约的状态变量就不能访问了.</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract infoFeed&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">contract Consumer&#123;</span><br><span class="line">InfoFeed feed; <span class="comment">// 指向一个已经部署的合约;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setFeed</span>(<span class="params">address addr</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 传入部署合约的区块链地址</span></span><br><span class="line">feed = Infofeed(addr) <span class="comment">// 显示进行类型转换,不会调用构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建合约实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNewFeed</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">feed = <span class="keyword">new</span> InfoFeed() <span class="comment">// 调用构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器自动为所有 public 状态的变量创建 getter 函数.外部访问时被认作一个函数.<br>状态变量声明为 constant (常量)或者 immutable （不可变量）<br>合约之外的函数（也称为“自由函数”）始终具有隐式的 internal 可见性。 它们的代码包含在所有调用它们合约中，类似于内部库函数。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code>函数也是一种值类型,可以将函数传递给另外一个函数作为参数,可以再函数中返回一个函数.</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 ,可以由多个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">uint x</span>) <span class="title">returns</span> (<span class="params">uint a, uint b</span>) </span>&#123;</span><br><span class="line">a = x+<span class="number">1</span>;</span><br><span class="line">b = a*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> (a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>函数类型分为两类: 内部 internal 函数类型和外部 external 函数类型.如果函数不需要返回,可以省略 returns xx.一个函数默认是内部函数.函数有四种可见性,public(公开),private(私有,定义的合约内部访问),external(不能再合约内部调用),internal(只能从内部访问).在public函数中，solidity会立刻把函数数组参数拷贝到内存中，而external函数可以直接从calldata中读取数据。内存分配是昂贵的，直接从calldata中读取是便宜的.constructor 是构造函数,在创建合约时执行,并在内部初始化 代码 和状态变量.构造函数运行后将合约最终代码部署到区块链.View 视图函数: 减函数声明为 view 类型,这种情况下要保证不修改状态(包括修改状态,产生事件,创建合约,发送 eth,调用任何没有标记 view 和 pure 的函数,销毁合约等). Constant 之前是 view 的别名,0.5.0 移除.Pure 纯函数: 承诺不读取也不修改状态.访问 address 和 block 等其他信息都属于读取状态.纯函数能适应 revert()和 require()在发生错误是还原状态.一个合约最多有一个接收函数 receive(),声明为`receive() external payable {...}`不需要 function 关键字,也没有参数和返回值,必须用 external 和 payable 修饰.如果它不存在就会调用有 payable 的 fallback 回退函数.如果两个都没有就会在交易时抛出异常.函数修饰符: modifier(修改器) 用于在函数执行前检查某种前置条件是否满足</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyOwner&#123;</span><br><span class="line"><span class="built_in">require</span>(msg.sender == owner); <span class="comment">// 判断调用合约的是不是合约所有者</span></span><br><span class="line">_;<span class="comment">// 下划线表示私有修改符的函数的方法体的替换位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>回退函数 fallback: 每个合约最多只有一个,这个函数无参数也无返回值.一般有两种情况对调用回退函数,一是调用合约时没有匹配到任何函数,二是给合约发送 eth 时,交易中没有附带任何其他数据,也会调用回退函数.新版本不再推荐,推荐使用 receive 函数.</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract Test&#123;</span><br><span class="line">fallback() external payable&#123;</span><br><span class="line"><span class="keyword">throw</span>; <span class="comment">// 执行失败返回 eth 给发送者. payable 修饰符用来接收 eth</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>自毁函数: selfdestruct(address)用来摧毁合约并将 eth 转移到给定地址.当你发现合约有问题不想让其他人使用时就可以摧毁这个合约了.摧毁之后再有人发送eth 到这个地址就会消失.solidity 支持函数重载和函数重写 overriding.父合约标记为 virtual 函数可以再继承合约里重写.重写的函数要用 override 修饰.继承: solidity 合约可以通过 is 关键字实现从父合约中继承.</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">contract B is A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多重继承</span></span><br><span class="line">contract C is A,B&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>接口:接口 interface 是 solidity 在版本 0.4.11 版本后引入的,接口所有函数都是抽象函数, 关键字 abstract定义抽象函数.合约中有的函数没有函数体只有函数定义的是抽象合约.库:库是一中不同类型的合约,没有存储,不拥有 eth.库中的代码可以被其他合约调用而不需要重新部署,这样可以节省大量 gas.库中没有可支付的函数(payable),没有 fallback 回退函数,库的调用通过 DELEGATECALL(委托调用,除此之外好友 call,staticcall都是低级的函数,破坏了 solidity 的类型安全性,谨慎使用) 实现,不切换上下文.Using for:using for 的声明方式是 using lib for a,意为库 lib 中所有函数默认接收 a 实例作为第一个参数.`using Balances for *`引入库 Balances 中的函数被附加在任意的类型上。</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">library C&#123;</span><br><span class="line">funtion a() returns (address)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">contract A&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">returns</span>(<span class="params">address</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> C.a(); <span class="comment">// 返回 A 合约的地址</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><pre><code>真实环境中我们需要发送交易(Transaction)来调用智能合约,我们无法立即获得合约的返回值,此时调用返回值只是该交易的 txid 或 tx hash 值.当事件真正发生时,合约将事件写入区块链时,前端才能进行响应.</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义事件</span></span><br><span class="line">event Sent(address,indexed <span class="keyword">from</span>...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">emit Sent(address,...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// js 调用事件</span></span><br><span class="line"><span class="keyword">var</span> ClientReceipt = web3.eth.contract(xx);</span><br><span class="line"><span class="keyword">var</span> event = ClientReceipt.Sent();</span><br><span class="line">event.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error,result</span>)</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;solidity-区块链编程入门&quot;&gt;&lt;a href=&quot;#solidity-区块链编程入门&quot; class=&quot;headerlink&quot; title=&quot;solidity 区块链编程入门&quot;&gt;&lt;/a&gt;solidity 区块链编程入门&lt;/h1&gt;&lt;h3 id=&quot;编译器&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="solidity ETH" scheme="http://yoursite.com/categories/solidity-ETH/"/>
    
    
      <category term="solidity ETH" scheme="http://yoursite.com/tags/solidity-ETH/"/>
    
  </entry>
  
  <entry>
    <title>认识以太坊</title>
    <link href="http://yoursite.com/2019/09/18/%E8%AE%A4%E8%AF%86%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    <id>http://yoursite.com/2019/09/18/认识以太坊/</id>
    <published>2019-09-18T11:29:39.000Z</published>
    <updated>2021-08-30T11:30:52.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识以太坊"><a href="#认识以太坊" class="headerlink" title="认识以太坊"></a>认识以太坊</h1><ol><li>以太坊不同于比特币,它是一种图灵完备的系统.以太坊能够执行存储在区块链之上的程序的能力，是由被称为EVM的状态机完成的,创建了一个分布式的单体状态世界计算机。</li><li>根据图灵的理论，在真正运行合约之前，以太坊实际上无法预先判断一个合约是否会运行终止，或者它需要运行多久，也许这个合约会陷入死循环一直运行。无论是程序中的瑕疵，还是故意为之，智能合约都可能在一个节点试图验证它的时候永远不停地执行下去，这也就造成了一种DDoS攻击的后果。为了应对这个挑战，以太坊引入了名为gas的计量机制。以太坊的货币是 eth,不同于比特币,eth 的总量没有上限,它的最小单位是 wei,1eth 等于 10 的 18 次方 wei.</li><li>DAPP 去中心化应用,代表更为广泛的智能合约.它需要一个智能合约和web 用户界面,是一个区中心化的 web 应用程序.</li><li>Web3 是一种去中心化的互联网协议.</li><li>选择一款以太坊钱包(推荐MetaMask可以运行在 chrome 中),并保管好你的私钥.在交易时矿工会收取一部分手续费,手续费是由矿工决定的.交易完成后可以通过以太坊区块浏览器 查询到.</li><li>钱包创建的账户是外部账户,用户掌握私钥.而合约账户掌握智能合约代码,没有私钥,它由代码所控制.合约具有地址,可以接收和发送以太币.合约账户无法启动交易,但合约可以互相调用,对交易做出反应.</li><li>以太坊支持多种编程语言,最常用的是Solidity,有以太坊创始人之一Gavin Wood 创立.Solidity 编译器会把代码编译成EVM 字节码然后可以再区块链上的 EVM 中所执行.在次之前需要给合约注册到以太坊链上,需要通过一个特殊的交易，这个交易的目标地址是0x0000000000000000000000000000000000000000,被称为零地址,用来告诉以太坊区块链用户希望通过这样的交易来注册合约.注册成功后合约有了自己的地址.</li><li>有人向合约地址发送交易就会触发合约在 EVM 上的执行,交易的本身就是合约函数的输入参数.合约发起的交易称内部转账或消息.</li><li>请注意,JavaScript的限制，大于10的17次幂 的数值无法处理,我们需要单独处理.</li><li>以太坊协议分别有六种实现,分别是以 rust,pathon,Go,Java,cpp,scala 实现的.开发以太坊并不需要在主网上有运行一个全功能节点,可以再测试网络上的节点完成开发.测试网络节点连接的是一个公共测试区块链.</li><li>以太坊客户端的API是一组远程过程调用（RPC）命令，并采用JSON格式编码。这被称为JSON-RPCAPI。最基本的，JSON-RPCAPI作为一个接口，允许程序员编写代码，把以太坊客户端作为进入以太坊网络和区块数据的大门-网关.RPC接口使用8545端口以HTTP协议的方式对外服务。出于安全的目的，在默认情况下对这个端口的访问是受限的，只允许来自本地网络的链接.RPC 接口提供了很多服务,比如“管理钱包中的私钥和以太坊地址。创建、签名并广播交易。通过交易内数据载荷的方式与智能合约交互。浏览并使用DApp。提供外部服务的链接，例如区块浏览器。转换以太币的单位,向浏览器注入一个 web3 实例.移动钱包都属于远程客户端.</li><li>不要尝试用编程的方式 创建随机数,使用密码学安全的伪随机数生成器（如CSPRNG），并且使用熵源充足的随机源做种子,可以确保它在密码学上是安全的.</li><li>椭圆曲线程序库, openSSL和libsecp256k1(bitcoinCore).</li><li>加密哈希函数是一种单向的哈希函数，可以将任意长度的数据映射为固定长度的比特序列。这种“单向性”意味着，如果我们只知道哈希函数的输出值，还原出输入数据在计算上是不可能的。以太坊使用的哈希算法是Keccak-256(爱德华斯诺登爆出美国国家安全部门在该算法的随机数生成器中留有后门), 可能会更改为FIPS-202 SHA-3. 不同于比特币,以太坊的地址没有校验信息,在交易时注意地址是否正确.EIP55 提案增加了校验,但只有支持 EIP55 的钱包才能使用.</li><li>以太坊的交易信息中有一个 nonce值,它是一个记数器,如果同时发起多笔交易,矿工是以任意顺序接收交易的,交易信息中有 nonce 的比没有 nonce 值的交易优先级要高.如果你按顺序创建了一系列交易，但其中一个没有得到确认，那么之后的所有交易都会“堵”住，等待这个缺失的交易。如果某个 nonce 的值不对或者没有足够的 gas,交易都会被堵住.</li><li>交易信息中还包含 gas 和 gasLimit 这两个信息,gas 不是以太币,但它跟以太币有汇率关系会上下波动.gas 是用来支付给矿工的手续费,高额的 gas 可以让你的交易快速完成.gasLimit 是付款人为了完成交易愿意付出的最大 gas 量.由于每次调用合约,合约的计算量会根据代码决定,为了应对突发状况,你需要多付出一些 gas.以太坊没有找零机制.</li><li>向一个错误的地址 发送交易会导致 eth 被销毁(进入黑洞),因为错误的地址没有私钥,无法完成签名去使用它.</li><li>交易的核心数据是 value 和 data 两个字段,他们都可以为空.接收者为外部账户,不管对方是否存在该金额都会转移到接收地址.如果接收者是合约地址,就会执行 EVM 合约,data为空时执行合约的回退函数.data 有内容时,data字段的内容会被EVM解读为针对合约的函数调用，调用data中指定的函数，并把需要的参数传递给这个函数。</li><li>一但被部署之后,智能合约就不能被更改,更改的唯一方式就是部署一个新的合约实例.但合约实例可以被删除,当把合约地址和内部存储信息清空之后合约就成了一个空地址,系统会提供 gas 退款,用来激励大家释放资源.需要注意，只有合约的开发者在代码中编写了对应的删除功能，SELFDESTRUCT字节码才会起作用。否则无法删除合约实例.</li><li>智能合约为程序员设定了一个很高的门槛：如果有bug，可能会损失大量的金钱。因此，编写智能合约就需要极力避免任何可能的副作用。</li><li>gas的费用由交易的发起方支付，因此我们需要避免调用那些可能引发高额gas的合约或者函数。程序员的最佳策略就是设法避免合约可能产生的 gas 消耗.比如避免对动态数组所执行的循环操作,避免调用未知的合约.</li><li>Vyper是在以太坊虚拟机上执行的、面向合约的实验性编程语言，旨在提供更好的可审计性，并帮助程序员更轻松地完成清晰易懂的代码.OpenZeppelin项目完成了一项伟大的工作，它为以太坊社区构建并审计了很多安全的库合约,可以避免漏洞.</li><li>有很多可重用的代码可以供我们编写自己的合约，包括已经部署到链上的可调用合约以及可以作为代码模板使用的库合约代码.有OpenZeppelin 和 zeppelinOS 等</li><li>ERC20 标准是在以太坊上构建代币的标准.工具型代币是指用来支付某个服务、应用或资源的代币,比如 gas。权益型代币可以被设定为没有投票权的，用来分红和分配利润的代币，也可以承载一个去中心化自治组织的投票权，这类组织的管理由持有代币的所有人共同投票决定.</li><li>ERC 合约必须实现如下函数和事件,总发行量 totalSupply,balanceOf 余额,transfer 转账,transform 转账信息,approve 审核,allowance配额,Transfer 转账事件,Approval 审核事件,name 名称,其他的都是可选函数.symbol 符号等.</li><li>ERC20支持两种转账。第一种是单一式转账，直接使用transfer函数。这个流程被钱包软件用来发送代币给其他地址。大多数的代币转账都是通过transfer函数完成的。第二种方式是使用了approve和transferFrom的两步式交易。这个流程允许代币的持有人授权其他地址操纵他们的代币。这通常用于授权给某一个合约地址，进行代币的分发，但也可以用于交易所的场景。</li><li>以太币是使用带有目标接受人地址的交易进行转账的，而代币的转账是通过代币合约内相关的状态转换进行的，使用合约作为地址，而不是接收方的地址。代币合约跟踪余额并发出事件。在代币的转账过程中，并没有任何针对接收方地址的交易。接收方的地址被加入代币合约的余额映射表中。即使是支持ERC20代币的钱包软件，也不会自动发现对应地址上的代币余额变化，触发用户主动把某个代币合约添加到钱包的关注列表。大多数ERC20代币都像是垃圾邮件一般毫无价值。</li><li>以太币使用send函数发送，任何合约中的可支付函数或者外部账户都可以接收以太币。代币使用transfer或approve&amp;transferFrom函数发送，这些函数只存在于创建这个代币的合约中.并不会触发接收方合约中的任何可支付函数。</li><li>预言机（oracle），它是可以为以太坊智能合约提供外部数据源的系统。为了保持共识，EVM的执行过程必须完全确定，并且仅基于以太坊状态和签名交易的共享上下文。这产生了两个特别重要的后果：一个是EVM和智能合约没有内在的随机性来源；另一个是外部数据只能作为交易的数据载荷引入。我们可以引入外部信息，包括随机性、价格信息、天气预报等，作为发送到网络的交易的数据部分。但是，这些数据本身无法信任，因为它的来源无法核实。我们使用预言机尝试解决这个问题.理想状态下预言机可以无信任的获取外部信息,用于智能合约,还可以把信息安全的中继到 dapp 前端.</li><li>预言机的设计模式: 所有的预言机都提供了一些关键功能。这些能力包括：从链外的数据源收集数据。使用签名消息在链上传输数据。将数据放入智能合约的存储空间，使数据可用。其他智能合约再调用预言机智能合约的检索功能来访问它.预言机的三种主要方式可以分为请求与响应、发布与订阅和立即读取。数据证明:让链外方法可以证明返回数据的完整性是非常关键的。两种常见的数据认证方法是真实性证明以及可信执行环境,上面列举出的所有机制描述的都是中心化的预言机系统，都需要依赖可信的权威。</li><li>去中心化预言机可以用于保证数据可得性，还可搭配链上数据汇总系统创建独立数据提供者网络。比如 chainLink,它分为三部分分别是声誉合约、订单匹配合约、数据汇总合约.</li><li>DAPP 通常是指具有 web 前端的智能合约.Dapp 的后端部署在区块链上,无法篡改.因为在智能合约中执行计算非常昂贵,所以应该让它尽量小.当需要计算量特别大时,一般选做外部计算或使用外部数据源.但前提是你的用户必须信任这些外部源.Dapp 的前端与传统前端并无不同,通过 web3.js 连接以太坊.</li><li>不仅是计算,储存数据也通常储存在链下.可以是中心化的数据存储平台,也可以说去中心化数据存储平台IPFS和以太坊自有平台 Swarm.星际文件系统（IPFS）是一个去中心化的、内容可寻址的存储系统，它可以在P2P网络中分配存储的对象。Swarm是另外一个内容可寻址的、类似于IPFS的P2P存储系统。</li><li>任何应用都会包含的重要组件是进程之间的通信。传统情况下，这可以通过依赖中心化的服务器进行。但是，也有许多基于P2P网络的替代方案。对DApp来说，最值得关注的P2P消息协议是Whisper.</li><li>一些DApp可能设置一个或者多个具有特殊功能的特权账户，如终止DApp合约，覆盖或者更改合约配置，甚至“否决”某些操作。通常，在DApp中引入这些治理功能是为了避免某些未知的问题而引起的bug。在构建一个DApp时，你必须决定是让其完全独立，一旦部署之后就无法被控制，还是创建一个特权账户，承受受到攻击的风险。任何一种选择都会带来风险，但是长远来看，真正的DApp不应该存在能进行特权访问的特权账户，因为这不是去中心化。</li><li>以太坊名称服务:ENS不仅仅是一个智能合约，它本身是一个基础的DApp，提供去中心化的名称服务。是以太坊的域名(DNS服务商 ,域名是.eth,它通过一个拍卖系统被分发，并且没有保留列表或者优先级，获得名称的唯一办法就是使用该系统。ENS的顶层是另一个超级简单的合约，目的只有一个：持有资金。如果所有者不再需要这个名称，他们可以将其卖给系统并拿回他们的以太币(资金只能转给所有者).这种方法大大降低了因为bug引起的攻击而给资金带来的风险。</li><li>以太坊虚拟机 EVM 用来处理智能合约的部署和执行.EVM有一个基于栈的架构，在一个栈中保存了所有内存数值 。EVM的数据处理单位被定义为256位的“字”（这主要是为了方便处理哈希运算和椭圆曲线运算操作），并且它还具有以下数据组件:一个不可变的程序代码存储区ROM，加载了要执行的智能合约字节码。一个内容可变的内存，它被严格地初始化为全0数值。一个永久的存储，它是作为以太坊状态的一部分存在的，也会被初始化为全0.它仅仅是一个计算引擎，仅提供对计算和存储的抽象，就像Java虚拟机（JVM）那样。从高级视角来看，JVM的设计提供了一个无须知晓底层宿主OS或硬件的运行环境，从而提供了跨不同系统平台的兼容性.EVM 的执行顺序由以太坊发起的交易决定,就像是 js 中的单线程.</li><li>EVM既没有任何“系统接口”，也没有“硬件支持”，因为并没有任何物理机器需要与之交互。以太坊世界计算机是完全虚拟化的。EVM 的任务是基于以太坊协议、根据智能合约代码的执行来计算合法的状态转换，用以更新以太坊的状态。</li><li>由于停机问题，以太坊世界计算机就有了一个被程序要求永远执行下去的风险。这可能是由于某些意外情况或者恶意的目的。不过在有了gas之后，也就有了一个解决方案：如果在一个预先指定的最大计算量被用尽的时候计算还没有结束，那么所有处理都会无条件地停止。这个限制并不是固定的，你可以通过支付费用来将它提高到最大值.</li><li>与比特币协议中仅仅以交易数据的字节大小来计算交易费不同，以太坊协议中计算交易费Gas时需要计量由交易和智能合约代码执行所引发的所有计算步骤。比如相加两个数值需要消耗3 gas,发送一个交易需要消耗21000 gas.Gas 是以太币和矿工奖励之间的缓冲,增加攻击者的攻击成本.如果智能合约执行完成,gas 作为交易费给矿工,矿工费= 合约实际消费的gas * gas 的价格(与以太币的汇率)最后得到一笔以太币,交易剩余的 gas 兑换成以太币返还. 交易未成功的话也需要支付交易费,因为矿工为发生错误的操作执行了计算.</li><li>在一个敌意环伺、没有中心化控制者的分布式网络中达成共识的能力是所有开放性公有区块链的核心。比如工作量证明POW是支撑比特币的最重要的发明,奖励只是工具,它的目的是保护比特币系统的安全和去中心化.PoW共识意味着一套风险与收益的细致权衡，驱动着参与者出于自利而遵循共识规则行动。</li><li>POW 提出之前就已经出现了权益证明共识 POS.以太坊也正在由 pow 逐渐向 pos 过渡.PoS算法的运作流程大体如下: 持有以太币的人会有投票权,但是需要质押自己的资产充作保证金,投票的权重和保证金成正比,投票的区块通过则按比例获取奖励,不通过则失去保证金.另外还有一种 DPOS 它是分布式的 POS.</li><li>POW 的币种都要考虑有 ASIC 矿机造成的算力集中,GPU短缺,电力浪费等问题.</li><li>THE DAO 去中心化的自治组织,在ICO众筹自己发行的代币 DAO 时遭到黑客攻击,损失了 360 万 ETH. 以太坊社区针对是否回滚发生争议,硬分叉为 ETC(不回滚) 和 ETH (回滚)两条链.根据社区投票,ETH 为客户端默认选择.</li><li>Truffle框架由若干个Node.js包构成。用来开发以太坊智能合约.相似的框架还有 embark和 OpenZeppelin,zeppelinOS.web3 提供了与以太坊连接的接口.Ganache 提供了一个本地测试区块链用来测试智能合约.</li><li>以太坊共包含流程,从下往上分别是 数据层(区块和区块链),网络层(p2p),共识层(pow/pos),激励层(挖矿和 gas),合约层(EVM 和智能合约),应用层(DAPP,钱包)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识以太坊&quot;&gt;&lt;a href=&quot;#认识以太坊&quot; class=&quot;headerlink&quot; title=&quot;认识以太坊&quot;&gt;&lt;/a&gt;认识以太坊&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;以太坊不同于比特币,它是一种图灵完备的系统.以太坊能够执行存储在区块链之上的程序的能力，是由被称为EVM
      
    
    </summary>
    
      <category term="ETH" scheme="http://yoursite.com/categories/ETH/"/>
    
    
      <category term="ETH" scheme="http://yoursite.com/tags/ETH/"/>
    
  </entry>
  
  <entry>
    <title>认识比特币</title>
    <link href="http://yoursite.com/2019/08/30/%E8%AE%A4%E8%AF%86%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>http://yoursite.com/2019/08/30/认识比特币/</id>
    <published>2019-08-30T11:27:11.000Z</published>
    <updated>2021-08-30T11:29:18.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识比特币-BTC"><a href="#认识比特币-BTC" class="headerlink" title="认识比特币(BTC)"></a>认识比特币(BTC)</h1><ol><li>比特币地址以 1 和 3 开头. 1 开头的地址,比特币只能通过私钥签名和公钥哈希后才能消费,3 开头的是P2SH 地址,代表多重签名.</li><li>钱包是多个地址和对应密钥的集合.</li><li>没有交易过的地址是无效地址,交易过的地址就已经在全网公布了,可以再全账本或区块链浏览器中查到交易记录.交易后该记录是未确认状态,由矿工打包到区块中并链接到链上后变为确认状态.</li><li>在交易时,钱包会从多个地址找到有余额的地址(UTXO 意为未花费的交易输出),然后组合成可消费当前金额的组合(不一定相等,但一定是不少于可消费金额),然后创建一个找零地址,为了让这笔交易快速确认再付一笔矿工费,再发送出去.矿工费可能是设置的找零金额和实际找零金额的差值,所以要确认这个金额是否相差过多.</li><li>ASIC矿机是一个集成可上百个挖矿专用算法硬件且能同时在一个单独芯片上并行工作的专用集成电路.而矿池是多个矿工共享算力和依靠贡献分成的.</li><li>交易发送到区块链网络时,区块链网络上的节点会把这些交易放到未验证的交易池当中.矿工构建新区块时会从交易池中放到新区块中,以矿工费为优先级进行排序,然后计算哈希开始挖矿.矿工一旦从网络上收到新区块时,会立刻放弃当前挖的区块,重新生成新区块.当生成新快成功后,区块奖励的比特币会支付到自己的比特币地址,如果是矿池会根据工作量进行分配.每生成一个区块,对于上一个区块就多了一个证明.按照惯例,6 个确认之后就被认为是不可撤销的.</li><li>比特币核心客户端是一个完整的账本,随着时间发展,账本会越来越大.按照后可以使用 bitcoin-cli 工具,包含了很多工具和功能.比如钱包设置和加密,备份,文本导出和恢复.接收交易等等</li><li>拥有比特币的秘钥就拥有该账户的控制权,秘钥是非对称加密的,公钥向外展示是比特币地址,私钥用来签名不对外公开.可以根据私钥计算出公钥,一般存储时只储存私钥.私钥是一个数字随机选出(256 位的二进制,2 的 256 次幂),然后根据椭圆加密曲线这个单向加密函数产生一个公钥.有了公钥就可以根据哈希函数生成比特币地址.</li><li>素数幂和椭圆曲线算法是不可逆的,很容易向一个方向计算但不能逆向去推算.使得数字签名称为可能.比特币使用椭圆曲线算法作为其公钥加密的基础算法.</li><li>比特币交易时会使用私钥对公钥进行签名,每次签名都不同,网络中的节点可以根据公钥和签名进行验证,确认该笔交易是否拥有比特币的所有权.</li><li>椭圆曲线算法:是一种基于离散对数问题的非对称加密算法,它是单向的函数.比特币使用了一种 secp256k1 标准所定义的一条特殊椭圆曲线和一系列数学常数.以一个随机生成的私钥 k 为起点,将其与曲线上已经定义的生成点 G相乘 获得曲线上的另外一个点 K 即公钥.生成点 G 是 secp256k1 标准的一部分,比特币的生成点都是一样的, K = k*G,公钥和私钥关系是固定的,但只能单向运算,所以暴露公钥并不会威胁到私钥的安全.(椭圆曲线之上的算术运算跟常规的数学运算是不一样的。一个点（G）可以与一个整数（k）相乘来获得另外一个点（K）。但是椭圆曲线的世界里没有除法的概念。因此不可能简单地通过计算公钥K对G点的除法来计算私钥。这就是本章前面提到的单向数学函数。</li><li>哈希加密算法在比特币中广泛运用,包括比特币地址的生成,工作量证明等等.比特币私钥 SHA256 哈希加密算法. 根据公钥进行 sha256 和RIPEMD 160 两次哈希运算的到160bit或20字节的公钥哈希,然后根据 base58check编码获取比特币地址(前缀为 0x00). 因为 256 位二进制过长,交易不便,base58 编码和 base64 不同的是, base58不仅实现了数据压缩和易读性还具有错误诊断功能.它不包含 base64 中的数字0 ,大写 o,小写 l,大写 I 这些容易混淆的字符.base58check增加了错误校验,数据中自带校验码,错误的比特币地址不会被认为有效地址从而造成损失.</li><li>早期比特币钱包只是随机生成的私钥集合,称非确定性(随机)钱包,难以管理备份和导出.这与避免地址重复使用原则相违背(每个地址最好只使用一次,可以增加安全性),后面出现的确定性钱包现在是主流,确定性钱包可以从公共的种子生成大量私钥,创建备份导出时只关注种子就可以了.助记词是英文单词序列用作种子所对应的确定性钱包的随机数私钥.单词的顺序就是钱包的备份.用来恢复钱包.助记词被定义在比特币改进协议 BIP0039 中作为草案而不是标准方案.通过 BIP0039 生成的钱包是 HD(分层确定性)钱包,由种子生成主密钥,再生成子密钥,子密钥又可以生成孙密钥.</li><li>BI0038提出一个通用标准,使用一个口令加密私钥并使用Base58Check对加密的私钥进行编码，这样加密的私钥就可以安全地保存在备份介质里，安全地在钱包间传输，保持密钥在任何可能被暴露情况下的安全性。其本质就是私钥和密码混合形成加密私钥.</li><li>比特币地址以 1 和 3 开头. 1 开头的地址,比特币只能通过私钥签名和公钥哈希后才能消费,3 开头的是P2SH 地址,代表多重签名.多重签名需要从 N 个密钥中需要 M 个私钥签名才可以消费这笔金额.</li><li>比特币开发者针对比特币客户端进行交易的脚本类型设置了一些限制,然后编译为一个叫standard 的函数,该函数定义了五种类型的交易分别是P2PKH、P2PK、MS（限15个密钥）、P2SH(多重签名)和OP_Return”</li><li>并非所有的节点都有能录存储完整的区块链账本,通过简化的支付验证（SPV）的方式可以使它们在不必存储完整区块链的情况下进行工作.SPV 节点只需要下载区块头而不用下载交易信息.一个拥有完整区块链的节点会构造一条验证链，这条链是由沿着区块链按时间倒序一直追溯到创世区块的数千区块及交易组成。而一个SPV节点会验证所有区块的链（但不是所有的交易），并且把区块链和有关交易链接起来.但它不是绝对安全的,如果要保证万无一失的安全性，最可靠的方法还是运行完整区块链的节点。</li><li>在SPV节点里，Bloom 过滤器被用来向对等节点发送交易信息查询请求，同时交易地址不会被暴露。</li><li>比特币网络中几乎每个节点都会维护一份未确认交易的临时列表，被称为内存池或交易池.内存池中的交易如果长时间未处理就会消失,交易人可以重新发起交易或提高矿工费以提高优先级.</li><li>一个区块出现多个子区块的情况被称为“区块链分叉。但这只是暂时的,最长链原则决定了分叉的问题.区块越长,篡改的成本越大,区块链越安全,这也是比特币的一个特征.</li><li>一个区块的大小是 1M,一笔交易最小是250 字节,也就是一个区块最多包含 500 笔交易.一个区块有区块头,交易额记数,交易信息三部分组成.</li><li>挖矿保护了比特币系统的安全，并且实现了在没有中心机构的情况下，也能使整个比特币网络达成共识。铸造新币的奖励和交易费是一种激励机制，它可以调节矿工行为和网络安全，同时又完成了比特币的货币发行.比特币每出 210000 个区块奖励就会减半.2140 年奖励为最小单位,停止奖励,总金额是 2100w 个.区块奖励不同于其他交易,没有付款人,只包含一个 coinbase 的输入,仅仅是用来创建新的比特币,叫创币交易.</li><li>工作量证明的难度单位为 1TH/s 表示每秒可以处理 1 万亿次哈希运算.比特币每 10 分钟出一个区块,但并不是没 10 分钟进行一个难度调整,而是 2016 个块会调整一次难度,会根据 2016 个区块的总共花费的时长与 20160 分钟进行比对,之后再决定该如何调整.</li><li>51%攻击,当一个或者一群拥有了整个系统中大量算力(一些安全模型认为 30%的算力就可发动 共识攻击)的矿工出现之后，他们就可以通过攻击比特币的共识机制来达到破坏比特币网络的安全性和可靠性的目的.共识攻击不能从其他的钱包那里偷到比特币、不签名地支付比特币、重新分配比特币、改变过去的交易或者改变比特币持有纪录。共识攻击能够造成的唯一影响是影响最近的区块（最多10个）并且通过拒绝服务来影响未来区块的生成。这也是惯例 6 个区块确认才算做安全交易的由来.</li><li>莱特币的工作量证明与比特币不同,比特币是基与 SHA256,而莱特币为了避免 ASIC 矿机导致算力过于集中,采用了scrypt 算法,便于 CPU 挖矿.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识比特币-BTC&quot;&gt;&lt;a href=&quot;#认识比特币-BTC&quot; class=&quot;headerlink&quot; title=&quot;认识比特币(BTC)&quot;&gt;&lt;/a&gt;认识比特币(BTC)&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;比特币地址以 1 和 3 开头. 1 开头的地址,比特币只能通过私钥
      
    
    </summary>
    
      <category term="BTC" scheme="http://yoursite.com/categories/BTC/"/>
    
    
      <category term="BTC" scheme="http://yoursite.com/tags/BTC/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用总结</title>
    <link href="http://yoursite.com/2019/07/30/Docker%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/30/Docker使用总结/</id>
    <published>2019-07-30T09:34:47.000Z</published>
    <updated>2021-08-30T09:39:13.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 镜像相关</span></span><br><span class="line">docker images <span class="comment"># 查看镜像</span></span><br><span class="line">docker search xxx <span class="comment"># 搜索互联网镜像</span></span><br><span class="line">docker pull xxxx <span class="comment"># 拉取镜像</span></span><br><span class="line">docker rmi xxxx <span class="comment"># 删除镜像</span></span><br><span class="line"><span class="comment"># 容器相关</span></span><br><span class="line">docker ps <span class="comment"># 查看运行的容器 </span></span><br><span class="line">docker ps -a <span class="comment"># 查看所有容器 </span></span><br><span class="line">docker run <span class="comment"># 运行容器，-i运行容器，-t创建后进入命令行，-d后台运行，-p端口映射，-v目录映挂载，--name命名</span></span><br><span class="line"><span class="comment">#交互式 docker run -it --name=mycentos centos:7 /bin/bash</span></span><br><span class="line"><span class="comment"># 守护式 docker run -di --name=mycentos1 centos:7</span></span><br><span class="line">docker exex -it xxxxx /bin/bash <span class="comment"># 进入容器 </span></span><br><span class="line">docker stop xxx <span class="comment"># 停止容器</span></span><br><span class="line">docker start xxx <span class="comment"># 启动容器</span></span><br><span class="line"><span class="comment"># 文件拷贝</span></span><br><span class="line">docker cp 需要拷贝的目录 容器名：容器目录</span><br><span class="line">docker cp 容器名：容器目录 需要拷贝的目录</span><br><span class="line"><span class="comment"># 通过目录挂载将目录与容器目录进行映射 通过--privileged=true来解决目录权限问题</span></span><br><span class="line">docker run -di -v /xx/YY:/xx/YY --name=mycentos2 cnetos：7</span><br><span class="line"><span class="comment"># 查看容器相关数据 </span></span><br><span class="line">docker inspect xxx</span><br><span class="line"><span class="comment"># 查看容器ip</span></span><br><span class="line">docker inspect --format=<span class="string">'&#123;&#123;.NetworkSrtting.IPAddress&#125;&#125;'</span> xxx</span><br><span class="line"><span class="comment"># 删除指定容器</span></span><br><span class="line">docker rm xxx</span><br></pre></td></tr></table></figure><h4 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql</span></span><br><span class="line">docker pull centos/mysql-xxx</span><br><span class="line">docker run -di --name=testmysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br><span class="line">docker exex -it testmysql /bin/bash</span><br><span class="line">mysql -uroot -pxxx</span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx</span></span><br><span class="line">docker pull nginx</span><br><span class="line">docker run --name nginx-test -p 8080:80 -d nginx</span><br><span class="line">docker <span class="built_in">exec</span> -it nginx-test /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#tomcat</span></span><br><span class="line">docker pull tomcat</span><br><span class="line">docker run --name myTomcat -p 8080:8080 -v <span class="variable">$PWD</span>/xxx:/usr/<span class="built_in">local</span>/tomcat/webapps/ -d tomcat <span class="comment">#目录映射</span></span><br><span class="line">docker <span class="built_in">exec</span> -it myTomcat /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># mongo</span></span><br><span class="line">docker pull mongo</span><br><span class="line">docker run -itd --name myMongo -p 27017:27017 mongo --auth</span><br><span class="line">docker <span class="built_in">exec</span> -it myMongo mongo admin</span><br><span class="line"><span class="comment"># 创建一个名为 admin，密码为 admin 的用户。</span></span><br><span class="line">&gt; db.createUser(&#123; user:<span class="string">'admin'</span>,<span class="built_in">pwd</span>:<span class="string">'admin'</span>,roles:[ &#123; role:<span class="string">'userAdminAnyDatabase'</span>, db: <span class="string">'admin'</span>&#125;]&#125;)</span><br><span class="line"><span class="comment"># 尝试使用上面创建的用户信息进行连接。</span></span><br><span class="line">&gt; db.auth(<span class="string">'admin'</span>, <span class="string">'admin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># RabbitMQ</span></span><br><span class="line">docker search rabbitmq</span><br><span class="line">docker pull rabbitmq:3.8.3-management</span><br><span class="line">docker run -di --name myRabbitmq -p 5671:5617 -p 5672:5672 -p 4369:4369 -p 15671:15671 -p 15672:15672 -p 25672:25672 rabbitmq:management</span><br><span class="line"><span class="comment"># 访问 http://127.0.0.1:15672/</span></span><br></pre></td></tr></table></figure><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#容器保存为镜像</span></span><br><span class="line">docker commit 容器名称xxxx 镜像名称YYY</span><br><span class="line"><span class="comment"># 镜像备份</span></span><br><span class="line">docker save -o xxx.tar 镜像名称YYY</span><br><span class="line"><span class="comment"># 镜像恢复与迁徙</span></span><br><span class="line">docker load -i xxx.tar</span><br></pre></td></tr></table></figure><h4 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h4><p>dockerfile是有一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p><p>dockerFile常用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM image_name:tag 定义使用的基础镜像</span><br><span class="line">MAINTAINER user_name 什么镜像创建者</span><br><span class="line">ENV key calue 设置环境变量</span><br><span class="line">RUN <span class="built_in">command</span> 命令执行</span><br><span class="line">ADD 原目录/文件 目标目录/文件 将文件移动到容器</span><br><span class="line">COPY 原目录/文件 目标目录/文件 将文件复制到容器</span><br><span class="line">WORKDIR 目录 设置工作目录</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h3&gt;&lt;h4 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常
      
    
    </summary>
    
      <category term="后端 docker" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF-docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>vim入门指南</title>
    <link href="http://yoursite.com/2019/05/09/vim%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2019/05/09/vim入门指南/</id>
    <published>2019-05-09T11:24:13.000Z</published>
    <updated>2021-08-30T11:40:09.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim入门指南"><a href="#vim入门指南" class="headerlink" title="vim入门指南"></a>vim入门指南</h1><h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><pre><code>- di&quot; 删除本行&quot;&quot;内的文本- cw 替换一个词- yaw 复制当前词- f和 t来查找当前行字符,`;`重复查找,`*`查找当前词,n 跳往下一个.- ctrl + d/u 向下/上 滚动半屏- 分隔符 a/i 带空格/不带空格 ,例如 a(/i( ,一般 d 和 a 配合,c 和 i 配合, w/词 -&gt; s/句子-&gt;p/段落.- u 撤销修改,U 撤销所有修改(undo), 撤销最后一次修改 ctrl + R- i/I,a/A,o/O 插入- mm 命令可以标记一个位置,然后~m回到标记点- 全局替换`:%s/{pattern}/{string}/{flags}`- 宏: q a-z 命名, 操作 q 离开完成.调用 @ a-z 具体的宏.</code></pre><h4 id="字符跳动"><a href="#字符跳动" class="headerlink" title="字符跳动"></a>字符跳动</h4><ul><li>h,j,k,l 左下上右</li></ul><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>所有命令都需要在normal模式下使用</p><ul><li>i切换到insert模式，按esc回到normal模式</li><li>v 可视化模式,按v或V进入可视模式<br>v可以进入面向字符的可视模式,V 是针对行的可视模式.ctrl +v可以进入针对列的可视模式.可视模式下按 o 可以调整选择区边界.</li><li>:wqa! w为保存，q为离开，！为强制执行 ,a表示all所有</li></ul><h4 id="行内移动"><a href="#行内移动" class="headerlink" title="行内移动"></a>行内移动</h4><ul><li>0 到行头</li><li>^ 第一个不是空的位置</li><li>$ 行尾</li><li><p>g_ 最后一个不是空的位置</p></li><li><p>w 下一个单词开头</p></li><li>b 当前或上一个单词开头</li><li><p>wi/bi 在开头前插入</p></li><li><p>e 当前或下一个单词结尾 (end)</p></li><li>ge 上一个单词结尾</li><li><p>ea,gea 在结尾后插入</p></li><li><p>fa 下一个字符为a的位置</p></li><li>ta 字符a前的第一个字符</li></ul><h4 id="页移动"><a href="#页移动" class="headerlink" title="页移动"></a>页移动</h4><ul><li>H 跳转到当前屏幕第一行 (head)</li><li>M 当前屏幕中间一行  (middle)</li><li><p>L 最后一行        (last)</p></li><li><p>2H 移动到当前屏幕第2行</p></li><li>3L 移动到当前屏幕倒数第三行</li><li>ctrl + f  前移一页  (forward)</li><li>ctrl + b 后移一页   (back)</li><li>ctrl + d 往下滚动半屏  (down)</li><li><p>ctrl + u 往上滚动半屏  </p></li><li><p>gg 调到首行  相当于:1</p></li><li>G 调到尾行</li><li>nG 调到n行  相当于:n</li><li>% 调到另一边括号 ({[]})</li></ul><h4 id="配合查找字符方式移动"><a href="#配合查找字符方式移动" class="headerlink" title="配合查找字符方式移动"></a>配合查找字符方式移动</h4><ul><li>fa 正向移动到第一个字符a处, ta 正向移动到下一个a字符之前</li><li>Fa 逆向移动到第一个字符a处, Ta 逆向移动到下一个a字符之前</li><li><code>;</code>可以重复查找上次 f 命令查找的字符,不用再重复使用 f 命令.如果按了太多次,可以按<code>,</code>回到上次位置.</li><li><code>*</code>命令可以查找光标当前所在词,按 n 跳往下一个.</li><li>f/t 只能在行内查找且查找时只能查找一个字符,而不是单词.查找时尽量选择频率比较低的字符从而快速移动到目标处.</li></ul><h4 id="非相邻单词或字符间移动"><a href="#非相邻单词或字符间移动" class="headerlink" title="非相邻单词或字符间移动"></a>非相邻单词或字符间移动</h4><ul><li>8w 正向移动到相隔8个单词的首字符</li><li>4Fa 逆向移动到第4个a字符</li></ul><h4 id="搜索匹配"><a href="#搜索匹配" class="headerlink" title="搜索匹配"></a>搜索匹配</h4><ul><li>/text 向后搜索 </li><li>? text 向前搜索</li><li>:g/word 全局搜索</li><li>n 搜索下一个同样的内容</li><li><p>N 搜索上一个同样的内容</p></li><li><p>查找 :{作用范围}s/{目标}/{替换}/{替换标志}</p></li><li><p>:%s/old/new/gc 全局替换</p></li><li><p>作用范围 当前行:s,全文:%s,选区在visual 选择区域后输入:后 vim 自动补全:’&lt;,&gt;’s 或手动指定:4,6s  或.,+2s 接下来 2 行</p></li><li><p>替换标志 </p><ul><li>i 表示大小写不敏感,I 表示敏感,等于与模式中的\c<br>  :%s/foo/bar/i  === :%s/foo\c/bar</li><li>g 全局替换</li><li>c 表示需要确认,每次替换系统按键确认 y 替换/n 不替换/a 替换所有/q 退出查找模式/ l 替换当前位置并退出</li></ul></li><li><p>在normal模式下按下*即可查找光标所在单词（word）</p></li><li>\c表示大小写不敏感查找，\C表示大小写敏感查找</li><li><em># 匹配当前光标所在的单词 </em>是下一个 #是上一个</li><li>光标移动可以与其他命令联动，比如 0y$ 表示从行首拷贝到最后一个字符</li><li>拷贝不一定要用y，还可以使用d(删除)，v（可视化选择），gU(变大写),gu(变小写)</li></ul><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul><li>i在光标前插入(insert),I 在当前行开头插入</li><li>a在光标后插入(append),A在当前行结尾进行插入,相当于执行了<code>$a</code>操作</li><li>o在当前行后插入新行, O在当前行前插入新行</li><li>ea  在当前行结尾插入(end append)</li><li>cw 当前光标到单词结尾清空并插入</li><li>在插入模式删除除了使用退格键,还可以使用 ctrl+w 删除前一个单词或使用 ctrl + u 删除至行首.</li></ul><h4 id="替换和删除"><a href="#替换和删除" class="headerlink" title="替换和删除"></a>替换和删除</h4><ul><li>r 替换一个字符 replace,R 可以替换多个字母.</li><li>cc 替换一行</li><li>cw 替换一个 word</li><li>c$ 替换到行尾</li><li>s 修改一个字符</li><li><p>S 修改一整行</p></li><li><p>x 删除当前光标所在的一个字符</p></li><li>dl 删除当前字符  === x</li><li>dw 删除到下一个单词开头</li><li>d0 删除至行首</li><li>dd 删除当前行</li><li>dj 删除上一行</li><li>dk 删除下一行</li><li>gg dG 删除全部内容</li><li>:1,10d 删除1-10行</li><li>:11,$d 删除11行及以后所有行<br>删除的内容存到剪贴板.</li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>d,c,y等操作符加 一个动作命令组成一次操作.例如 daw.<br>    操作符有</p><pre><code>- c 修改 (change)- d 删除 (delete)- y 复制, (yank)- p 粘贴 (paste/put)- g~ 反转大小写- gu 转换为小写- gU 转换为大写-  `&gt;` 增加缩进-  `&lt;` 减少缩进- `=` 自动缩进</code></pre><h4 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h4><ul><li>yy 拷贝当前行(yank)</li><li>按v或V进入可视模式,然后上下左右选择,再按y即可复制,按d即可剪贴</li><li>p 粘贴到下一行或右侧</li><li>P 粘贴至上一行或左侧</li><li>调换文本行可以使用 ddp(先删除当前行再粘贴),同理复制当前行 yyp</li><li>交换两个词. 先用 d 删除一个词,然后 mm 标记,在用 v 选中另一个词按 p替换,然后 ~m 回到标记位置再按 p 即可完成替换.</li><li>针对字符的复制或删除操作如 x,diw等将创建面向字符的寄存器,粘贴时会放在光标后.针对行的复制删除操作如 dd,yy 或 dap 会创建针对行的寄存器,粘贴时会放在当前行的下一行.</li></ul><h4 id="撤销和重复"><a href="#撤销和重复" class="headerlink" title="撤销和重复"></a>撤销和重复</h4><ul><li>u撤销最近一次修改(undo)</li><li>.命令可以再普通模式下重复上次修改,如果想要在命令模式下重复上次命令可以用<code>@:</code></li><li>U撤销所有</li><li>ctrl + r 取消最后一次的撤销</li></ul><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><ul><li>:e<path to="" file=""></path> 打开一个文件</li><li>:saveas<path to="" file=""></path> 文件另存为</li><li>:x 或 zz 或:wq 保存并推出</li><li>:bn 切换到下一个文件（n表示next，b表示切换blocked-out）</li><li>:bp 切换到上一个文件（p表示prev）</li><li>:n 切换到下一个</li></ul><h4 id="命令行模式技巧"><a href="#命令行模式技巧" class="headerlink" title="命令行模式技巧"></a>命令行模式技巧</h4><ul><li>DTc 删除光标的c之间的所有字符</li><li>Rc 将光标的字符替换为c</li><li>nDD 删除n行数据</li><li>nYY 复制n行数据</li><li>nX 删除n个字符</li></ul><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>按:进入命令模式.</p><ul><li>:n 光标移动到多少行</li><li>:1,5w file 将第一行至第五行写入文件</li><li>:.,$w file 当前行至结束写入文件</li><li>:w 保存</li><li>:wq 保存退出</li><li>:q 退出</li><li>:q! 强制退出</li><li>:/str/ 正向搜索,光标移动到下一个结果</li><li>:?str? 逆向搜索</li><li>正则:</li><li>:/^xxx/</li><li>:/xxx$/</li><li>:s实现替换</li><li>delete 删除</li><li>yank 复制</li><li>put 粘贴</li><li>copy 拷贝</li><li>move 移动</li><li>join 连接</li><li>normal 可以执行普通模式下的命令</li><li>substitute/{pattern}/{string}/{flags} 在范围内出现{pattern}的地方替换为{string}</li><li>x,y 表示 x-y 行,<code>.</code>表示当前行,<code>%</code>表示当前文件所有行</li><li>使用<code>:t</code>和<code>:m</code>命令复制和移动行.其中<code>:t</code>是 copy 命令的简写(可以理解为copyTo),<code>:m</code>是 move 命令的简写</li></ul><h3 id="vim-实用技巧"><a href="#vim-实用技巧" class="headerlink" title="vim 实用技巧"></a>vim 实用技巧</h3><ul><li><p>分隔符文本对象.<br>  vim 的文本对象由两个字符组成,第一个字符是 i/a, i 会选择分隔符内部文本,a 会选择包括分隔符在内的整个文本.可以理解为 inside/all. 第二个字符是分隔符如<code>)]}&gt;&#39;&quot;</code>,t 表示标签</p><ul><li>a)/i)</li><li>a”/i”</li><li>at/it<br>文本对象前可使用 <code>d/c/y/g~/gu/gU/&gt;/&lt;/=</code> 等操作符</li></ul></li><li><p>范围文本对象</p><ul><li>aw 当前单词及一个空格/iw 当前单词</li><li>as 当前句子及一个空格/is 当前句子</li><li>ap 当前段落及一个空行/ ip 当前段落<br>一般 d 和 a 配合, c 和 i 配合.</li></ul></li><li><p>标记位置<br>  mm 命令可以标记一个位置,然后~m回到标记点 可以回到上次修改位置.<br>  比如我们想要修改一对大括号,可以先用%匹配大括号,这时 vim 会自动为发生跳转的地方设置一个标记,在我们使用 r]修改后大括号后,按 ~~ 调回到前大括号,然后 r[ 修改完成.</p></li><li><p>自定义宏</p><ul><li>创建宏 q a,操作,q 结束. 其中 a 为命名的寄存器.</li><li>查看宏 :reg a</li><li>调用宏 @a, @@可以回放上次调用的宏.</li><li>当前行多次调用宏. 3@a ,调用三次宏 a</li><li>多行调用宏, 按 v 进入可视模式,选中执行区间,<code>:normal @a</code>就可以在每一行执行宏了.</li></ul></li><li><p>用迭代求值的方式给列表编号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">let</span> i = 1  <span class="comment">#定义变量</span></span><br><span class="line">qa  <span class="comment"># 定义宏和寄存器</span></span><br><span class="line">I ctrl+r =1 ctrl+R ) esc <span class="comment"># 对行进行操作</span></span><br><span class="line">:<span class="built_in">let</span> i += 1 <span class="comment"># 变量递增</span></span><br><span class="line">q <span class="comment"># 完成录制</span></span><br></pre></td></tr></table></figure></li><li><p>搜索引擎<br><code>\v</code>表示模式开关,可以让搜索时不用正则写过多的转义字符,比如要匹配 css 中的颜色可以使用<code>/\v #[0-9a-fA-F]{6}|[0-9a-fA-F]{3}</code><br><code>\V</code>表示原义开关,按照字符进行匹配,即便字符中有像.这样的符号也会按照原义查找.</p></li><li><p>substitude命令<br>该命令可以提供查找模式以及替换字符串,还可以指定执行的范围.具体语法<code>:s/{pattern}/{string}/{flags}</code> 在范围内出现{pattern}的地方替换为{string},如果想要全局配置要使用<code>:%s/xxx/xxx/g</code><br>flags 为标志位,其中 g 是全局范围,n 为统计个数而不执行替换,c 让我们确认每一次修改.e 可以屏蔽错误提示.i 表示大小写不敏感,I 表示大小写敏感.</p></li></ul><h4 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h4><ul><li>:vsp 左右分屏</li><li>:sp 上下分屏</li><li>:tabnew 新建标</li></ul><h3 id="z和fzf脚本"><a href="#z和fzf脚本" class="headerlink" title="z和fzf脚本"></a>z和fzf脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">j</span></span>() &#123;</span><br><span class="line">     <span class="keyword">if</span> [[ -z <span class="string">"$*"</span> ]]; <span class="keyword">then</span></span><br><span class="line">         <span class="built_in">cd</span> <span class="string">"<span class="variable">$(_z -l 2&gt;&amp;1 | fzf +s | sed 's/^[0-9,.]* *//')</span>"</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         _last_z_args=<span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">         _z <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">     <span class="keyword">fi</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">jj</span></span>() &#123;</span><br><span class="line">     <span class="built_in">cd</span> <span class="string">"<span class="variable">$(_z -l 2&gt;&amp;1 | sed 's/^[0-9,.]* *//' | fzf -q $_last_z_args)</span>"</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vim入门指南&quot;&gt;&lt;a href=&quot;#vim入门指南&quot; class=&quot;headerlink&quot; title=&quot;vim入门指南&quot;&gt;&lt;/a&gt;vim入门指南&lt;/h1&gt;&lt;h3 id=&quot;快捷操作&quot;&gt;&lt;a href=&quot;#快捷操作&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="VIM" scheme="http://yoursite.com/categories/VIM/"/>
    
    
      <category term="VIM" scheme="http://yoursite.com/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>入门shell编程</title>
    <link href="http://yoursite.com/2019/01/11/%E5%85%A5%E9%97%A8shell%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/01/11/入门shell编程/</id>
    <published>2019-01-11T11:20:45.000Z</published>
    <updated>2021-08-30T11:21:42.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门shell编程"><a href="#入门shell编程" class="headerlink" title="入门shell编程"></a>入门shell编程</h1><h3 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">mkdir code</span><br><span class="line"><span class="built_in">cd</span>  code</span><br><span class="line"><span class="keyword">for</span> ((i=0; i&lt;3; i++)); <span class="keyword">do</span></span><br><span class="line">    touch test_<span class="variable">$&#123;i&#125;</span>.txt</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"shell很简单"</span> &gt;&gt; test_<span class="variable">$&#123;i&#125;</span>.txt</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>让我们看一下以上代码都做了什么:</p><ol><li>从系统path中寻找指定脚本的解释程序 </li><li>创建 名叫code文件夹 </li><li>进入创建的文件夹 </li><li>for循环3次 </li><li>创建文件 </li><li>往创建的文件中写入信息 </li><li>结束循环</li></ol><p>mkdir, touch，cd，touch，echo都是系统命令，在命令行下可以直接执行 for, do, done 是shell脚本语言 for循环的语法.</p><h3 id="编写shell"><a href="#编写shell" class="headerlink" title="编写shell"></a>编写shell</h3><p>新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php，扩展名为php，如果你用Python，扩展名为python.</p><p>第一行一般是这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/php</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment">#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行 /env 是系统的PATH目录中查找</span></span><br></pre></td></tr></table></figure><h4 id="运行shell脚本有两种方式"><a href="#运行shell脚本有两种方式" class="headerlink" title="运行shell脚本有两种方式"></a>运行shell脚本有两种方式</h4><ol><li><p>作为可执行程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x op_base.sh  //设置op_base.sh可执行权限</span><br><span class="line">./op_base.sh  //执行op_base.sh文件</span><br></pre></td></tr></table></figure></li><li><p>作为参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh op_base.sh</span><br></pre></td></tr></table></figure></li></ol><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>定义变量时，变量名前不需要加符号和Python一样,但是在PHP语言中变量需要加$.如<code>my_name=&quot;jack&quot;</code></p><p>变量名和=之间不能有空格且变量后不能有<code>;</code>号.</p><h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>对于已经定义过的变量,使用的时候在前面添加<code>$</code>,如<code>echo $my_name</code>,或<code>echo ${my_name}</code> .花括号是可选的,但建议加上.因为花括号是为了帮助解释器识别变量的边界.</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>单行注释使用<code>#</code>,解释器会忽略该行</p><p>sh 里没有多行注释,只能每一行加一个#号.</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>shell 不像其他语言如 php,python 有很多数据类型,在 shell 中常用的数据类型即字符串和数字.</p><p>shell中的引号和 php 类似,可以用单引号或双引号,双引号中可以有变量,可以出现转义字符,但单引号中的变量是无效的.python 中引号没有区别,且存在三个引号.三个引号不会被转义.</p><h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><ul><li><p>拼接字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">"hello"</span></span><br><span class="line">b=<span class="string">"world"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span> <span class="variable">$b</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>获取字符串长度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#a&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>截取字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a:0:2&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="shell-数组"><a href="#shell-数组" class="headerlink" title="shell 数组"></a>shell 数组</h3><h4 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h4><p>在 shell 中用括号表示数组,数组元素用<strong>空格</strong>分隔开.如<code>name=(name1 name2 name3)</code>还可以单独定义数组的各个分量如<code>arr[0]=name1</code></p><h4 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h4><p>读取数组的一般格式是<code>${数组[下标]}</code>,比如<code>echo ${name[0]}</code>,使用<code>@</code>符号可以获取数组中所有元素.例如<code>echo $name[@]</code></p><h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><p>获取数组长度与字符串类似,例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取数组元素个数</span></span><br><span class="line">length=<span class="variable">$&#123;#name[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> length</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">length=<span class="variable">$&#123;#name[*]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> length</span><br><span class="line"><span class="comment"># 取得数组单个元素的长度</span></span><br><span class="line">length=<span class="variable">$&#123;#name[n]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> length</span><br></pre></td></tr></table></figure><h3 id="shell-传递参数"><a href="#shell-传递参数" class="headerlink" title="shell 传递参数"></a>shell 传递参数</h3><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./test.sh 1 2 3</span><br><span class="line"><span class="variable">$0</span> <span class="comment"># ./test.sh</span></span><br><span class="line"><span class="variable">$1</span> <span class="comment"># 1 ...</span></span><br></pre></td></tr></table></figure></p><h3 id="shell-运算符"><a href="#shell-运算符" class="headerlink" title="shell 运算符"></a>shell 运算符</h3><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 算术运算符</span></span><br><span class="line"><span class="comment"># + - \* / % = == !=</span></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"两数之和为 : <span class="variable">$val</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#关系运算符</span></span><br><span class="line"><span class="comment"># -eq 相等 , -ne 不相等, -gt 大于, -lt 小于, -ge 大于等于, -le 小于等于</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -eq <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> -eq <span class="variable">$b</span> : a 等于 b"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 布尔运算</span></span><br><span class="line"><span class="comment"># ! 非. -o 或, -a与</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -lt 100 -a <span class="variable">$b</span> -gt 15 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span> 小于 100 且 <span class="variable">$b</span> 大于 15 : 返回 true"</span></span><br><span class="line"><span class="comment"># 逻辑运算</span></span><br><span class="line"><span class="comment"># &amp;&amp; ||</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串运算</span></span><br><span class="line"><span class="comment"># =, !=, -z 长度是否为 0, -n 长度是否不为 0, $ 是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件测试运算符</span></span><br><span class="line"><span class="comment"># -e 是否存在</span></span><br><span class="line"><span class="comment"># -d 是否存在且为目录</span></span><br><span class="line"><span class="comment"># -f 是否存在且为常规文件</span></span><br><span class="line"><span class="comment"># -r 是否存在且可读</span></span><br><span class="line"><span class="comment"># -w 是否存在且可写</span></span><br><span class="line"><span class="comment"># -x 是否存在且可执行</span></span><br><span class="line"><span class="comment"># -s 文件大小是否大于 0</span></span><br></pre></td></tr></table></figure><h3 id="test-命令-和"><a href="#test-命令-和" class="headerlink" title="test 命令 和 [[]]"></a>test 命令 和 [[]]</h3><p>test命令用来测试某条件是否成立,可以用[]代替, 但[]内部不能使用||和&amp;&amp;以及!,[[]]支持这种写法,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> tel</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$tel</span> =~ ^1[0-9]&#123;10&#125;$ ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"你输入的是手机号码"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"你输入的不是手机号码"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><h3 id="echo-和-printf"><a href="#echo-和-printf" class="headerlink" title="echo 和 printf"></a>echo 和 printf</h3><p>echo 和 printf是用于字符串的输出.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>"</span> &gt; xx.txt</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4s\n"</span> 姓名 性别 体重kg</span><br></pre></td></tr></table></figure></p><h3 id="shell-流程控制"><a href="#shell-流程控制" class="headerlink" title="shell 流程控制"></a>shell 流程控制</h3><p><strong>和其他编程语言流程控制不同,sh的流程控制不能为空</strong> </p><p>如 js 流程控制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> a&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a 为 true"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//什么也不做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 sh/bash 里不能这么写,如果 else 分支没有执行语句就不要写 else. 如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line"><span class="keyword">if</span> [<span class="variable">$a</span> == <span class="variable">$b</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'a 等于 b'</span></span><br><span class="line"><span class="keyword">elif</span> [<span class="variable">$a</span> -gt <span class="variable">$b</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'a 大于 b'</span></span><br><span class="line"><span class="keyword">elif</span> [<span class="variable">$a</span> -lt <span class="variable">$b</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'a 小于 b'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"没有符合的条件"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>shell 的 for 循环和 python 类似.</p><p>python 的 for 循环:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><p>shell 的 for 循环写法一:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for item in 1 2 3 4 5;</span><br><span class="line">do</span><br><span class="line">echo 'i='$i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>shell 的 for 循环写法二:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ((i=0;i&lt;5;i++)); </span><br><span class="line">do</span><br><span class="line">echo "i="$i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><p>while 循环用于不断执行一系列命令,也用于从输入文件中读取数据,命令通常为测试条件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int=1</span><br><span class="line"><span class="keyword">while</span> ((<span class="variable">$int</span>&lt;=5))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line"><span class="built_in">let</span> <span class="string">"int++"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数</p><h3 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo "这个函数会对输入的两个数字进行相加运算..."</span><br><span class="line">    echo "输入第一个数字: "</span><br><span class="line">    read aNum</span><br><span class="line">    echo "输入第二个数字: "</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo "两个数字分别为 $aNum 和 $anotherNum !"</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-输入重定向"><a href="#输出-输入重定向" class="headerlink" title="输出/输入重定向"></a>输出/输入重定向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &gt; 输出重定向到 file</span></span><br><span class="line"><span class="comment"># &lt; 输人重定向到 file</span></span><br><span class="line"><span class="comment"># &gt;&gt; 追加</span></span><br><span class="line"><span class="comment"># n&gt;&amp;m n 和m 合并到 m</span></span><br></pre></td></tr></table></figure><h3 id="shell-结合系统命令"><a href="#shell-结合系统命令" class="headerlink" title="shell 结合系统命令"></a>shell 结合系统命令</h3><p>shell脚本结合系统命令会更加强大,在字符串处理领域,有 grep,awk,sed 三剑客, grep 负责找出特定的行, awk 能将行拆分成多个字段, sed 则可以实现更新插入删除等写操作.例如定时检测 nginx,mysql 是否被关闭.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">path=/var/<span class="built_in">log</span></span><br><span class="line"><span class="built_in">log</span>=<span class="variable">$&#123;path&#125;</span>/httpd-mysql.log</span><br><span class="line"></span><br><span class="line">name=(apache mysql)</span><br><span class="line"></span><br><span class="line">exs_init[0]=<span class="string">"service httpd start"</span></span><br><span class="line">exs_init[1]=<span class="string">"/etc/init.d/mysqld restart"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=0; i&lt;2; i++)); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"检查<span class="variable">$&#123;name[i]&#125;</span>进程是否存在"</span></span><br><span class="line">    ps -ef|grep <span class="variable">$&#123;name[i]&#125;</span> |grep -v grep</span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        pid=$(pgrep -f <span class="variable">$&#123;name[i]&#125;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"`date +"</span>%Y-%m-%d %H:%M:%S<span class="string">"` <span class="variable">$&#123;name[$i]&#125;</span> is running with pid <span class="variable">$pid</span>"</span> &gt;&gt; <span class="variable">$&#123;log&#125;</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        $(<span class="variable">$&#123;exs_init[i]&#125;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"`date +"</span>%Y-%m-%d %H:%M:%S<span class="string">"` <span class="variable">$&#123;name[$i]&#125;</span> start success"</span> &gt;&gt; <span class="variable">$&#123;log&#125;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#检测 nginx、mysql进程是否存在，如果不存在了会自动重新启动。 脚本每次运行会写日志的，没事可以去看看该日志文件，如果进程是不是真的经常性不存在，恐怕就要排查一下深层原因了。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;入门shell编程&quot;&gt;&lt;a href=&quot;#入门shell编程&quot; class=&quot;headerlink&quot; title=&quot;入门shell编程&quot;&gt;&lt;/a&gt;入门shell编程&lt;/h1&gt;&lt;h3 id=&quot;第一个shell脚本&quot;&gt;&lt;a href=&quot;#第一个shell脚本&quot; cla
      
    
    </summary>
    
      <category term="Shell" scheme="http://yoursite.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>关于 JavaScript 隐式转换的一道题</title>
    <link href="http://yoursite.com/2018/07/14/%E5%85%B3%E4%BA%8E%20JavaScript%20%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98/"/>
    <id>http://yoursite.com/2018/07/14/关于 JavaScript 隐式转换的一道题/</id>
    <published>2018-07-14T11:16:05.000Z</published>
    <updated>2021-08-30T11:20:16.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-JavaScript-隐式转换的一道题"><a href="#关于-JavaScript-隐式转换的一道题" class="headerlink" title="关于 JavaScript 隐式转换的一道题"></a>关于 JavaScript 隐式转换的一道题</h1><h3 id="让我们先看一道面试题"><a href="#让我们先看一道面试题" class="headerlink" title="让我们先看一道面试题"></a>让我们先看一道面试题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当 a==1 &amp;&amp; a==2 &amp;&amp; a==3 为 true 时,a = ?</span><br><span class="line">简要分析 a 多次 == 一个不同的值成立,由此可以推断 a 是一个引用类型的值</span><br><span class="line">且比较时用到 == 而不是 === ,可以判断这道题考察的是 js 的隐式转换问题</span><br></pre></td></tr></table></figure><h3 id="其他值转换为字符串"><a href="#其他值转换为字符串" class="headerlink" title="其他值转换为字符串"></a>其他值转换为字符串</h3><ul><li>当值是原始类型时,直接转换为字符串类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> =&gt; <span class="string">'null'</span></span><br><span class="line"><span class="literal">undefined</span> =&gt; <span class="string">'undefined'</span></span><br><span class="line"><span class="literal">true</span> =&gt; <span class="string">'true'</span></span><br><span class="line"><span class="number">1</span> =&gt; <span class="string">'1'</span></span><br></pre></td></tr></table></figure><ul><li>当值是引用类型时,先转换为原始类型,再转换为字符串.String方法背后的转换规则与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// 1,2,3 因为[1,2,3].toString() 是'1,2,3',再调用 valueOf 是'1,2,3'</span></span><br><span class="line"><span class="built_in">String</span>([]) <span class="comment">// ''</span></span><br><span class="line">&#123;<span class="attr">a</span>:<span class="number">1</span>&#125; <span class="comment">// [object object]</span></span><br></pre></td></tr></table></figure><h3 id="其他值转换为数字类型"><a href="#其他值转换为数字类型" class="headerlink" title="其他值转换为数字类型"></a>其他值转换为数字类型</h3><ul><li>当值是原始类型的转换规则</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字类型转数字类型</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">123</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 字符串转数字类型</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'123a'</span>) <span class="comment">// NaN  Number 比 parseInt 严格,当有字符串无法转换时返回 NaN,而 parseInt 返回已经转换的值, 空字符串转成0</span></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="comment">// undefined：转成 NaN ,null 转成0</span></span><br></pre></td></tr></table></figure><ul><li>当值是引用类型时的转换规则</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先调用 valueOf(),如果不是原始类型的值再调用 toString,然后Number</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="其他值转换为布尔值"><a href="#其他值转换为布尔值" class="headerlink" title="其他值转换为布尔值"></a>其他值转换为布尔值</h3><p>只有 null,undefined,0,空字符串,NaN 转换为 false,其他所有值都转为 true</p><h3 id="引用类型转换为原始类型"><a href="#引用类型转换为原始类型" class="headerlink" title="引用类型转换为原始类型"></a>引用类型转换为原始类型</h3><p>先调用 valueOf(),如果未返回原始类型的值,再调用 toString()</p><h3 id="比较时的隐式转换规则"><a href="#比较时的隐式转换规则" class="headerlink" title="== 比较时的隐式转换规则"></a>== 比较时的隐式转换规则</h3><p>用一句话概括就是<strong>原始类型转数字,引用类型转原始类型</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true == 2 (布尔值先转换为数字类型再参与比较)</span><br><span class="line">11 == ‘11’ (字符串转换为数字类型再参与比较)</span><br><span class="line">&#123;a:1&#125; == ‘a:1’ (复杂类型转换为原始类型再参与比较)</span><br><span class="line">null,undefined 互相==,与自身==,但与其他所有值都不==</span><br></pre></td></tr></table></figure></p><h3 id="解析面试题"><a href="#解析面试题" class="headerlink" title="解析面试题"></a>解析面试题</h3><p>我们可以推测出 a 是引用类型,引用类型与原始类型比较时会先转换成原始类型参与比较,所以 a 每次参与比较都会先后调用自身的 valueOf()和 toString()方法,所以在最后调用 toSring 时让自身递增,就可以让条件成立.所以 a 的值就是.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;</span><br><span class="line">  i:<span class="number">1</span>,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a == <span class="number">1</span> &amp;&amp; a==<span class="number">2</span> &amp; a==<span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于-JavaScript-隐式转换的一道题&quot;&gt;&lt;a href=&quot;#关于-JavaScript-隐式转换的一道题&quot; class=&quot;headerlink&quot; title=&quot;关于 JavaScript 隐式转换的一道题&quot;&gt;&lt;/a&gt;关于 JavaScript 隐式转换的一
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Sass和Less的总结</title>
    <link href="http://yoursite.com/2018/06/22/Sass%E5%92%8CLess%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/22/Sass和Less的总结/</id>
    <published>2018-06-22T07:27:55.000Z</published>
    <updated>2018-06-22T07:28:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Sass的安装-及编译"><a href="#Sass的安装-及编译" class="headerlink" title="Sass的安装 及编译"></a>Sass的安装 及编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">brew install ruby</span><br><span class="line">brew install sass</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译(sass提供4种编译风格)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nested: 嵌套缩进,默认值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> expanded: 没有缩进的扩展的 css 代码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> compact: 简洁格式的 css 代码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> compressed: 压缩后的 css 代码</span></span><br><span class="line">sass --style compressed test.sass  test.css</span><br><span class="line"><span class="meta">#</span><span class="bash"> 监控某个文件,一旦变动,自动生成编译后的版本</span></span><br><span class="line">sass --watch input.scss:output.css</span><br><span class="line"><span class="meta">#</span><span class="bash"> 监控某个文件夹</span></span><br><span class="line">sass --watch app/sass:publc/stylesheets</span><br></pre></td></tr></table></figure><h3 id="Sass-的使用"><a href="#Sass-的使用" class="headerlink" title="Sass 的使用"></a>Sass 的使用</h3><ol><li><p>使用变量</p><p>sass 使用<code>$</code>符号来标识变量,因为它不会导致现存和未来的 css 语法冲突,且深受程序员喜爱.</p><ol><li><p>变量声明</p><p>和 css 属性声明类似:<code>$custom-color:#f90;</code>,声明后的变量只有引用这个变量的时候才会生效.与 css 属性不同,变量可以在 css 规则块定义之外存在.当变量定义在 css 规则块内,那么该变量只有在这个规则块内使用才会生效.声明变量时,变量值还可以引用其他的变量.</p></li><li><p>变量引用</p><p>凡是 css 属性的标准值可存在的地方就可以使用变量.<code>background-color: $custom-color;</code></p></li><li><p>变量镶嵌在字符串中必须写在<code>#{}</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$side: left;</span><br><span class="line">.div&#123;</span><br><span class="line">    border-#&#123;$side&#125;-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变量名用中划线还是下划线分割</p><p>这两种用法相互兼容,但是推荐使用中划线,这也是 compass 使用的方式.</p></li></ol></li><li><p>计算功能</p><p>sass 允许在代码中使用算式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    margin: (14px/2);</span><br><span class="line">    top: 50px + 100px;</span><br><span class="line">    right: $var * 10%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>嵌套 css 规则</p><p>sass 可以再规则块中嵌套规则块,使样式可读性更高.且 sass 在输出时会帮你把这些规则处理好,避免你的重复书写.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    .header&#123;</span><br><span class="line">        p&#123;</span><br><span class="line">            font-size: $font-size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 大多数这种简单的嵌套都没有问题,但<strong>如果你现在嵌套的选择器中使用类似于<code>:hover</code>的伪类,为了解决这种情况, sass 提供了一个特殊结构<code>&amp;</code></strong></p><ol><li><p>父选择器的标识符<code>&amp;</code></p><p>如果不使用<code>&amp;</code>,下面的 sass 则无法工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">article a&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    :hover&#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//他会被编译为 article a :hover&#123;...&#125;</span><br></pre></td></tr></table></figure><p>article 元素内所有的子元素在 hover 都会变成红色.这是不正确的.你想把这条规则应用到超链接自身,而后代选择器的方式无法帮你实现.</p><p><strong>sass 提供<code>&amp;</code>表示父选择器,它不会像后代选择器那样进行拼接,而是直接替换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">article a&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    &amp;:hover&#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//他会被编译为 article a:hover&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>群组选择器的嵌套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nav, aside&#123;</span><br><span class="line">    a &#123;color: blue&#125;</span><br><span class="line">&#125;</span><br><span class="line">//编译为: nav a , aside a &#123;color: blue&#125;</span><br></pre></td></tr></table></figure></li><li><p>子组合器和同层组合选择器 <code>&gt;</code>,<code>+</code>,<code>~</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">article&#123;</span><br><span class="line">    ~ article&#123;border-top: 1px solid #ccc&#125;</span><br><span class="line">    &gt; section &#123;color: red&#125;</span><br><span class="line">    nav + &amp; &#123;margin: 0&#125;</span><br><span class="line">&#125;</span><br><span class="line">//编译为</span><br><span class="line">article ~ article&#123;...&#125;</span><br><span class="line">article &gt; section&#123;...&#125;</span><br><span class="line">nav + article &#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>嵌套属性</p><p>在 sass 中,除了 css 选择器可以嵌套,属性也可以嵌套,比如 border 的诸多属性反复写比较痛苦,我们可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nav&#123;</span><br><span class="line">    border&#123;</span><br><span class="line">        style: solid;</span><br><span class="line">        width: 1px;</span><br><span class="line">        color: #ccc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>导入 sass 文件</p><p>css 中有一个<code>@ import</code>规则,允许在一个 css 文件中导入其他 css 文件,然而只有执行到<code>@ import</code> 时,浏览器才回去下载其他 css 文件,导致文件加载特别慢.</p><p><strong>sass也有一个<code>@ import</code> 的规则,不同的是, sass 的<code>@ import</code> 在生成 css 文件时就把相关文件导入进来,在导入时你可以省略<code>. sass</code> 或<code>. scss</code> 的后缀</strong></p><ol><li><p>使用 sass 的部分文件</p><p>当通过<code>@ import</code>把 sass 的样式分散到多个文件时,你通常只想生成少数几个 css 文件,有些 sass 文件并不需要生成对应的独立 css 文件,这些 sass 文件称为局部文件.<strong>sass 约定局部文件名以下划线开头,这样 sass 就不会再编译时单独编译这个文件输出 css, 而只把这个文件用作导入.</strong></p></li><li><p>默认变量值</p><p>如果反复声明一个变量,后者会覆盖前者,加入你引入一个他人的 sass 库文件,你可能希望导入者可以定制修改这个文件中的某些值.<strong>使用sass 的<code>!default</code>标签可以实现这个目标,它很像 css 的<code>!important</code>的对立面,不同的是<code>!default</code>表示如果这个变量被声明赋值了,则用它的声明,否则就用这个默认值</strong></p></li><li><p>嵌套导入</p><p>sass 允许<code>@import</code>可以写在 css 规则中.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aside&#123;</span><br><span class="line">    @import &apos;test&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>原生的 css 导入</p><p>由于 sass 兼容原生的 css, 所以支持原生的@ import, 因为 sass 语法完全兼容 css, 所以你可以把原始的 css 文件改名为<code>. scss</code>后缀即可直接导入了.</p></li><li><p>静默注释</p><p>sass 提供了一种不同于 css 标准注释格式的<code>/*...*/</code>的注释语法,即静默注释,其内容不会出现在生成的 css 文件中,他的语法和 js ,java 等类 C 的语言中单行注释相同即以<code>//</code>开头,注释内容到行末</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    color: #333;//不会出现在生成的 css 中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>高级用法</p><ol><li><p>条件语句<code>@if ... @else ...</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@if $color == &apos;red&apos;&#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;@else&#123;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*for 循环*/</span><br><span class="line">@for $i from 1 to 10&#123;</span><br><span class="line">    .border-#&#123;$i&#125;&#123;</span><br><span class="line">        border: #&#123;$i&#125;px solid blue; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*while 循环*/</span><br><span class="line">$i: 10;</span><br><span class="line">@while $i &gt; 0 &#123;</span><br><span class="line">    .item-#&#123;$i&#125;&#123;</span><br><span class="line">        width: 2px * $i;</span><br><span class="line">    &#125;</span><br><span class="line">    $i: $i -2;</span><br><span class="line">&#125;</span><br><span class="line">/**each 命令,作用和 for 类似*/</span><br><span class="line">@each $member in a,b,c,d &#123;</span><br><span class="line">    .#&#123;$member&#125;&#123;</span><br><span class="line">        background-image: url(&quot;/image/#&#123;$member&#125;.jpg&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义函数</p><p>sass 允许用户编写自己的函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@function double($n)&#123;</span><br><span class="line">    @return $n * 2;</span><br><span class="line">&#125;</span><br><span class="line">.sidebar&#123;</span><br><span class="line">    width: double(5px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>混合器</p><ol><li><p>当你的样式越来越复杂时,大量使用变量并不是一个很好的方式,<strong>你可以通过混合器来实现大段样式的重用.混合器使用<code>@ mixin</code>标识符定义.</strong>这看上去很像 css 的标识符,比如<code>@media</code>或<code>@font-face</code>.混合器标识符可以把混合器中所有的样式提取出来放在<code>@include</code>中被调用的部分.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@mixin custorm&#123;</span><br><span class="line">    border: 1px solid #ccc;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">&#125;</span><br><span class="line">notice&#123;</span><br><span class="line">    color: #eee;</span><br><span class="line">    @include custorm</span><br><span class="line">&#125;</span><br><span class="line">//编译为</span><br><span class="line">notice&#123;</span><br><span class="line">    color: #eee;</span><br><span class="line">    border: 1px solid #ccc;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你发现在很多地方都在使用同一样式,则应该把它改造为混合器.</p></li><li><p>给混合器传参</p><p>混合器并不一定总是生成相同的样式,可以给混合器传参来定制精确的样式,这种方式和 JS 中的<code>function</code>很像.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@mixin link-color($normal,$hover)&#123;</span><br><span class="line">    color: $normal;</span><br><span class="line">    &amp;:hover &#123;color: $hover&#125;</span><br><span class="line">&#125;</span><br><span class="line">a&#123;</span><br><span class="line">    @include link-color(blue,red)</span><br><span class="line">&#125;</span><br><span class="line">//混合器支持默认参数值</span><br><span class="line">@mixin color(</span><br><span class="line">$normal,</span><br><span class="line">$hover: $normal</span><br><span class="line">)&#123;</span><br><span class="line">    color: $normal;</span><br><span class="line">    &amp;:hover &#123;color: $hover&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>继承</p><ol><li><p>使用选择器继承来精简 css</p><p>使用 sass 时,最后一个减少重复的主要特征就是选择器继承.就是说一个选择器可以继承另一个选择器的所有样式,这个通过<code>@extend</code>语法实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.error&#123;</span><br><span class="line">    border: 1px solid #ccc;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">.seriousError&#123;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    @extend .error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@extend</code>不仅会继承它自身的所有属性,任何跟它有关的组合选择器样式也会以组合选择器的形式继承.比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.error a&#123;</span><br><span class="line">    font-weight: 100;</span><br><span class="line">&#125;</span><br><span class="line">//同样应用到 .seriousError a&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>何时使用继承</p><p>继承是基于类的,所以继承应该建立于语义化的关系上,当一个元素拥有类,表明它属于另一个类,这时使用继承再适合不过了.<strong>使用继承时的最好方法就是不要在后代选择器的时候去继承 css 规则,因为这样被继承的 css规则通过后代选择器修饰的样式,生成 css 中选择器的数量很快就会失控.</strong></p></li><li><p>继承与混合器的比较</p><p>继承比混合器生成的 css 代码更少,因为继承仅仅是重复选择器,而不会像混合器那样重复书写,所以继承会提升站点的速度.继承遵从 css 的层叠规则,同一属性根数层叠的权重高低而选择权重高的胜出,而混合器本身不会引起 css 层叠的问题,因为混合器把样式直接放到 css 规则块中.</p></li></ol></li></ol><h3 id="Less-的安装及编译"><a href="#Less-的安装及编译" class="headerlink" title="Less 的安装及编译"></a>Less 的安装及编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 node 环境全局安装 less</span></span><br><span class="line">npm install -g less</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 less 文件</span></span><br><span class="line">lessc styles.less styles.css</span><br></pre></td></tr></table></figure><h3 id="Less-的使用"><a href="#Less-的使用" class="headerlink" title="Less 的使用"></a>Less 的使用</h3><p>​    和 Sass一样,Less 作为一种 css 扩展,它同样兼容 css, 且学习成本比 Sass 要小一些,这使得学习 Less 更轻松.</p><ol><li><p>变量</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@nice-blue :</span> <span class="number">#5B83AD</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="variable">@nice-blue</span>;</span><br><span class="line"><span class="comment">/*变量插值*/</span></span><br><span class="line"><span class="variable">@dicretion:</span> left;</span><br><span class="line"><span class="selector-tag">margin-</span><span class="variable">@&#123;dicretion&#125;</span>: <span class="selector-tag">20px</span>;</span><br></pre></td></tr></table></figure><p>注意: 变量只能定义一次,实际上它们就是常量.</p></li><li><p>mixin( 混合)</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.nice-color</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#5B83AD</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*只需要在规则中访问我们定义的类名即可*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="selector-class">.nice-color</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*带默认参数的混合*/</span></span><br><span class="line"><span class="selector-class">.nice-color</span>(<span class="variable">@beauty</span>:<span class="number">#5B83AD</span>)&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@beauty</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="selector-class">.nice-color</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>嵌套规则</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#5B83AD</span>;</span><br><span class="line">    <span class="comment">/*配合媒体查询*/</span></span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">min-width</span>:<span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*&amp;为当前选择器的父选择器*/</span></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">        <span class="attribute">clear</span>:both;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运算</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**Less 能够推断颜色和单位之间的区别*/</span></span><br><span class="line"><span class="attribute">color</span>: <span class="number">#888</span> / <span class="number">4</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">1px</span> + <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>继承</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inline</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">p</span>:extend(.inline)</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>函数</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span>(<span class="variable">@color</span>,<span class="variable">@size</span>)&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">@size</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="selector-class">.a</span>(<span class="number">#ccc</span>,<span class="number">16px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作用域</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**Less 中的作用域与编程语言中的作用域概念非常相似。首先会在局部查找变量和混合，如果没找到，编译器就会在父作用域中查找，依次类推。*/</span></span><br><span class="line"><span class="variable">@var:</span> red;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#page</span> &#123;</span><br><span class="line">  <span class="variable">@var:</span> white;</span><br><span class="line">  <span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@var</span>; <span class="comment">// white</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注释</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 可以使用块注释 */</span></span><br><span class="line"><span class="variable">@var:</span> red;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用行注释</span></span><br><span class="line"><span class="variable">@var:</span> white;</span><br></pre></td></tr></table></figure></li><li><p>导入</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**导入工作与你预期的一样。你可以导入一个 .less 文件，然后这个文件中的所有变量都可以使用了。对于 .less 文件而言，其扩展名是可选的。*/</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"library"</span>; <span class="comment">// library.less</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"typo.css"</span>;<span class="comment">// css import</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Sass-和-Less-的区别"><a href="#Sass-和-Less-的区别" class="headerlink" title="Sass 和 Less 的区别"></a>Sass 和 Less 的区别</h3><ol><li><p>扩展名</p><p>Sass 以<code>.sass</code>和<code>.scss</code>后缀结尾,而 Less 以<code>less</code>后缀结尾.</p></li><li><p>变量声明</p><p>Sass变量必须是以$开头的，然后变量和值之间使用冒号（：）隔开.而 Less变量以@开头.</p></li><li><p>变量嵌入字符串</p><p>Sass 使用<code>${xx}</code>使变量嵌入字符串,而 Less 使用<code>@{xx}</code></p></li><li><p>继承</p><p>Sass 以<code>@extend</code>继承,而 Less 以<code>:extend</code>继承.</p></li><li><p>混入</p><p>Sass 的混入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@mixin error($borderWidth: 2px) &#123;</span><br><span class="line">  border: $borderWidth solid #F00;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">    @ include error(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Less 的混入</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span>(<span class="variable">@borderWidth</span>: <span class="number">2px</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@borderWidth</span> solid <span class="number">#F00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="selector-class">.error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高级语法</p><p>Sass 支持很多高级语法,而 Less 对高级语法的支持比较少.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Sass的安装-及编译&quot;&gt;&lt;a href=&quot;#Sass的安装-及编译&quot; class=&quot;headerlink&quot; title=&quot;Sass的安装 及编译&quot;&gt;&lt;/a&gt;Sass的安装 及编译&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="前端 css" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF-css/"/>
    
    
      <category term="sass less" scheme="http://yoursite.com/tags/sass-less/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 requestAnimationFrame 请求动画帧</title>
    <link href="http://yoursite.com/2018/05/03/%E6%B5%85%E8%B0%88%20requestAnimationFrame%20%E8%AF%B7%E6%B1%82%E5%8A%A8%E7%94%BB%E5%B8%A7/"/>
    <id>http://yoursite.com/2018/05/03/浅谈 requestAnimationFrame 请求动画帧/</id>
    <published>2018-05-03T11:14:12.000Z</published>
    <updated>2021-08-30T11:15:39.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈-requestAnimationFrame-请求动画帧"><a href="#浅谈-requestAnimationFrame-请求动画帧" class="headerlink" title="浅谈 requestAnimationFrame 请求动画帧"></a>浅谈 requestAnimationFrame 请求动画帧</h1><blockquote><p>JavaScript 中有 setTimeout 和 setInterval 两种定时器,但这两种定时器虽然设定了精确的时间,但 JS 却不能保证恰好在那个时间点运行.一是因为大多数浏览器并没有精确到毫秒级别的触发时间,多少会有时间差,二是因为JS 的运行机制是 EventLoop 无法保证时间精确.</p></blockquote><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p>requestAnimationFrame是一种时间精确的定时器,原理是由系统决定回调函数的执行时间,而执行频率紧紧跟随浏览器的刷新频率.如果刷新频率通常为60HZ,即一秒钟重绘60次,那么requestAnimationFrame也会执行60次.即使什么都不做,显示器依然会以相应频率不断刷新屏幕上的图像.</p><p>setTimeout 和 setInterval 实现的动画在某些设备上会有卡顿,抖动的效果.这是因为刷新频率与设置的时间间隔不同步导致的.而动画的本质就是让人眼看到的图像被绘制而引起变化的视觉效果,这个变化要以连贯平滑的方式进行过渡.</p><h3 id="requestAnimationFrame的调用"><a href="#requestAnimationFrame的调用" class="headerlink" title="requestAnimationFrame的调用"></a>requestAnimationFrame的调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> progress = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  progress += <span class="number">1</span> <span class="comment">//修改图像位置</span></span><br><span class="line">  <span class="keyword">if</span>(progress &lt; <span class="number">100</span>)&#123;</span><br><span class="line">    <span class="comment">// 递归渲染</span></span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(render)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(render) <span class="comment">// 第一帧渲染</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈-requestAnimationFrame-请求动画帧&quot;&gt;&lt;a href=&quot;#浅谈-requestAnimationFrame-请求动画帧&quot; class=&quot;headerlink&quot; title=&quot;浅谈 requestAnimationFrame 请求动画帧&quot;&gt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>&lt;CSS世界&gt;读书笔记</title>
    <link href="http://yoursite.com/2018/04/12/CSS%E4%B8%96%E7%95%8C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/12/CSS世界-读书笔记/</id>
    <published>2018-04-12T03:11:01.000Z</published>
    <updated>2018-04-12T03:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在看张鑫旭的<code>&lt;&lt;CSS世界&gt;&gt;</code>,对里面说的一些干货做了点总结,如果希望看到更多知识,请自行购买.</p></blockquote><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><h4 id="何为流"><a href="#何为流" class="headerlink" title="何为流?"></a>何为流?</h4><p>“流”实际上是CSS世界中的一种基本的定位和布局机制,可以理解为现实世界的一套物理规则,”流”和现实世界的”水流”有异曲同工之妙.就好像我们把水流入一个容器,水面一定是平整的,我们在水中放入物体,水面升高物体依次排列.所以”流”就是CSS世界中引导元素排列和定位的一条看不见的水流.</p><h3 id="流-元素与基本尺寸"><a href="#流-元素与基本尺寸" class="headerlink" title="流,元素与基本尺寸"></a>流,元素与基本尺寸</h3><h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><p>“块级元素”和<code>display:block;</code>不是一个概念.比如<code>&lt;li&gt;</code>元素默认的display是list-item,<code>&lt;table&gt;</code>对应的display是table,但它们都是块级元素,因为它们符合块级元素的特征,也就是一个水平流上只能单独显示一个元素,多个元素则换行显示.正是由于块级元素的换行特性,理论上它都可以配合clear属性来清除浮动.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    display: table;//或block等.</span><br><span class="line">    <span class="selector-tag">clear</span>: <span class="selector-tag">both</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外部尺寸和内部尺寸"><a href="#外部尺寸和内部尺寸" class="headerlink" title="外部尺寸和内部尺寸"></a>外部尺寸和内部尺寸</h4><p>当一个元素的尺寸由外部元素决定就称为外部尺寸,当一个元素的尺寸由内部元素决定就称为内部尺寸.</p><h4 id="深藏不漏的width-auto"><a href="#深藏不漏的width-auto" class="headerlink" title="深藏不漏的width: auto"></a>深藏不漏的width: auto</h4><ul><li><p>正常流宽度</p><p>在页面中随便扔一个div元素,它就会具备block容器的流特性.</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a元素的display 默认是 inline,当它设置为 block的时候使其具有块状化.但width设置为100%则完全没有必要.”鑫三无原则”,即”无宽度,无图片,无浮动”.为何无宽度?因为表现为”外部尺寸的”块级元素一旦设置了宽度,流动性就失去了.<strong>所谓流动性,并不是看上去宽度为100%那么简单,而是一直margin/border/padding以及content内容区域自动分配水平空间的机制.</strong></p><ul><li><p>格式化宽度</p><p>格式化宽度值出现在”绝对定位模型”中,也就是当position为absolute或fixed元素中,默认情况下,绝对定位元素的宽度是由内部尺寸决定的,但是有一种情况宽度由外部尺寸决定.对于非替换元素(…)当left/right或top/bottom<strong>对立的属性值同时存在时,元素的宽度为格式化宽度</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1000px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    div2&#123;</span><br><span class="line">        <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">        <span class="selector-tag">left</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line">        <span class="selector-tag">right</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上样式可知,div2的宽度为<code>1000-20-20 = 960</code></p></li><li><p>内部尺寸和流式特性</p><p>button按钮是CSS极具代表的inline-block元素,是展示”包裹性”最好的例子,具体表现为:按钮文字越多宽度越宽(内部尺寸特性),但文字足够多,在容器宽度处自动换行(自适应特性).</p><p>包裹性在实际开发中的用处: 页面某个模块文字内容是动态的,希望文字少的时候居中显示,文字多的时候居左显示.代码如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>width值作用的细节</p><p>CSS盒模型的组成模式有两种: 一种是border-box.即padding和border也被包含在width和height中的怪异下的盒模型,还有一种是content-box为标准模式下的盒模型.</p><p>给width属性赋一个值,该值作用在content上,且一旦设定width值,该元素就没有了流动性,所以提出”无宽度准则”,这样会更灵活,容错性更强.</p></li><li><p>CSS流体布局下的宽度分离原则(便于维护)</p><p>也就是CSS中的width属性不与其他影响宽度的padding/border/margin属性共存.width属性独占一层标签,而padding/border等属性利用流动性在内部自适应实现.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">180px</span>;</span><br><span class="line">    .son&#123;</span><br><span class="line">        <span class="selector-tag">margin</span>: 0 20<span class="selector-tag">px</span>;</span><br><span class="line">        <span class="selector-tag">padding</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="相对简单单纯的height-auto"><a href="#相对简单单纯的height-auto" class="headerlink" title="相对简单单纯的height: auto"></a>相对简单单纯的height: auto</h4><p>CSS的默认流是水平方向的,宽度是稀缺的,高度是无限的,所以宽度的分配规则比较复杂,高度显得比较随意.</p><ul><li><p>关于height: 100%</p><p>对于width属性就算父元素的width是auto,其百分比值也是支持的.但是,对于height属性,如果父元素的height为auto,只要子元素在文档流中,其百分比的值就被忽略了.<strong>我们发现百分比高度值想要生效,其父级必须有一个可以生效的高度值.</strong></p><p>要明白其中的原因要先了解浏览器渲染的基本原理.首先下载文档内容,加载头部的样式资源,然后从上而下,自外而内的顺序渲染DOM内容.因此,当渲染到父元素的时候,子元素的width:100%;并没有渲染,宽度就是内容的宽度,等渲染到子元素时,父元素宽度已经固定,此时width:100%;就是父元素的宽度.宽度不够溢出就好了.overflow属性就是为此而生的.<strong>为什么宽度支持,高度不支持呢?</strong>规范中给出了答案,<strong>如果包含块的高度没有显式指定(即高度由内容决定),并且该元素不是绝对定位,则计算值为auto.一句话总结就是,高度没有显式指定则解释为auto,再和百分比计算结果为NaN</strong></p><p>想要他生效只有如下设置:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>max-width/height,min-width/height与width/height区别</p><p>width/height的默认值是auto,而min-width/height 的默认值是0,max-width/height的默认值是none.</p><p>他们三者也有一套相互覆盖的规则:<strong>超越!important,超越最大</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span> <span class="attr">style</span>=<span class="string">"width: 480px!important"</span>/&gt;</span></span><br><span class="line">img&#123;</span><br><span class="line">max-width: 260px;//max-width会覆盖width.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">1400px</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">1200px</span>;</span><br><span class="line">    //当min比max还要大的时候,遵循'超越最大'原则</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h4><p>​    inline和block是<strong>流式布局的本质所在</strong>.从作用上来讲,块级负责结构,内联负责内容.且内联元素设计的属性非常多,且往往具有继承属性.</p><p>​    从定义看,<strong>内联元素与<code>display:inline</code>不是一个概念</strong>.因为<code>display:inline-block;</code>与<code>display:inline-table;</code>也是内联元素,因为他们的外在盒子都是内联元素.</p><p>从表现上,<strong>内联元素的典型特征就是可以和文字显示在一行.</strong>因此,文字是内联元素,按钮也是内联元素,输入框下拉框都是.</p><h3 id="盒尺寸四大家族"><a href="#盒尺寸四大家族" class="headerlink" title="盒尺寸四大家族"></a>盒尺寸四大家族</h3><h4 id="深入理解content"><a href="#深入理解content" class="headerlink" title="深入理解content"></a>深入理解content</h4><ul><li><p>什么是替换元素?</p><p>根据”外在盒子”是内联还是块级,我们把元素分为内联元素和块级元素.而根据是否具有可替换内容我们把元素分为替换元素和非替换元素.举个例子,<code>&lt;img src=&quot;1.jpg&quot;&gt;</code>但我们把src换为<code>2.jpg</code>图片就会替换,这种通过修改某个属性值就可以被替换的元素称为”替换元素”.所以的替换元素都是内联水平元素.</p><p>替换元素有三种尺寸,分别为固有尺寸,HTML尺寸,CSS尺寸.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>&gt;</span> /如果没有HTML尺寸和CSS尺寸,则使用固有尺寸即图片的尺寸/</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> <span class="attr">height</span>=<span class="string">"96"</span>&gt;</span> /如果没有CSS尺寸则使用HTML尺寸/</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>&gt;</span></span><br><span class="line">img&#123;</span><br><span class="line">width:200px;</span><br><span class="line">height:100px;/如果有css尺寸则使用css尺寸/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CSS世界中的替换元素有一个很重要的特性,那就是’我们无法改变这个替换元素内容的固有尺寸’</strong>.那为什么我们设置width和height会影响图片尺寸呢?那是因为图片中的content替换内容的默认适配方式是”填充”,不管设置的尺寸有多大,就填充多大.在CSS3之前这种适配方式是不能修改的.CSS3我们可以通过<strong>object-fit属性修改该方式</strong>,例如<code>&lt;img&gt;</code>元素的默认声明是<code>object-fit:fill;</code>如果我们设置为<code>object-fit:none;</code>那么图片的尺寸就完全不受控制.如果我们设置为<code>object-fit: contain;</code>则图片保持比例尽可能的利用HTML的尺寸但又不会超出的方式显示.</p><p><strong>替换元素和非替换元素的区别主要在于src和content</strong>.</p></li><li><p>content生成辅助元素</p><p>实际项目中,content属性主要用于<code>::before</code>以及<code>::after</code>这两个伪元素中.此应用的核心点不在content上,而在伪元素上,所以我们通常会写<code>content:&#39;&#39;;</code> 生成辅助元素后再实现特定布局或实现图形效果.辅助元素最常用的应用是清除浮动.如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>content字符内容生成</p><p>content字符内容生成就是直接写入字符内容,中英文都可以,比较常见的就是配合@font-face规则实现图标字体效果.</p></li><li><p>content图片生成</p><p>content图片生成指的是直接使用url功能符显示图片.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(1.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们对于图片的宽高不好控制,无法改变图片的固有尺寸.所以我们通常使用background-image.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(1.jpg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>content计数器</p><p>主要是两个属性和一个方法.</p><p>counter-reset: 计数器名字   计数器的默认值;</p><p>counter-increment:  计数器名字 递增的值(省略的话默认是1);</p><p>方法:counter(name) 显示计数.</p><p>​</p></li></ul><h4 id="温和的padding属性"><a href="#温和的padding属性" class="headerlink" title="温和的padding属性"></a>温和的padding属性</h4><ul><li><p>padding和元素的尺寸</p><p>因为CSS默认的box-sizing是content-box,所以使用padding会影响元素的尺寸.但对于内联元素(不包括替换元素)而言,padding影响水平方向,而不影响垂直方向,这样的说法也不完全准确.由于内联元素没有可视宽度和可视高度的说法,垂直方向完全受line-height和vertical-align的影响,所以从视觉上来说,padding在垂直方向上没有起作用,但是我们给它加个背景色会发现其尺寸确实受到影响了.在实际开发中,我们可以在不影响布局的前提下,优雅的增加链接或按钮的点击区域大小.</p></li><li><p>padding的百分比取值</p><p>padding的值和margin值不同之处在于,padding的值不可以是负数.还有,<strong>padding的值如果是百分比,不论是水平方向还是垂直方向都是相对于宽度来说的.</strong></p></li><li><p>padding与图像绘制</p><p><strong>padding和background-clip属性配合可以在有限的标签下实现一些CSS绘制效果.</strong></p><p>比如如何用一个标签绘制”大队长”三道杠的分类图标效果.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">140px</span>;</span><br><span class="line">    height: 10px;//中间的杠</span><br><span class="line">    <span class="selector-tag">padding</span>: 35<span class="selector-tag">px</span> 0;</span><br><span class="line">    border-top: 10px solid;//上面的杠</span><br><span class="line">    border-bottom: 10px solid;//下面的杠</span><br><span class="line">    <span class="selector-tag">background-color</span>: <span class="selector-tag">currentColor</span>;</span><br><span class="line">    <span class="selector-tag">background-clip</span>: <span class="selector-tag">content-box</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="激进的margin属性"><a href="#激进的margin属性" class="headerlink" title="激进的margin属性"></a>激进的margin属性</h4><ul><li><p>相关概念</p><p>元素尺寸: border + padding + content</p><p>元素内部尺寸: padding + content</p><p>元素外部尺寸: margin + border + padding + content</p></li></ul><ul><li><p>margin与元素尺寸以及相关布局</p><p><strong>一旦宽度设定,margin就无法改变元素尺寸.</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    margin: 0 -20px;//元素宽度还是100px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p><strong>只要元素的尺寸表现符合’充分利用可用空间’无论是垂直方向还是水平方向都可以通过margin改变尺寸.</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    margin: 0 -20px; //该元素空间为140px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正是这种具有流体特性下的改变尺寸特性,margin可以很方便的实现很多流体布局效果,比如说一侧定宽,一侧自适应.</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>margin的百分比值</p><p>和padding一样,margin的百分比值无论是水平方向还是垂直方向都是相对于宽度计算的.</p></li><li><p>margin的合并</p><p>块级元素的margin-top和margin-bottom通常会合并为一个margin.我们可以捕获两点重要信息,<strong>一是块级元素</strong>,二是<strong>垂直方向</strong>.</p><p>margin合并的计算规则:<strong>正正取大值,正负值相加,负负最负值.</strong></p></li><li><p>深入理解margin: auto;</p><p>我们首先要知道,有时候元素就算没有设置height和width,也会自动填充和自动填充对应的方位.假设一个外部的容器宽度是300px, 而内部的容器因为设置宽度为200px而导致原本应该自动填满的空间现在有100px闲置了,<code>margin: auto</code>就是为了填充这个闲置的尺寸的.<code>margin:auto;</code>的填充规则是: <strong>如果一侧定值,一侧auto,则auto为剩余的空间大小.如果两侧都是auto,则平分剩余空间.</strong></p><p>当我们想要某个块级元素右对齐时,脑子里不要就一个<code>float:right;</code>,很多时候<code>margin-left:auto;</code>才是最佳实践.浮动毕竟是个”魔鬼”,<strong>margin属性的auto计算就是为了块级元素左右对齐而设计的,和内联元素的text-align控制左右对齐相呼应.</strong></p><p>我们可能会发现<code>margin:auto;</code>并不能实现垂直居中,但是我们可以利用绝对定位实现这个需求.因为绝对定位后,top/bottom/left/right会自动填充,但又因为设置了宽高,导致多余的空间闲置,这时<code>margin:auto;</code>就可以计算空间了.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>: left:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>; <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    margin: auto;//实现垂直居中.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="功勋卓越的border属性"><a href="#功勋卓越的border属性" class="headerlink" title="功勋卓越的border属性"></a>功勋卓越的border属性</h4><ul><li><p>border与透明边框技巧</p><p><strong>优雅的增加点击区域大小.</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.click</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">11px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三角形图形绘制</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#f30</span> transparent transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="内联元素与流"><a href="#内联元素与流" class="headerlink" title="内联元素与流"></a>内联元素与流</h3><h4 id="字母x是CSS中隐匿的举重若轻的角色"><a href="#字母x是CSS中隐匿的举重若轻的角色" class="headerlink" title="字母x是CSS中隐匿的举重若轻的角色"></a>字母x是CSS中隐匿的举重若轻的角色</h4><p>各种内联相关模型中,凡是涉及垂直方向的排版或是对齐的,都离不开最基本的基线.字母x下的下边缘就是基线.</p><p><code>vertical-align:middle;</code>并不是绝对的垂直居中对齐,这里的middle是基线往上1/2 x-height的高度,也就是字母x的交叉点的位置.所以middle得垂直居中只是一种近似效果.</p><p>字母X衍生了x-height(字母x的高度)的概念,并进一步衍生出了ex,ex是css中的一个尺寸单位,是一个相对单位,指的是小写字母x的高度.其实就是x-height.</p><h4 id="内联元素的基石-line-height"><a href="#内联元素的基石-line-height" class="headerlink" title="内联元素的基石 line-height"></a>内联元素的基石 line-height</h4><p>思考下面的问题,一个默认的空div高度是0,里面写上几个文字后高度就有了,这个高度从何而来?</p><p>不少人认为是由文字把内容撑开的,但本质上是由line-height属性所决定的,对于文本这样的纯内联元素,line-height就是高度计算的基石.</p><p>为什么line-height可以让内联元素垂直居中?这是一个误区,要想让单行文字垂直居中只要设置line-height大小就可以了,和height没有任何关系.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title2</span>&#123;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">24px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多行文本和替换元素的垂直居中和单行文本不一样, 需要用到vertical-align:middle的帮助.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>line-height的值一般为固定长度值,也可以是数值和是百分比,两者的值都是与font-size相乘后的值.</p><p><strong>内联元素的大值特性:无论内联元素的line-height如何设置,最终父级元素的高度都是由数值最大的那个line-height所决定的.</strong></p><h4 id="line-height的好朋友vertical-align"><a href="#line-height的好朋友vertical-align" class="headerlink" title="line-height的好朋友vertical-align"></a>line-height的好朋友vertical-align</h4><p>为什么说他们是好朋友呢,因为凡是line-height起作用的地方vertical-align也一定起作用.因为vertical-align的默认值是baseline基线对齐,而基线的定义是x的下边缘.它等同于<code>vertical-align:0;</code></p><p>####基于vertical-align属性的水平垂直居中大小不固定弹框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dialog"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;<span class="attribute">right</span>:<span class="number">0</span>;<span class="attribute">bottom</span>:<span class="number">0</span>;<span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,0,.5);</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">white-space</span>: nowarp;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dialog</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">    <span class="attribute">text-align</span>:left;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">white-space</span>: nowarp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流的破坏与保护"><a href="#流的破坏与保护" class="headerlink" title="流的破坏与保护"></a>流的破坏与保护</h3><h4 id="魔鬼属性float"><a href="#魔鬼属性float" class="headerlink" title="魔鬼属性float"></a>魔鬼属性float</h4><p>浮动的本质就是为了实现文字环绕效果,这种文字环绕主要指文字环绕图片的显示效果.理论上可以通过float把整个页面结构都弄出来,但这种方式太脆弱缺乏弹性.一旦某个元素宽高发生变化,就会发生布局错位.</p><p>float的特性:</p><ol><li><p>包裹性</p><p>假设浮动元素的父元素width为200px,浮动元素子元素是一个宽度为128px的图片,此时元素宽度表现为”包裹”,就是里面图片的宽度128px;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    .float&#123;</span><br><span class="line">        float: left;//该元素宽度为128px;</span><br><span class="line">        <span class="selector-tag">img</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>:<span class="number">128px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果浮动元素的子元素不止是一张图片,还有许多文字,就会出现”自适应性”,此时浮动元素的宽度为父元素的宽度200px;</strong></p></li><li><p>块状化并格式化上下文</p><p>块状化即float的值只要不是none,其display就会成为block或table.</p></li><li><p>破坏文档流</p></li><li><p>没有任何margin合并</p></li></ol><h4 id="float的作用机制"><a href="#float的作用机制" class="headerlink" title="float的作用机制"></a>float的作用机制</h4><p>float的最著名的特性表现就是会让父元素的高度塌陷.但只要父元素设置了一个具体的值就不需要担心高度塌陷的问题了.但不建议这样做,比较稳妥的做法还是采用一些手段清除浮动带来的影响.</p><h4 id="float与流体布局"><a href="#float与流体布局" class="headerlink" title="float与流体布局"></a>float与流体布局</h4><p>我们可以利用float破坏css正常流的特性,实现两栏或多栏的自适应布局.</p><p>一侧定宽,一侧自适应布局.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    width:100px;//不定宽可以设置为百分比</span><br><span class="line">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span><br><span class="line">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    margin-left: 100px;//不定宽可以设置为百分比</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="float的天然克星clear"><a href="#float的天然克星clear" class="headerlink" title="float的天然克星clear"></a>float的天然克星clear</h4><p>其语法如下: clear : none | left | right | both;</p><p>clear属性本质上并不是清除浮动,而是让自身不能和浮动元素相邻,但clear属性只对块级元素有效.这也就是我们在借助::after等伪元素(内联)清除浮动时需要设置display的原因.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CSS的结界-BFC"><a href="#CSS的结界-BFC" class="headerlink" title="CSS的结界-BFC"></a>CSS的结界-BFC</h4><p>BFC全称 block formatting context,中文为”块级格式化上下文”.</p><p>它的表现原则为: 如果一个元素具有BFC,内部子元素再怎么样也不会影响外部的元素,所以BFC不可能发生margin重叠的.BFC也可以用来清除浮动的影响,因为不清除浮动会影响后面的布局和定位.</p><p><strong>什么时候会触发BFC呢?</strong></p><ol><li><code>&lt;html&gt;</code>根元素</li><li>float的值不为none;</li><li>overflow的值为auto, scroll 或 hidden;</li><li>display 的值为: inline-block,table-cell,table-caption中的任何一个;</li><li>position的值不为static和relative;</li></ol><p>只要元素符合上面的任何一个条件就无需使用<code>clear:both;</code>去清除浮动的影响了.</p><h4 id="最佳结界overflow"><a href="#最佳结界overflow" class="headerlink" title="最佳结界overflow"></a>最佳结界overflow</h4><p>要想彻底清除浮动的影响,最适合的属性不是clear而是overflow.一般使用<code>overflow:hidden;</code></p><p>HTML中有两个标签是可以默认产生进度条的,一个是根元素<code>&lt;html&gt;</code>,另一个是文本域<code>&lt;textarea&gt;</code>,之所以出现滚动条是因为这两个标签的overflow的默认值不是visible.</p><p>滚动条是可以自定义的.支持-webkit-前缀的浏览器可以这样设置.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::-webkit-scrollbar</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">8px</span>;<span class="comment">/*血槽宽度*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-thumb</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,0,.3);<span class="comment">/*拖动条*/</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">::-webkit-scrollbar-track</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ddd</span>;<span class="comment">/*背景槽*/</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>overflow与锚点定位</strong>:锚点就是可以让页面定位到某个位置的点,本质上是通过改变容器滚动高度或者宽度来实现的.设置了overflow属性为auto,scroll,hidden的元素是可以滚动的,<code>overflow:hidden</code>与scroll 和 auto的区别就在于有没有那个滚动条.<strong>高度溢出,滚动依旧存在,只是滚动条不存在</strong>,牢记这一点可以让我们更简单更原生的方式实现一些交互效果.</p><h3 id="CSS世界的层叠规则"><a href="#CSS世界的层叠规则" class="headerlink" title="CSS世界的层叠规则"></a>CSS世界的层叠规则</h3><p>在css中,z-index属性只有和定位元素(position不为static的元素)在一起的时候才有用,可以是正数也可以是负数.但随着css3到来,flex盒子也可以使用z-index属性.</p><p>CSS层叠顺序类型如下:(由低到高) </p><p><strong>层叠上下文background/border -&gt; 负z-index -&gt; block盒子 -&gt; float浮动盒子 -&gt; inline水平盒子 -&gt; z-index: auto或0 -&gt; 正z-index.</strong></p><p>CSS3新时代的层叠上下文:</p><ol><li>元素为flex布局的元素.</li><li>元素opacity不是1</li><li>元素的transform不是none</li><li>元素mix-blend-mode不是 normal</li><li>元素isolation是isolate</li><li>元素will-change属性为上面2-6的任意一个</li><li>元素filter不是none</li><li>元素的-webkit-overflow-scrolling为touch</li></ol><p><strong>z-index”不犯二”准则</strong>:对于非浮层元素,避免设置z-index的值,z-index的值没有任何道理需要超过2.</p><h3 id="强大的文本处理能力"><a href="#强大的文本处理能力" class="headerlink" title="强大的文本处理能力"></a>强大的文本处理能力</h3><h4 id="font-size的能力"><a href="#font-size的能力" class="headerlink" title="font-size的能力"></a>font-size的能力</h4><p>line-height的部分类别属性是相对于font-size计算的,而vertical-align百分比属性值又是相对于line-height计算的.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &gt; <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: -<span class="number">25%</span>; <span class="comment">/* (即16px * 1.5 * -25% = -6px) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>font-size与ex,em,和rem的关系</strong>: ex是字符x的高度,font-size越大,对应的ex越大.em是根据当前元素的font-size计算的,而rem( root-em )是相对于HTML根元素的font-size进行计算的.</p><p><strong>桌面Chrome浏览器有一个12px的字号限制</strong>但并不是所有小于12px的字号都当做12px处理,有一个值例外那就是0.</p><p><strong>如果font-size:0;那么文字就会被直接隐藏掉</strong>.不然哪怕是0.00001px也会被当做12px处理.</p><p>font-weight表示文字的粗细程度,我们通常设置为bold 和 normal.也可以设置为100-900,该值必须是整百数.其中400等同于normal,700等同于bold.</p><p>font属性联写: [font-style] ? font-size [/line-height].例如<code>.font{ font: normal 700 14px/20px }</code></p><h4 id="了解-font-face"><a href="#了解-font-face" class="headerlink" title="了解@font face"></a>了解@font face</h4><p>@font face 本质上就是一个定义字体和字体集的变量.这个变量不仅仅是简单的自定义字体,还包括字体重命名,默认字体样式设置.它大多用于字体图标技术.所谓字体本质上就是字符集和图形的一种映射关系.字体图标技术通常把字符映射成另外的图标形状,我们看到的图标,本质上就是一个普通的字符.</p><h4 id="文本的控制"><a href="#文本的控制" class="headerlink" title="文本的控制"></a>文本的控制</h4><p>text-indent就是对文本进行缩进控制.项目中我们用的最多的就是给text-indent一个很大的负值来隐藏文本内容.比如很多网站的LOGO放在<code>&lt;h1&gt;</code>中,然后设置一个很大的负值,比如-9999em.</p><p>letter-spacing用来控制与字符的间距.这里的字符包括英文字母,汉字以及空格.支持负值.</p><p>word-spacing用来控制与单词间的间距.<strong>它仅作用于空格而不是字面上的单词</strong>.</p><p>white-space 声明了如何处理元素内的空白字符,normal为合并,pre为不合并,只有在换行符的地方换行.nowrap合并空白但不允许文字环绕.当设置为nowrap时,元素的宽度此时表现为”最大可用宽度”,换行符和一些空格全部合并,文本在一行显示.</p><p><strong>如何解决text-decoration下划线和字体重叠的问题?</strong>可以用兼容性并不好的text-decoration-skip属性,或用box-shadow或background-image模拟,然而最好的解决方式是看似普通却很有用的border属性.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>text-transform是专门为英文字符设计的,要么全部大写<code>text-transform: uppercase</code>,要么全部小写<code>text-transform: lowercase</code>,身份证号的x输入以及验证码的字母大小写都可以使用这个属性实现需求.</p><h3 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h3><ul><li><p>display:none;</p><p>display:none;可以让元素以及所有后代元素都隐藏,占据的空间消失,是真正意义上的隐藏.</p><p>在火狐浏览器下display:none的元素的background-image是不加载的,但是chrome和safari视情况而定,父元素隐藏图片不加载,自身元素隐藏,图片依旧会加载.</p></li><li><p>visibility:hidden;</p><p>与display:none一样可以隐藏元素,但visibility:hidden;保留元素的空间.但他和display:none不一样的是,它具有继承性,父元素设置visibility:hidden;子元素也会看不到,一旦子元素设置visibility:visible;子元素就会显示出来这种后代可见特性在开发中非常有用.</p><p><strong>visibility可以喝transition配合使用,而display不能和transition配合,因为transition的属性有visibility而没有display.</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">td</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.list</span>&#123;</span><br><span class="line">    <span class="attribute">visibility</span>: visible;</span><br><span class="line">    <span class="attribute">transition</span>: visibility <span class="number">0s</span> .<span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>希望元素不可见,不能点击,不占空间,但键盘可访问可以使用<strong>clip: rect(0 0 0 0 )</strong>剪切隐藏.</p></li><li><p>希望元素不可见,不能点击,但占据空间且键盘可访问使用<strong>relative配合负z-index隐藏</strong></p></li><li><p>希望元素不可见,但可以点击,不占空间可以使用<strong>opacity:0;</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在看张鑫旭的&lt;code&gt;&amp;lt;&amp;lt;CSS世界&amp;gt;&amp;gt;&lt;/code&gt;,对里面说的一些干货做了点总结,如果希望看到更多知识,请自行购买.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概论&quot;&gt;&lt;a href=&quot;#概论&quot; clas
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css 前端" scheme="http://yoursite.com/tags/css-%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>初识 TypeScript</title>
    <link href="http://yoursite.com/2018/03/19/%E5%88%9D%E8%AF%86%20TypeScript/"/>
    <id>http://yoursite.com/2018/03/19/初识 TypeScript/</id>
    <published>2018-03-19T11:12:13.000Z</published>
    <updated>2021-08-30T11:13:41.862Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><ul><li>any 任何类型</li><li>number 数字类型</li><li>string 字符串</li><li>boolean 布尔值</li><li>Array 数组 各类型元素相同 例如 any[] 或 Array<any></any></li><li>Tuple 元组 各类型元素不同</li><li>enum 枚举</li><li>void 函数无返回值</li><li>null 空</li><li>undefined 未定义</li><li>never 永远不存在值的类型</li></ul><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><ul><li>自定义类型 type xxx = number | string</li><li>字符串字面量类型 type xxx = ‘click’ | ‘scroll’ …</li></ul><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [变量名] : [类型] = 值;</span><br><span class="line"><span class="keyword">var</span> uname: string = <span class="string">'jack'</span></span><br><span class="line"><span class="keyword">var</span> uname: string;</span><br></pre></td></tr></table></figure><h3 id="类型断言-type-assertion"><a href="#类型断言-type-assertion" class="headerlink" title="类型断言(type assertion)"></a>类型断言(type assertion)</h3><p>类型断言可以手动指定一个值得类型,即允许变量从一种类型更改为另一种类型.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;类型&gt;值</span></span><br><span class="line"><span class="comment">// 或: 值 as 类型</span></span><br><span class="line"><span class="comment">// JSX 中使用 &lt;type&gt; 的断言语法时，这会与 JSX 的语法存在歧义,建议使用 as</span></span><br><span class="line">interface Foo &#123;</span><br><span class="line">  bar: number;</span><br><span class="line">  bas: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125; <span class="keyword">as</span> Foo;</span><br><span class="line">foo.bar = <span class="number">123</span>;</span><br><span class="line">foo.bas = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>当类型没有指定时,TypeScript 编译器会利用类型推断来推断类型.</p><p>如果由于缺乏声明而不能推断出类型,那么它的类型被视作默认的动态 any 类型.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;<span class="comment">//类型推断为 number</span></span><br><span class="line">num = <span class="string">'12'</span>;<span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul><li>全局作用域(全局变量)</li><li>类作用域(类变量,静态变量)</li><li>局部作用域(局部变量)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global_num = <span class="number">12</span> <span class="comment">// 全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Numbers</span> </span>&#123;</span><br><span class="line">    num_val = <span class="number">13</span>; <span class="comment">// 类变量</span></span><br><span class="line"><span class="keyword">static</span> sval = <span class="number">10</span>; <span class="comment">// 静态变量</span></span><br><span class="line">    storeNum(): <span class="keyword">void</span>&#123;</span><br><span class="line"><span class="keyword">var</span> local_num = <span class="number">14</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'全局变量为'</span>+global_num)</span><br><span class="line"><span class="built_in">console</span>.log(Numbers.sval)<span class="comment">//静态变量</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Numbers()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'类变量'</span>+obj.num_val)</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'helloworld'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x:number,y:number</span>): <span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName:string,lastName ?:string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lastName)&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">'bob'</span>) <span class="comment">// 'bob'</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">'bob'</span>,<span class="string">'jack'</span>,<span class="string">'adams'</span>) <span class="comment">// 错误,参数过多</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">'bob'</span>,<span class="string">'jack'</span>) <span class="comment">// bob jack</span></span><br></pre></td></tr></table></figure><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caculate</span>(<span class="params">price:number,rate:number = <span class="number">0.50</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * rate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: string, ...restName:string[]</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + restName.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda-箭头函数"><a href="#lambda-箭头函数" class="headerlink" title="lambda 箭头函数"></a>lambda 箭头函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">x:number</span>) =&gt;</span> <span class="number">10</span> + x</span><br></pre></td></tr></table></figure><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>可以通过管道符<code>|</code>将变量设置多种类型.赋值时可以根据设置的类型来赋值,也可以将联合类型作为函数参数使用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val:string|number</span><br><span class="line">val = <span class="number">12</span></span><br><span class="line">val = <span class="string">'jack'</span></span><br><span class="line"><span class="comment">// 数组联合声明</span></span><br><span class="line"><span class="keyword">var</span> arr:number[] | string[]</span><br></pre></td></tr></table></figure><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>你可以通过<code>&amp;</code>交叉类型从两个对象中创建一个新对象，新对象会拥有着两个对象所有的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="xml"><span class="tag">&lt;<span class="name">T</span> &amp; <span class="attr">U</span>&gt;</span>&#123;&#125;;</span></span><br><span class="line"><span class="xml">  for (let id in first) &#123;</span></span><br><span class="line">    (&lt;T&gt;result)[id] = first[id];</span><br><span class="line">  &#125;</span><br><span class="line">  for (let id in second) &#123;</span><br><span class="line">    if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      (&lt;U&gt;result)[id] = second[id];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const x = extend(&#123; a: 'hello' &#125;, &#123; b: 42 &#125;);</span><br><span class="line"></span><br><span class="line">// 现在 x 拥有了 a 属性与 b 属性</span><br><span class="line">const a = x.a;</span><br><span class="line">const b = x.b;</span><br></pre></td></tr></table></figure><h3 id="TypeScript-接口"><a href="#TypeScript-接口" class="headerlink" title="TypeScript 接口"></a>TypeScript 接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson&#123;</span><br><span class="line">    firstName: string,</span><br><span class="line">    <span class="comment">// 只读属性</span></span><br><span class="line">    readonly lastName:string,</span><br><span class="line">    sayHi: <span class="function"><span class="params">()</span>=&gt;</span>string,</span><br><span class="line">    <span class="comment">// 可选属性</span></span><br><span class="line">    age?:number,</span><br><span class="line">    <span class="comment">//任意属性 其类型必须是其他属性类型的子集, any,null...</span></span><br><span class="line">    [propName:string]: any</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> customer: IPerson = &#123;</span><br><span class="line">    firstName: <span class="string">'Tom'</span>,</span><br><span class="line">    lastName: <span class="string">'Hanks'</span>,</span><br><span class="line">    sayHi: ():<span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数也可以使用 interface</span></span><br><span class="line">interface SearchFunc&#123;</span><br><span class="line">    (source: string, <span class="attr">subString</span>:string):boolean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source:string,subString:string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可索引类型(定义索引类型)</span></span><br><span class="line">interface StringArray&#123;</span><br><span class="line">    [index:number]: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> MyArray : StringArray;</span><br><span class="line">MyArray = [<span class="string">'初春令月'</span>,<span class="string">'气淑风和'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(MyArray[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 接口也可以继承接口</span></span><br><span class="line">interface Shape&#123;</span><br><span class="line">    color: string</span><br><span class="line">&#125;</span><br><span class="line">interface PenStroke&#123;</span><br><span class="line">    penWidth:nubmer</span><br><span class="line">&#125;</span><br><span class="line">interface Square extends Shape,PenStroke&#123;</span><br><span class="line">    sideLength:number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="xml"><span class="tag">&lt;<span class="name">Square</span>&gt;</span>&#123;&#125;;</span></span><br><span class="line"><span class="xml">s.color="blue"</span></span><br><span class="line"><span class="xml">s.penWidth =100</span></span><br><span class="line"><span class="xml">s.sideLength = 10</span></span><br><span class="line"><span class="xml">// 接口还可以继承类</span></span><br><span class="line"><span class="xml">class Point&#123;</span></span><br><span class="line"><span class="xml">    x:number;</span></span><br><span class="line"><span class="xml">    y:number;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">interface Point3d extend Point&#123;</span></span><br><span class="line"><span class="xml">    z:number;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">let point3d : Point3d&#123;</span></span><br><span class="line"><span class="xml">    x:1,</span></span><br><span class="line"><span class="xml">    y:2,</span></span><br><span class="line"><span class="xml">    z:3</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="内联类型注解"><a href="#内联类型注解" class="headerlink" title="内联类型注解"></a>内联类型注解</h5><p>内联类型能为你快速的提供一个类型注解。它可以帮助你省去为类型起名的麻烦,如果多次使用相同的内联注解时，可以考虑把它重构为一个接口.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: &#123;</span><br><span class="line">  first: string;</span><br><span class="line">  second: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">name = &#123;</span><br><span class="line">  first: <span class="string">'John'</span>,</span><br><span class="line">  second: <span class="string">'Doe'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="TypeScript-类"><a href="#TypeScript-类" class="headerlink" title="TypeScript 类"></a>TypeScript 类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="comment">//字段</span></span><br><span class="line">    engine: string;</span><br><span class="line">_name: string;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(engine:string)&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 储存器</span></span><br><span class="line">    get name():string&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">    &#125;</span><br><span class="line">    set name(value:string)&#123;</span><br><span class="line">        <span class="keyword">this</span>._name = value</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line">    disp():<span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"发动机为:"</span> + <span class="keyword">this</span>.engine)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Feature</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> name: string; <span class="comment">// 静态变量或静态方法,不需要实例化,直接通过类调用</span></span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>() <span class="comment">// 调用父类构造函数和方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// private 私有,只能在类中访问</span></span><br><span class="line">    <span class="comment">// protected 受保护,只能在自身以及子类父类访问</span></span><br><span class="line">    <span class="comment">// public(默认) 公有,可以再任何地方被访问</span></span><br><span class="line">    run():<span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'品牌是:'</span>+Feature.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个实例</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Car(<span class="string">'XXSY1'</span>)</span><br><span class="line"><span class="comment">// 抽象类(不允许实例化,但可以被继承,内部方法也可以抽象化)</span></span><br><span class="line">abstrct <span class="class"><span class="keyword">class</span> <span class="title">xxx</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 接口 interface 可以对类的一部分进行抽象.implements(实现)是一个重要概念.不同类之间共有的特性提取为接口用 implements 实现.一个类 可以实现多个接口.</span></span><br><span class="line">interface Light&#123;</span><br><span class="line">    lightOn() <span class="comment">// 开灯</span></span><br><span class="line">    lightOff() <span class="comment">// 关灯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">implements</span> <span class="title">Light</span></span>&#123;</span><br><span class="line">    lightOn() <span class="comment">// 开灯</span></span><br><span class="line">    lightOff() <span class="comment">// 关灯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>TypeScript 文件模块支持commonjs, amd, es modules, others,你可以根据不同的 <code>module</code> 选项来把 TypeScript 编译成不同的 JavaScript 模块类型.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名: SomeInterface.ts</span></span><br><span class="line"><span class="keyword">export</span> interface SomeInterface&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引用</span></span><br><span class="line"><span class="keyword">import</span> &#123;SomeInterfaceRef&#125; <span class="keyword">from</span> <span class="string">'./SomeInterface'</span></span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是在定义函数,接口或类时,不预先指定具体类型,而是在使用时再指定的一种特性.</p><p>使用泛型来创建可重用的组件,一个组件可以支持多种数据类型.这样用户就可以以自己的数据类型来使用组件.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> output = Hello&lt;string&gt;(<span class="string">'helloworld'</span>)<span class="comment">//调用时指定类型</span></span><br><span class="line"><span class="keyword">let</span> output2 = Hello(<span class="string">'helloworld'</span>) <span class="comment">// 或不指定,让类型推论自动推算</span></span><br></pre></td></tr></table></figure><p>泛型约束是在函数内部使用泛型变量时,由于事先不知道它是哪种类型,所以不能随意的操作它的属性和方法,比如 length 属性.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggin</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length)</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型通过接口约束了必须有 length 方法,如果没有编译阶段会报错</span></span><br></pre></td></tr></table></figure><p>接口可以定义函数形状,那么有泛型的接口也可以定义函数形状</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface CreateArrayFunc&lt;T&gt;&#123;</span><br><span class="line">    (length:number,<span class="attr">value</span>:T): <span class="built_in">Array</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类(当实际参数也无法推测出类型时,我们还可以给泛型指定默认参数)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span></span>=string&gt; &#123;</span><br><span class="line">zeroValue: T;</span><br><span class="line">    add: <span class="function">(<span class="params">x:T,y:T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h3><p>如果声明了两个以上的 相同名字的函数,接口或类,那么它们会合并成一个类型.</p><h5 id="函数合并"><a href="#函数合并" class="headerlink" title="函数合并"></a>函数合并</h5><p>我们可以使用函数重载定义多个函数类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x:number</span>):<span class="title">number</span>;</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">reverse</span>(<span class="params">x:string</span>):<span class="title">string</span>;</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">reverse</span>(<span class="params">x:number | string</span>):<span class="title">number</span> | <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> x === <span class="string">'number'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>))</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> x === <span class="string">'string'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接口合并"><a href="#接口合并" class="headerlink" title="接口合并"></a>接口合并</h5><p>接口合并的类型要一致,否则会报错,接口中方法合并和函数合并一样.<strong>类合并和接口合并规则一样</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并后相当于</span></span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="keyword">var</span> jQuery: <span class="function">(<span class="params">selector: string</span>) =&gt;</span> any</span><br><span class="line">jQuery(<span class="string">'#foo'</span>)</span><br><span class="line"><span class="comment">// 我们通常把声明放到一个文件中,比如 jquery.d.ts</span></span><br><span class="line"><span class="comment">// 推荐使用@types 统一管理第三方库的声明文件</span></span><br><span class="line"><span class="comment">// 如果第三方没有提供,需要我们自己书写声明文件</span></span><br><span class="line">declare <span class="keyword">var</span> <span class="comment">// 全局变量</span></span><br><span class="line">declare <span class="function"><span class="keyword">function</span> // 全局函数</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">class</span> // 全局类</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">enum</span> // 全局枚举</span></span><br><span class="line"><span class="function"><span class="title">declare</span> <span class="title">namespace</span> // 全局对象(<span class="params">含子属性</span>)</span></span><br><span class="line"><span class="function"><span class="title">interface</span> // 全局接口</span></span><br><span class="line"><span class="function"><span class="title">type</span> // 全局类型</span></span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>TypeScript 提供了 <code>namespace</code> 关键字用来在确保创建的变量不会泄漏至全局变量中.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace Utility &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">Utility.log(<span class="string">'Call me'</span>);</span><br><span class="line">Utility.error(<span class="string">'maybe'</span>);</span><br></pre></td></tr></table></figure><p><code>namespace</code> 关键字通过 TypeScript 编译后，与我们看到的 JavaScript 代码一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Utility</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加属性至 Utility</span></span><br><span class="line">&#125;)(Utility || Utility = &#123;&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础类型&quot;&gt;&lt;a href=&quot;#基础类型&quot; class=&quot;headerlink&quot; title=&quot;基础类型&quot;&gt;&lt;/a&gt;基础类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;any 任何类型&lt;/li&gt;
&lt;li&gt;number 数字类型&lt;/li&gt;
&lt;li&gt;string 字符串&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://yoursite.com/tags/TypeScript/"/>
    
  </entry>
  
</feed>
