<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>Vite 使用教程 | Mr.喵的网络日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="vite 教程安装12npm init @vitejs/app # npm 安装yatn create @vitejs/app # yarn 安装 特点 热启动快  模块热重载vite 提供一套原生 ESM 的 HMR(即时热更新 hot module replacement) API 实现热重载,无需重新加载页面和应用.  按需编译   Vite 要求项目完全由 es module 模块组成,因">
<meta name="keywords" content="Vite">
<meta property="og:type" content="article">
<meta property="og:title" content="Vite 使用教程">
<meta property="og:url" content="http://yoursite.com/2021/02/22/Vite 使用教程 /index.html">
<meta property="og:site_name" content="Mr.喵的网络日志">
<meta property="og:description" content="vite 教程安装12npm init @vitejs/app # npm 安装yatn create @vitejs/app # yarn 安装 特点 热启动快  模块热重载vite 提供一套原生 ESM 的 HMR(即时热更新 hot module replacement) API 实现热重载,无需重新加载页面和应用.  按需编译   Vite 要求项目完全由 es module 模块组成,因">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2021-08-30T09:54:36.241Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vite 使用教程">
<meta name="twitter:description" content="vite 教程安装12npm init @vitejs/app # npm 安装yatn create @vitejs/app # yarn 安装 特点 热启动快  模块热重载vite 提供一套原生 ESM 的 HMR(即时热更新 hot module replacement) API 实现热重载,无需重新加载页面和应用.  按需编译   Vite 要求项目完全由 es module 模块组成,因">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-Vite 使用教程 " class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/categories">Categories</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Vite 使用教程
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h1 id="vite-教程"><a href="#vite-教程" class="headerlink" title="vite 教程"></a>vite 教程</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init @vitejs/app <span class="comment"># npm 安装</span></span><br><span class="line">yatn create @vitejs/app <span class="comment"># yarn 安装</span></span><br></pre></td></tr></table></figure>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>热启动快</p>
</li>
<li><p>模块热重载<br>vite 提供一套原生 ESM 的 HMR(即时热更新 hot module replacement) API 实现热重载,无需重新加载页面和应用.</p>
</li>
<li><p>按需编译</p>
</li>
</ol>
<p>Vite 要求项目完全由 es module 模块组成,因此不能再生产环境使用,打包依旧由 rollup 打包工具,目前vite 更像是一个类似于 webpack-dev-server 的开发工具.</p>
<h3 id="es-module-和-commonJs"><a href="#es-module-和-commonJs" class="headerlink" title="es module 和 commonJs"></a>es module 和 commonJs</h3><p>es modules 是浏览器支持的一种模块化方案.<br><code>import HelloWorld from &#39;./Helloworld.vue&#39;</code>,当浏览器解析这条语句的时候会往当前域名发送一个请求获取对应的资源.<br>我们平时在 webpack 上写的 esmodule 代码会被打包成 commonJs 的方式运行,所以运行速度较慢.<br>目前 90% 的浏览器都已支持 基于 web 标准的 es module.<br>浏览器对于带有type=”module”的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的defer属性。有多个该标签会依次执行.</p>
<p>CommonJs 是 NodeJs 中的规范,每个模块都有一个 exports 私有变量,exports 指向 module.exports.require 命令可以读入并执行一个 js 文件然后返回该文件的 exports 对象.require 被导出的值的拷贝.commonJs 是动态分析,动态加载.先整体加载模块,再从对象上读取里面的方法,因为只有运行中才能得到对象所以没有办法在静态编译时做静态优化.</p>
<p>esModule 的导入和导出都是声明式的,必须位于模块的顶层作用域,在 es6 代码编译阶段就可以分析模块依赖.通过静态分析未被调用的模块不会被执行和打包,确保模块之间传递的值和接口类型正确.import 导入的模块是只读的,不允许在导入后直接对其修改.如果是一个对象,可以对对象的属性进行修改.由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
<p>不同: cjs 输出的是值拷贝,mjs 输出的是值引用. cjs 是运行时加载,mjs 是编译时记载.cjs 中 this 指向顶层对象,mjs 指向 undefined.</p>
<p>esModule 如果想要动态记载,可以使用 2020 提案中的 import()函数.该函数的参数可以是动态的.与 commonJS 中 require 的区别就是 require 是异步加载,import()是同步加载.加载成功后使用 then 方法从参数中获取模块.</p>
<p>node 要求 es6 模块使用 mjs 后缀,如果不想改后缀需要在 package.json 中加 <code>&#39;type&#39; : &#39;module&#39;</code>,这时 commonjs 需要加 cjs 后缀了.两者尽量不要混用.</p>
<p>esModule 加载路径必须给出脚本的完整路径,不能省略后缀名. 而使用webpack时 由于在<code>resolve.extensions: [&#39;.js&#39;,&#39;.jsx&#39;,&#39;.vue&#39;]</code>配置过,可省略后缀名.而vite可以通过<code>resolve.extensions :[&#39;.mjs&#39;, &#39;.js&#39;, &#39;.ts&#39;, &#39;.jsx&#39;, &#39;.tsx&#39;, &#39;.json&#39;]</code>配置.</p>
<h3 id="webpack-VS-vite"><a href="#webpack-VS-vite" class="headerlink" title="webpack VS vite"></a>webpack VS vite</h3><p>我们经常会遇到我们改动一小行代码,webpack 会耗时数秒来重新打包.因为 webpack 需要将所有模块打包成一个或多个模块.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'a.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;b&#125; <span class="keyword">from</span> <span class="string">'b.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getNumber = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打包成 bundle.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> getNumber = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;getNumber&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们修改一个子模块 bJs,整个 bundleJs 都需要重新打包.随着项目增大,重新打包的时间越来越长.热更新的速度越来越慢.<br>webpack 之所以慢,是因为 webpack 会将很多资源构成一个或多个 bundle.如果跳过打包过程,当需要某个模块的时候再通过请求去获取就完美的解决了这个问题.Vite 做到了.</p>
<h3 id="Vite-实现原理"><a href="#Vite-实现原理" class="headerlink" title="Vite 实现原理"></a>Vite 实现原理</h3><ol>
<li>请求拦截.<br>Vite 的基本原理就是启动一个 node 服务器拦截浏览器请求 es module 的请求,通过 path 找到对应文件做一定的处理,然后以 es module 的方式返回给浏览器.</li>
</ol>
<ol>
<li><p>esbuild.<br>Vite 对 js/ts 的处理没有经过 gulp/rollup 等传统打包工具,而是使用 esbuild,esbuild 是一个全新的 js 打包工具,支持如 babel,压缩等功能,它要比 rollup 等传统工具快上几十倍.原因是它使用了 go 语言作为底层语言.</p>
</li>
<li><p>node_modules 模块的处理<br>当我们在日常开发时引用 node_modules 的时候,我们会这样引用.<code>import vue from &#39;vue&#39;;</code>然后 webpack 等打包工具会帮我们找到模块的路径.<br>但是浏览器只能通过相对路径去找,vite 为了解决这个问题,对其做了一些特殊处理.当浏览器请求<code>vue.js</code>时,请求路径是<code>@modules/vue.js</code>.在 vite 中约定若 path 的请求路径满足<code>/^\/@modules\//</code>格式时,就被认为是 node_modules 模块.那么如何将代码中的<code>vue.js</code>变为<code>/@modules/vue</code> 呢? Vite 对 es module 形式的 js 文件模块处理使用了 Es module lexer 处理, Lexer(词法分析器)会返回 js 文件中导入模块以数组形式返回.然后通过该数组判断是否为一个 node_modules 模块,若是则重写其 path. 然后当浏览器发生 path 为<code>/@modules/xx</code>的对应请求时,会被 Vite 服务端做一层拦截,最终找到对应模块进行返回.<br>Vite 对 script 标签导入的模块也会有对应的处理.</p>
<ol>
<li><p>vue 文件的处理<br>当 Vite 遇到 vue 文件时,它会被拆分成 template,css,script 三个模块进行处理.最后会对 script,template,css 发送多个请求获取.比如 App.vue?type=template 获取 template,type=style 获取 css.</p>
</li>
<li><p>静态文件的加载<br>当请求的路径符合 imageRE,mediaRE,fontsRE 或 JSON 格式时会被认作静态资源.然后处理成 es module 模块返回.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/node/utils/pathUtils.ts</span></span><br><span class="line"><span class="keyword">const</span> imageRE = <span class="regexp">/\.(png|jpe?g|gif|svg|ico|webp)(\?.*)?$/</span></span><br><span class="line"><span class="keyword">const</span> mediaRE = <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span></span><br><span class="line"><span class="keyword">const</span> fontsRE = <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/i</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isStaticAsset = <span class="function">(<span class="params">file: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> imageRE.test(file) || mediaRE.test(file) || fontsRE.test(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HMR(即时热更新 hot module replacement)的原理<br>Vite 的热更新原理就是在客户端和服务端建立了一个 websocket 链接,当代码修改时服务端发送消息通知客户端重新请求信代码,完成更新.</p>
</li>
</ol>
<ul>
<li>服务端原理 websocket</li>
<li>客户端原理<br>vite 在处理 html 时写入 websocket相关代码.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">export</span> <span class="keyword">const</span> clientPublicPath = <span class="string">`/vite/client`</span></span><br><span class="line"><span class="keyword">const</span> devInjectionCode = <span class="string">`\n&lt;script type="module"&gt;import "<span class="subst">$&#123;clientPublicPath&#125;</span>"&lt;/script&gt;\n`</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">rewriteHtml</span>(<span class="params">importer: string, html: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> injectScriptToHtml(html, devInjectionCode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// Listen for messages</span></span><br><span class="line">socket.addEventListener(<span class="string">'message'</span>, <span class="keyword">async</span> (&#123; data &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> payload = <span class="built_in">JSON</span>.parse(data) <span class="keyword">as</span> HMRPayload | MultiUpdatePayload</span><br><span class="line">  <span class="keyword">if</span> (payload.type === <span class="string">'multi'</span>) &#123;</span><br><span class="line">    payload.updates.forEach(handleMessage)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handleMessage(payload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleMessage</span>(<span class="params">payload: HMRPayload</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; path, changeSrcPath, timestamp &#125; = payload <span class="keyword">as</span> UpdatePayload</span><br><span class="line">  <span class="built_in">console</span>.log(path)</span><br><span class="line">  <span class="keyword">switch</span> (payload.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'vue-reload'</span>:</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="Vite-的一些优化"><a href="#Vite-的一些优化" class="headerlink" title="Vite 的一些优化"></a>Vite 的一些优化</h3><p>es module 如果包含相互依赖的话,页面初始化会发送大量请求. Vite 为了优化这个问题,给了一个 optimize 指令.它类似于 webpack 的 dll-plugin 插件,提前将 package.json 中的依赖打包成一个 esmodule 模块,这样在页面初始化就能减少大量请求.</p>
<p>Vite 只是一个用于开发环境的工具,上线仍会打包成一个 commonJs 文件进行调用.</p>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2021/02/22/Vite 使用教程 /" class="article-date">
  <time datetime="2021-02-22T05:39:21.000Z" itemprop="datePublished">2021-02-22</time>
</a>

        </li>
        
          <li>
            <span class="label">Categoría:</span>
            
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端/">前端</a>
  </div>


          </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vite/">Vite</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2021/05/05/读<<国富论>>/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Nuevo</strong>
      <div class="article-nav-title">
        
          读&lt;&lt;国富论&gt;&gt;
        
      </div>
    </a>
  
  
    <a href="/2020/09/29/Vue3 迁移指南/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Viejo</strong>
      <div class="article-nav-title">Vue3 迁移指南</div>
    </a>
  
</nav>


  
</article>






      </div>
      
    <footer id="footer" class="post-footer footer">
      
        <ul class="footer-links">
          
            <li><a href="/archives/"><span class="fa fa-book"></span></a></li>
          
            <li><a href="https://github.com/valenzhou"><span class="fa fa-github-alt"></span></a></li>
          
            <li><a href="https://www.facebook.com/valen.zhou"><span class="fa fa-facebook"></span></a></li>
          
            <li><a href="https://twitter.com/valenzhou/"><span class="fa fa-twitter"></span></a></li>
          
            <li><a href="https://plus.google.com/"><span class="fa fa-google-plus"></span></a></li>
          
            <li><a href="https://www.google.com/"><span class="fa fa-globe"></span></a></li>
          
            <li><a href="/atom.xml"><span class="fa fa-rss"></span></a></li>
          
        </ul>
	    
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>ipsum dolor sit amet, <strong>consectetur adipiscing elit.</strong> Fusce eget urna vitae velit <em>eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque</em> penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Post</p>


      </div>
    </footer>

      



<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
