<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>[阮一峰ES6标准]学习笔记 | Mr.喵的网络日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="let let声明的变量只在代码块内有效 不存在变量提升 let声明变量之前,该变量都是不可用的,称为暂时性死区 相同作用域内不允许重复声明同一个变量  const const声明一个只读的常量,一旦声明,常量的值不能改变. const一旦声明变量,必须初始化,不赋值就会报错. const保证的其实是保存变量的内存地址不得改动.对于简单数据类型,值就保存在变量指向的内存地址,等同于常量.对于复合类">
<meta property="og:type" content="article">
<meta property="og:title" content="[阮一峰ES6标准]学习笔记">
<meta property="og:url" content="http://yoursite.com/2016/03/21/阮一峰ES6标准-学习笔记/index.html">
<meta property="og:site_name" content="Mr.喵的网络日志">
<meta property="og:description" content="let let声明的变量只在代码块内有效 不存在变量提升 let声明变量之前,该变量都是不可用的,称为暂时性死区 相同作用域内不允许重复声明同一个变量  const const声明一个只读的常量,一旦声明,常量的值不能改变. const一旦声明变量,必须初始化,不赋值就会报错. const保证的其实是保存变量的内存地址不得改动.对于简单数据类型,值就保存在变量指向的内存地址,等同于常量.对于复合类">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2017-12-21T02:47:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[阮一峰ES6标准]学习笔记">
<meta name="twitter:description" content="let let声明的变量只在代码块内有效 不存在变量提升 let声明变量之前,该变量都是不可用的,称为暂时性死区 相同作用域内不允许重复声明同一个变量  const const声明一个只读的常量,一旦声明,常量的值不能改变. const一旦声明变量,必须初始化,不赋值就会报错. const保证的其实是保存变量的内存地址不得改动.对于简单数据类型,值就保存在变量指向的内存地址,等同于常量.对于复合类">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-阮一峰ES6标准-学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/categories">Categories</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [阮一峰ES6标准]学习笔记
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul>
<li>let声明的变量只在代码块内有效</li>
<li>不存在变量提升</li>
<li>let声明变量之前,该变量都是不可用的,称为暂时性死区</li>
<li>相同作用域内不允许重复声明同一个变量</li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li>const声明一个只读的常量,一旦声明,常量的值不能改变.</li>
<li>const一旦声明变量,必须初始化,不赋值就会报错.</li>
<li>const保证的其实是保存变量的内存地址不得改动.对于简单数据类型,值就保存在变量指向的内存地址,等同于常量.对于复合类型的数据,变量指向的地址保存的是一个指针.</li>
<li>var和function声明的全局变量,是顶层对象的属性.而let,const,class声明的全局变量不再属于顶层对象.</li>
</ul>
<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><p>从数组和对象中提取值,对变量进行赋值,这就称为解构.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];<span class="comment">//a=1,b=2,c=3</span></span><br><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>] <span class="comment">//解构不成功变量值为undefined</span></span><br></pre></td></tr></table></figure>
<p>如果等号右边不是数组(或不是可遍历的解构),会报错.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a] = <span class="literal">false</span>;<span class="comment">//false不是可遍历解构,报错</span></span><br></pre></td></tr></table></figure>
<p>解构赋值允许指定默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b=<span class="number">666</span>] = [<span class="number">1</span>]<span class="comment">//a=1,b=666</span></span><br></pre></td></tr></table></figure>
<p>对象也可以用于解构赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;foo,bar&#125; = &#123;<span class="attr">foo</span>:<span class="string">'a'</span>,<span class="attr">bar</span>:<span class="string">'b'</span>&#125;;<span class="comment">//foo='a',bar='b'</span></span><br><span class="line"><span class="comment">//属性名相同才能取到值</span></span><br><span class="line"><span class="keyword">let</span> &#123;foo,bar&#125; = &#123;<span class="attr">foo</span>:<span class="string">'a'</span>,<span class="attr">baszz</span>:<span class="string">'b'</span>&#125;;<span class="comment">//bar为undefined</span></span><br><span class="line"><span class="comment">//&#123;foo&#125;其实就是&#123;foo:foo&#125;的简写</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>:bar&#125; = &#123;<span class="attr">foo</span>:<span class="string">'a'</span>&#125;<span class="comment">//bar='a',foo未定义</span></span><br><span class="line"><span class="comment">//对象解构赋值也可以指定默认值</span></span><br><span class="line"><span class="keyword">let</span> &#123;x,y=<span class="number">3</span>&#125;=&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;<span class="comment">//x=1,y=3</span></span><br></pre></td></tr></table></figure>
<p>字符串也可用于解构赋值,因此此时,字符串被转换为一个类似数组的对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c,d,e] = <span class="string">'hello'</span>;<span class="comment">//a='h',b='e'</span></span><br></pre></td></tr></table></figure>
<p>函数的参数也可用于解构赋值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x,y=<span class="number">3</span>]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>,<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><p>ES6为字符串添加了便利器接口,使得字符串可以被for…of循环遍历.</p>
<p>ES5有indexOf用来确定一个字符串是否在另一个字符串中.</p>
<p>ES6又提供了三种方法:</p>
<ul>
<li>includes():返回布尔值,表示是否找到了参数字符串</li>
<li>startsWith():返回布尔值,表示是否在原字符串的头部</li>
<li>endsWith():返回布尔值,表示是否在原字符串的尾部</li>
</ul>
<p>这三个方法都提供了第二个参数,表示搜索的位置.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s =<span class="string">"hello World"</span></span><br><span class="line">s.includes(<span class="string">"hello"</span>)<span class="comment">//true</span></span><br><span class="line">s.startsWith(<span class="string">"hel"</span>)<span class="comment">//true</span></span><br><span class="line">s.endsWith(<span class="string">"rld"</span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>repeat()</strong>方法返回一个新字符串,表示将元字符串重复n次.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>);<span class="comment">//'hellohello'</span></span><br></pre></td></tr></table></figure>
<p>模板字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'world'</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">`hello <span class="subst">$&#123;s&#125;</span> !`</span><span class="comment">//a='hello world !'</span></span><br></pre></td></tr></table></figure>
<p><code>${}</code>里面不仅可以嵌入变量,还可以嵌入函数.</p>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><ul>
<li>Number.isFinite()用来检查一个数值是否为有限的(finite)</li>
<li>Number.isNaN()用来检查一个数值是否为NaN.</li>
<li>上面两个方法与传统的全局方法isFinite()和isNaN()的区别在于,传统方法会先调用Number()将非数值转换为数值在判断,新的两个方法只对数值有效,非数组一律返回false.</li>
<li>Number.parseInt();</li>
<li>Number.parseFloat();将全局方法移植到Number对象上,使语言逐步模块化.</li>
<li>Number.isInteger();用来判断一个值是否为整数.</li>
<li>指数运算符,例如<code>2**3===8;</code></li>
</ul>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><p>函数参数的默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x,y=<span class="string">'world'</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x,y)</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">'hello'</span>)<span class="comment">//hello world</span></span><br><span class="line"><span class="comment">//参数是默认声明的,所以不能用let和const再次声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=<span class="number">5</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;<span class="comment">//error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>;<span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>rest参数</strong></p>
<p>ES6引入rest参数,用于获取函数的多余参数,rest参数搭配的变量是一个数组,该变量将多余的参数放入数组中.rest参数只能是最后一个参数,否则会报错.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">...values</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> val <span class="keyword">of</span> values)&#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>函数的name属性返回该函数的函数名.</p>
<p><strong>箭头函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span>=&gt;</span> v;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span>=&gt;</span><span class="number">5</span>;<span class="comment">//没有参数或多个参数用()包括,多个函数语句用&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>箭头函数内的this是定义时所在的对象,不是使用时的对象</li>
<li>不可以当做构造函数</li>
<li>不可以使用arguments对象</li>
<li>不可以使用yield命令,不能作为Generator函数</li>
<li>箭头函数中的this的指向是固定的,不可变的.</li>
</ul>
<p><strong>尾调用</strong>就是在函数的最后一步调用另外一个函数.</p>
<p><strong>尾递归</strong>函数在最后一步调用自身就是尾递归.尾递归不会发生栈溢出,相对节省内存.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorrial</span>(<span class="params">n,total</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n<span class="number">-1</span>,n*total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数式编程有一个概念,叫做柯里化,意思就是将多参数的函数转换成单参数的函数形式.</p>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><p><strong>扩展运算符</strong>是三个点<code>...</code>.它好比rest参数的逆运算,将一个数组转为用逗号分隔的参数序列.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure>
<p>由于扩展运算符可以展开数组,所以不再需要<code>apply</code>方法将数组转为函数的函数了.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y,z</span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">f.apply(<span class="literal">null</span>,args)</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y,z</span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">f(...args)</span><br></pre></td></tr></table></figure>
<p>扩展运算符的应用</p>
<ul>
<li>复制数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line">cionst a2 = [...a1]</span><br></pre></td></tr></table></figure>
<ul>
<li>合并数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line">arr1.concat(arr2,arr3)</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line">[...arr1,...arr2,...arr3]</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串转为数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">"hello"</span>]<span class="comment">//['h','e','l','l','o']</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只要是有Iterator接口的对象都可以用扩展运算符转为数组.</li>
</ul>
<p><strong>Array.from()</strong>将类似数组的对象和可遍历对象转换为真正的数组.</p>
<p>扩展运算符转换为数组调用的是遍历器接口Iterator,Array.from()不仅可以支持可遍历对象还支持类似数组的对象,既任何拥有length属性的对象都可以通过Array.from转换为数组,而扩展运算符不行.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;<span class="string">'0'</span>:<span class="string">'a'</span>,<span class="string">'1'</span>:<span class="string">'b'</span>,<span class="attr">length</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike)</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike)</span><br></pre></td></tr></table></figure>
<p><strong>Array.of()</strong>用于将一组值转换为数组.因为Array()和new Array(),由于参数不同导致行为不统一.一个参数指定数组的长度,不少于两个才能组成新数组,这样会导致行为有差异.Array.of()基本可以替代Array()和new Array().</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure>
<p><strong>find()</strong>用于找出第一个符合条件的数组成员.他的第一个参数是一个回调函数,所有成员依次执行该函数,直到找到第一个为true的成员,没有找到返回undefined.该回调函数一个接受3个参数,分别是value,index,arr.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">10</span>].find(<span class="function">(<span class="params">n</span>)=&gt;</span>&#123;n&lt;<span class="number">0</span>&#125;)<span class="comment">//-5</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">10</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">v,i,a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span></span><br><span class="line">&#125;)<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p><strong>findIndex()</strong>与find()用法类似,用于找出符合条件成员的索引,都不符合返回-1.由于数组的IndexOf方法无法识别数组的NaN成员,而find和findIndex弥补了数组indexOf的不足.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">10</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">v,i,a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="number">4</span>;<span class="comment">//1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>fill()</strong>填充一个数组.接受第二和第三个参数分别为起始位置和结束位置之前.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>].fill(<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//['a',7,'c']</span></span><br></pre></td></tr></table></figure>
<p><strong>entries(),keys(),values()</strong>都返回一个遍历器对象,可以用for…of进行遍历.entries()是对键值对的遍历,keys()是对键名的遍历,values()是对值得遍历.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>,<span class="string">'b'</span>].keys())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);<span class="comment">//0  //1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数组的includes()</strong>返回一个布尔值表示数组是否包含给定的值,与字符串的includes()方法类似.另外Map和Set数据结构有一个has方法,需要注意与includes区分.Map的has用来查找key,Set的has用来查找value.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].includes(<span class="number">3</span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><p><strong>属性的简写形式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>:x,<span class="attr">y</span>:y&#125;;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;x,y&#125;</span><br></pre></td></tr></table></figure>
<p><strong>属性名表达式</strong></p>
<p>ES6允许字面量定义对象时,用表达式作为对象的属性名.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [name]: <span class="string">'foo'</span>,</span><br><span class="line">  [<span class="string">'a'</span>+<span class="string">'bc'</span>]: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;foo:'foo','abc':123&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.is()</strong>用来比较两个值是否严格相等,与===行为基本一致.<strong>不同之处在于+0不等于-0,NaN等于NaN</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span>;<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>,<span class="number">-0</span>)<span class="comment">//false</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>;<span class="comment">//false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.assign()</strong>用于对象合并,将源对象所有可枚举属性复制到目标对象.</p>
<ul>
<li>如果只有一个参数,直接返回该对象.</li>
<li>同名属性,后者会覆盖前者</li>
<li>Object.assign方法实行的是浅拷贝.如果某个属性的值是对象,那么目标对象拷贝的是这个对象的引用.</li>
</ul>
<p>Object.assign的用途.</p>
<ul>
<li>为对象添加属性</li>
<li>为对象添加方法(将函数放在空对象中)</li>
<li>克隆对象(和一个空对象合并)</li>
</ul>
<p><strong>Object.setPrototypeOf()</strong>设置一个对象的prototype对象,返回参数对象本身,它是ES6整数推荐的设置原型对象的方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> proto = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a,proto);<span class="comment">//a.b === 2</span></span><br><span class="line"><span class="comment">//上面代码将proto对象设置为a对象的原型</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.getPrototypeOf()</strong>用于读取一个对象的原型对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a);<span class="comment">//&#123;b:2&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>super关键字</strong>指向当前对象的原型对象.</p>
<p><strong>Object.keys()</strong>返回一个数组,成员是对象所有可遍历属性的键名.</p>
<p><strong>Object.values()</strong>返回一个数组,成员是对象所有可遍历属性的值.</p>
<p><strong>Object.entries()</strong>返回一个数组,成员是对象所有可遍历属性的键值对数组.</p>
<p><strong>对象也可用于解构赋值以及扩展运算符</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x,...y&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">z</span>:<span class="number">3</span>&#125;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y<span class="comment">// &#123;y:2,z:3&#125;</span></span><br><span class="line"><span class="keyword">let</span> z = &#123;...y&#125;<span class="comment">//&#123;y:2,z:3&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>Null</strong>传导运算符<code>?.</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = (msg &amp;&amp; msg.body&amp;&amp;msg.body.user || <span class="string">'default'</span>)</span><br><span class="line"><span class="comment">//使用null传导运算符</span></span><br><span class="line"><span class="keyword">const</span> first = (msg?.body?.user || <span class="string">'default'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>ES6引入了一种原始数据类型Symbol,表示独一无二的值.它是js第七种数据类型,分别是<code>undefined,null,Boolean,String,Number,Object,Symbol</code></p>
<p>由于symbol不是对象,而是数据类型,所以不能使用new,他是一种类似于字符串的的数据类型.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line">s === s1;<span class="comment">//false,Symbol不能参与运算.</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj[s] = <span class="string">'hello'</span><span class="comment">//Symbol作为属性名不能用.运算形式,且不能被遍历到</span></span><br></pre></td></tr></table></figure>
<h3 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h3><p>ES6提供了新的数据结构Set,它类似于数组,但是成员都是唯一的,没有重复的值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li>Set,prototype.constructor: 构造函数,默认就是Set函数</li>
<li>Set.prototype.size: 返回set实例的成员总数</li>
</ul>
<p>Set的4个操作方法</p>
<ul>
<li>add(value): 添加某个值,返回set结构本身</li>
<li>delete(value):删除某个值,返回一个布尔值,表示是否成功</li>
<li>has(value): 返回一个布尔值,表示是否为Set成员.</li>
<li>clear():清除所有成员.</li>
</ul>
<p>Set的4个遍历方法</p>
<ul>
<li>keys():返回键名的遍历器</li>
<li>values():返回值得遍历器(默认遍历生成函数)</li>
<li>entries():返回键值对的遍历器</li>
<li>forEach():使用回调函数遍历每个成员</li>
</ul>
<p>ES6提供了Map数据类型,类似于对象,但他的”键”的范围不限于字符串,各种类型的值都可以作为键.</p>
<p>Map的实例属性与操作方法:</p>
<ul>
<li>size: Map结构的成员总数</li>
<li>set(key,value):设置键值,返回整个结构</li>
<li>get(key): 读取某个键的值,找不到key返回undefined</li>
<li>has(key):返回布尔值,表示某个键是否在当前Map对象中</li>
<li>delete(key):删除某个键,返回布尔值表示是否成功.</li>
<li>clear():清除所有.</li>
</ul>
<p>Map结构提供的遍历方法与Set相同.</p>
<h3 id="promise对象"><a href="#promise对象" class="headerlink" title="promise对象"></a>promise对象</h3><p>promise是异步编程的一种解决方案.它接受一个函数作为参数,函数有两个参数resolve和reject有js引擎提供,resolve函数将promise有未完成变为成功,reject由未完成变为失败.</p>
<p>promise实例生成后可以用then指定resolved和rejected状态的回调函数,并且then返回一个新的promise实例,所以可以链式调用.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*成功*/</span>)&#123;</span><br><span class="line">      resolve(value)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//success</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//error</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//一般来说,不要再then中定义rejected状态的回调函数,既then的第二个参数,而应该总是使用catch方法.</span></span><br></pre></td></tr></table></figure>
<p>promise.catch是.then(null,rejection)的别名,指定发生错误是的回调函数.</p>
<p>promise.all将多个promise实例包装成一个promise实例.全部成功才成功,有一个失败就是失败.</p>
<p>promise.race将多个promise包装为一个,只要其中有一个先改变状态,整个状态就会改变.</p>
<p>promise.finally方法用于指定不管promise的最后状态无论怎样都会执行,它接受一个普通的回调函数作为参数,不管怎样都必须执行.</p>
<h3 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h3><p>当使用for…of循环某种数据结构时,该循环会自动寻找Iterator接口.</p>
<p>一个对象只要具备Symbol.iterator属性就代表该对象可遍历.</p>
<p>默认调用Iterator接口的场合:</p>
<ul>
<li>解构赋值<code>let [x,y] = [1,2]</code></li>
<li>扩展运算符<code>[...arr]</code></li>
<li>yield<em>后面如果跟的是可遍历结构就会调用遍历器接口`yield\</em> [2,3,4]`</li>
<li>for…of,Array.from()…</li>
</ul>
<p>遍历器对象除了具有next()函数,还要return()和throw()</p>
<p>for..of与其他遍历语法比较.</p>
<ul>
<li>for循环</li>
<li>数组的forEach(无法跳出循环,break,return都不行)</li>
<li>for …in(主要是循环对象而设计,不适用于遍历数组)</li>
<li>for…of,与for..in一样简洁,可以跳出循环…</li>
</ul>
<h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p>Generator是ES6题提供的异步编程解决方案.可以把它理解为一个状态机,封装了多个状态.还是一个遍历器对象生成函数.</p>
<p>Generator函数的特征:function与函数名之间有一个*号,函数体内部使用yield表达式定义不同的内部状态.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorld</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorld();</span><br><span class="line"><span class="comment">//generator函数调用后该函数并不执行,返回的也不是函数运行结果,而是遍历器对象Iterator.然后调用遍历器对象的next方法使得指针移动到下一个状态.</span></span><br><span class="line">hw.next();<span class="comment">//&#123;value:'hello',done:fasle&#125;</span></span><br><span class="line">hw.next();<span class="comment">//&#123;value:'world',done:false&#125;</span></span><br><span class="line">hw.next();<span class="comment">//&#123;value:'ending',done:true&#125;</span></span><br></pre></td></tr></table></figure>
<p>由于Generator函数返回一个遍历器对象,调用next才会遍历下一个内部状态,所以其实他是一个可以暂停执行的函数,yield就是暂停标志.next()遇到yield就会暂停后面的操作,并把yield后面表达式的值作为返回的value值,下一次调用next,再继续执行,知道遇到yield或return为止.另外yield表达式在其他地方使用都会报错.</p>
<p><strong>next()</strong>可以带一个参数,作为上一次yield表达式的返回值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span>*(<span class="keyword">yield</span> (x+<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y/<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x+y+z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next();<span class="comment">//&#123;value:6,done:fasle&#125;</span></span><br><span class="line">a.next();<span class="comment">//&#123;value:NaN,done:fasle&#125;</span></span><br><span class="line">a.next();<span class="comment">//&#123;value:NaN,done:fasle&#125;</span></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next();<span class="comment">//&#123;value:6,done:fasle&#125;</span></span><br><span class="line">b.next(<span class="number">12</span>);<span class="comment">//&#123;value:8,done:fasle&#125;</span></span><br><span class="line">b.next(<span class="number">13</span>);<span class="comment">//&#123;value:42,done:fasle&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>for…of</strong>可以自动遍历Generator函数生成的遍历器对象,并且不再需要调用next方法.但函数return 的值不会再循环中.</p>
<p><strong>在Generator函数中调用Generator函数是没有效果的</strong>,这就需要用到<code>yield*</code>表达式,用来达成以上目的.并且任何数据结构只要有Iterator接口,就可以使用<code>yield*</code>遍历</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h3><p>ES6引入了async函数,使异步操作更加方便.async函数就是Generator函数的语法糖.它将*替换成async,将yield替换成await,仅此而已.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  cosnt f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/a.txt'</span>)</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/b.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span>  readFile(<span class="string">'/etc/a.txt'</span>)</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span>  readFile(<span class="string">'/etc/b.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async对generator的改进</p>
<ul>
<li>内置执行器.async函数的执行与普通函数一样<code>gen()</code></li>
<li>更好的语义.比起*与yield,语义更清楚.</li>
<li>更广的适用性.async函数的await命令后面可以是promise对象和原始类型的值(但此时等同于同步操作).</li>
<li>返回值是promise对象,而generator返回的是一个Iterator遍历器.而async可以看做多个异步操作包装的promise对象,而await命令就是内部then的语法糖.</li>
</ul>
<p><strong>async函数内部return语句返回的值会成为then方法回调函数的参数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'helloWorld'</span></span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span>=&gt;</span><span class="built_in">console</span>,log(v))<span class="comment">//'helloWorld'</span></span><br></pre></td></tr></table></figure>
<p>async函数内部抛出错误会导致promise对象变为reject状态.错误对象会被catch方法回调函数接收.</p>
<p><strong>正常情况下await后面是一个peomise对象,如果不是,会转成一个立即resolve的promise</strong></p>
<p>for await of 用来遍历异步的iterator接口.</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>ES6引入class的概念,作为对象的模板,通过class关键字来定义类.</p>
<p>class其实只是一个语法糖,他的大部分功能ES5都可以做到,只是让对象原型的写法更像面向对象编程语法而已.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x+<span class="string">','</span>+<span class="keyword">this</span>.y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x,y)&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x+<span class="string">','</span>+<span class="keyword">this</span>.y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Point === Point.prototype.constructor<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point();</span><br></pre></td></tr></table></figure>
<p>toString是Point类内部定义的方法,它是不可枚举的,这与ES5不一致.</p>
<p><strong>类不存在变量提升</strong></p>
<p><strong>class的静态方法</strong>,类相当于实例的原型,所有类中定义的方法都会被实例继承,如果在一个方法前加上<code>static</code>关键字就表示该方法不会被实例继承,而是直接通过类来调用,这就成为静态方法.静态方法中的this指的是类而不是实例.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> hello()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'helloWorld'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.hello()<span class="comment">//'helloWorld'</span></span><br><span class="line"><span class="keyword">var</span> h = <span class="keyword">new</span> Foo();</span><br><span class="line">h.hello()<span class="comment">//报错typeError...</span></span><br></pre></td></tr></table></figure>
<p><strong>父的静态方法可以被子类继承</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x,y)&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> hello()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'helloWorld'</span></span><br><span class="line">  &#125;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x,y,z)&#123;</span><br><span class="line">    <span class="keyword">super</span>(x,y)<span class="comment">//调用父类的constructor(x,y)</span></span><br><span class="line">    <span class="keyword">this</span>.z = z;</span><br><span class="line">  &#125;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.z +<span class="string">','</span>+<span class="keyword">super</span>.toString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.hello()<span class="comment">//'helloWorld'</span></span><br></pre></td></tr></table></figure>
<p>super关键字表示父类的构造函数,用来新建父类的this对象.</p>
<p><strong>子类必须在constructor方法中调用super方法,否则新建实例会报错</strong>,这是因为子类没有自己的this对象而是继承父类的this对象,然后对其加工,不调用super()子类就得不到this对象.</p>
<p><strong>如果子类没有定义constructor,这个方法会被默认添加,super也会默认添加</strong>.只要调用super才能使用this关键字.</p>
<h3 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h3><p>修饰器函数用来修改类的行为,是对一个类进行处理的函数,修饰器函数的第一个参数就是说要修身的目标类.如果觉得一个参数不够用,可以再修饰器外再封装一层函数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span>()</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    target.isTest = <span class="literal">true</span>;<span class="comment">//静态属性</span></span><br><span class="line">    target.prototype.isOk = <span class="literal">false</span>;<span class="comment">//实例属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  MyTest.isTest <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>修饰器实在代码编译时发生的,这意味着修饰器本质就是编译时执行的函数.</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>export 用于规定模块的对外接口.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> b = <span class="string">'b'</span></span><br><span class="line"><span class="keyword">export</span> &#123;a,b&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  a,</span><br><span class="line">  b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>import 用于输入其他模块提供的功能.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a,b&#125; <span class="keyword">from</span> <span class="string">'./xxx'</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">as</span> A <span class="keyword">from</span> <span class="string">'./xxx'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> num <span class="keyword">from</span> <span class="string">'./xxx'</span></span><br></pre></td></tr></table></figure>
<p>如果import要取代Node的require方法就形成了障碍,因为require是运行时加载模块,而import无法取代require的动态加载功能.CommonJS输出的是一个值得拷贝,而ES6模块输出的是值得引用.</p>
<p><strong>浏览器加载ES6模块,也使用<code>&lt;script&gt;</code>,但要加入type=’module’属性</strong>告诉浏览器这是一个ES6模块.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2016/03/21/阮一峰ES6标准-学习笔记/" class="article-date">
  <time datetime="2016-03-21T02:43:25.000Z" itemprop="datePublished">2016-03-21</time>
</a>

        </li>
        
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2016/06/08/深入理解Git-工作流/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          深入理解Git 工作流
        
      </div>
    </a>
  
  
    <a href="/2015/10/29/深圳大梅沙看海/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">深圳大梅沙看海</div>
    </a>
  
</nav>


  
</article>






      </div>
      
    <footer id="footer" class="post-footer footer">
      
        <ul class="footer-links">
          
            <li><a href="/archives/"><span class="fa fa-book"></span></a></li>
          
            <li><a href="https://github.com/valenzhou"><span class="fa fa-github-alt"></span></a></li>
          
            <li><a href="https://www.facebook.com/valen.zhou"><span class="fa fa-facebook"></span></a></li>
          
            <li><a href="https://twitter.com/valenzhou/"><span class="fa fa-twitter"></span></a></li>
          
            <li><a href="https://plus.google.com/"><span class="fa fa-google-plus"></span></a></li>
          
            <li><a href="https://www.google.com/"><span class="fa fa-globe"></span></a></li>
          
            <li><a href="/atom.xml"><span class="fa fa-rss"></span></a></li>
          
        </ul>
	    
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>ipsum dolor sit amet, <strong>consectetur adipiscing elit.</strong> Fusce eget urna vitae velit <em>eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque</em> penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Post</p>


      </div>
    </footer>

      



<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
