<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>JS 函数式编程指南 | Mr.喵的网络日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JavaScript 函数式编程第一章 走进函数式 例子1234567891011121314document.querySelector(&quot;#msg&quot;).innerHTML = &apos;&amp;lt;h1&amp;gt;hello world&amp;lt;/h1&amp;gt;&apos;;// 用函数封装这段代码function printMessage(elementId,format,message)&amp;#123;	document.">
<meta name="keywords" content="JavaScript 函数式编程">
<meta property="og:type" content="article">
<meta property="og:title" content="JS 函数式编程指南">
<meta property="og:url" content="http://yoursite.com/2020/06/16/JS 函数式编程指南/index.html">
<meta property="og:site_name" content="Mr.喵的网络日志">
<meta property="og:description" content="JavaScript 函数式编程第一章 走进函数式 例子1234567891011121314document.querySelector(&quot;#msg&quot;).innerHTML = &apos;&amp;lt;h1&amp;gt;hello world&amp;lt;/h1&amp;gt;&apos;;// 用函数封装这段代码function printMessage(elementId,format,message)&amp;#123;	document.">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2021-08-30T09:51:01.505Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS 函数式编程指南">
<meta name="twitter:description" content="JavaScript 函数式编程第一章 走进函数式 例子1234567891011121314document.querySelector(&quot;#msg&quot;).innerHTML = &apos;&amp;lt;h1&amp;gt;hello world&amp;lt;/h1&amp;gt;&apos;;// 用函数封装这段代码function printMessage(elementId,format,message)&amp;#123;	document.">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  
</head>

  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-JS 函数式编程指南" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/categories">Categories</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JS 函数式编程指南
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h1 id="JavaScript-函数式编程"><a href="#JavaScript-函数式编程" class="headerlink" title="JavaScript 函数式编程"></a>JavaScript 函数式编程</h1><h3 id="第一章-走进函数式"><a href="#第一章-走进函数式" class="headerlink" title="第一章 走进函数式"></a>第一章 走进函数式</h3><ol>
<li>例子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#msg"</span>).innerHTML = <span class="string">'&lt;h1&gt;hello world&lt;/h1&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用函数封装这段代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMessage</span>(<span class="params">elementId,format,message</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;elementId&#125;</span>`</span>).innerHTML = <span class="string">`&lt;<span class="subst">$&#123;format&#125;</span>&gt;<span class="subst">$&#123;message&#125;</span>&lt;/<span class="subst">$&#123;format&#125;</span>&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line">printMessage(<span class="string">'msg'</span>,<span class="string">'h1'</span>,<span class="string">'hello world'</span>);</span><br><span class="line"><span class="comment">// 以上仍然不是一段可复用的代码,用函数式编程如下</span></span><br><span class="line"><span class="keyword">var</span> printMessage = run(addToDom(<span class="string">'msg'</span>),h1,echo);</span><br><span class="line">printMessage(<span class="string">'hello world'</span>);</span><br><span class="line"><span class="comment">// 将程序分解为多个函数,再将他们组合起来完成一系列的操作.</span></span><br><span class="line"><span class="comment">// 当需求更改为在控制台打印 3 遍文本信息,就可以改为一下代码</span></span><br><span class="line"><span class="keyword">var</span> printMessage = run(<span class="built_in">console</span>.log,repeat(<span class="number">3</span>),echo);</span><br><span class="line">printMessage(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>函数式编程的特征: 声明式编程,纯函数,引用透明,不可变性.</p>
<ol>
<li>声明式编程<br>目前更主流的是命令式编程和面向对象编程.我们来看一个命令式的例子.假设你需要计算一个数组中所有数的平方.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">	array[i] = <span class="built_in">Math</span>.pow(array[i],<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">array; <span class="comment">// [0,1,4,9,16]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>命令式编程是很具体的告诉计算机如何执行某个任务.而声明式编程是将程序的描述和求值分离开来.它关注与如何使用各种表达式来描述程序逻辑.你可以在 SQL 语句中找到声明式编程的例子.<br>可以将 es6 的 lambda 表达式和箭头函数将循环抽象成函数,减少代码的书写.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].map(<span class="function"><span class="params">num</span> =&gt;</span> <span class="built_in">Math</span>.pow(num,<span class="number">2</span>));  <span class="comment">// [0,1,4,9,16]</span></span><br></pre></td></tr></table></figure></p>
<p>为什么要去掉代码循环?因为循环是命令控制结构,很难重用,并且很难插入其他操作中.并且要尽量做到无副作用无状态变化,既纯函数.</p>
<ol>
<li>副作用带来的问题和纯函数<br>函数式编程基于一个前提,既使用纯函数构建具有不变形的程序.考虑以下函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ++counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上函数不是一个纯函数,它在读取外部资源时会产生副作用.还有一个例子 Date.now,它的输出是不可预见和不一致的.<br>另一个副作用是通过 this 关键字访问实例数据时,由于 js 语言的特性,它决定了一个函数在运行时的上下文,这往往导致很难去推理代码.<br>以下行为都可能导致副作用:</p>
<pre><code>- 改变一个全局的变量,属性,或数据结构
- 改变一个函数参数的原始值
- 处理用户输入
- 抛出异常又被当前函数捕获
- 屏幕打印或记录日志
- 查询 html 文档,浏览器数据或访问数据库
</code></pre><p>以下案例是一个命令式程序,它听过 SSN 号码找到一个学生的记录渲染到页面上.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showStudent</span>(<span class="params">ssn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> student = db.get(ssn);</span><br><span class="line">	<span class="keyword">if</span>(student != <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;elementId&#125;</span>`</span>).innerHTML = <span class="string">`<span class="subst">$&#123;student.ssn&#125;</span> - <span class="subst">$&#123;student.name&#125;</span>`</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Erroe(<span class="string">'student not found!'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">showStudent(<span class="string">'444-44-4444'</span>);</span><br></pre></td></tr></table></figure></p>
<p>该函数副作用有: 访问外部数据 db,全局变量 elementId 可能随时会改变,直接修改可外部共享的全局资源 html,抛出的异常会导致整个程序栈回退并结束.<br>如何使用函数式编程应对这种情况呢? 首先将长函数分离成多个且单一的短函数,其次通过显式的将外部依赖都定义为函数参数来减少副作用.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> find = curry(<span class="function"><span class="keyword">function</span>(<span class="params">db,id</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = db.get(id);</span><br><span class="line">	<span class="keyword">if</span>(obj === <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'object is not found'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> csv = (student)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;student.ssn&#125;</span> - <span class="subst">$&#123;student.name&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> append = curry(<span class="function"><span class="keyword">function</span>(<span class="params">elementId,info</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.querySelector(elementId).innerHTML = info;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用以上函数</span></span><br><span class="line"><span class="keyword">var</span> student = run(append(<span class="string">'#student'</span>),csv,find(db));</span><br><span class="line">student(<span class="string">'444-44-4444'</span>);</span><br></pre></td></tr></table></figure>
<p>这个程序仍然有些问题,find 函数有一个检查 null 的分支.当一个函数能够确保有相同的返回值,它使得函数的结果一致且可预测,这就是纯函数的一个特质,引用透明.</p>
<ol>
<li>引用透明和可置换性<br>如果一个函数对于相同的输入始终产生相同的结果,它就是引用透明的.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> increment = <span class="function"><span class="params">counter</span> =&gt;</span> counter + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>它不仅能使代码易于测试,还更容易推理整个程序.</p>
<ol>
<li>储存不可变数据<br>不可变数据指那些创建后不能更改的数据,js 的所有基本类型本质上不可变,但数组或对象都是可变的.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortDesc = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b-a;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">sortDesc(arr);<span class="comment">// [4,3,2,1]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>乍一看这段代码正常,但是 array.sort 函数是有状态的,会导致排序过程中产生副作用,因为原始的引用被修改了.</p>
<ol>
<li>总结<br>函数式编程是指为创建不可变程序,通过消除外部可见的副作用,来对纯函数的声明式求值过程.</li>
</ol>
<h3 id="第二章-高阶-JavaScript"><a href="#第二章-高阶-JavaScript" class="headerlink" title="第二章 高阶 JavaScript"></a>第二章 高阶 JavaScript</h3><ol>
<li>一等函数<br>函数是函数式编程的工作单元和中心,函数只有在返回一个有价值的结果(而不是 null和 undefined)时才有意义.同时,我们需要区分表达式(返回一个值的函数)与语句(不返回值得函数).函数式编程完全依赖表达式,无值函数在函数式编程下没有意义.<br>在 js 中,任何函数都是 Function 类型的一个实例,函数 length 属性可以获取形参的长度,apply 和 call 可以调用函数并加入上下文,不同的是 apply 函数接收一个参数数组,而 call 接收一系列参数.但函数式编程不建议这样做,因为它永远不会依赖于函数的上下文状态.</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个函数,接受一个函数参数,并返回取反其结果的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">negate</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> !(func.apply(<span class="literal">null</span>,<span class="built_in">arguments</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNull</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val === <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isNotNull = negate(isNull);</span><br><span class="line">isNotNull(<span class="literal">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ol>
<li>闭包和作用域<br>在 js 之前闭包只存在于函数式编程语言中,js 是第一个在主流开发中应用闭包的语言.<br>闭包是一种能后在函数声明过程中将环境信息和所属函数绑定在一起的数据结构.从本质上讲,闭包就是函数继承而来的作用域.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAddFunction</span>(<span class="params">amount</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// add 函数可以通过词法作用域访问 amount</span></span><br><span class="line">		<span class="keyword">return</span> number + amount;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> addTenTo = makeAddFunction(<span class="number">10</span>);</span><br><span class="line">addTenTo(<span class="number">1</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>闭包会在其声明时记住其作用域内的所有变量,并防止他们被垃圾回收机制回收.<br>js 的作用域分为全局作用域,函数作用域,伪块作用域.</p>
<pre><code>- 全局作用域,window 或 global,会有副作用,尽量避免使用
- 函数作用域,可以嵌套,由内而外向上查找,直到全局作用域,推荐使用.
- 伪块作用域,如 for,while,id,switch 语句,with,try..catch..等.无法从块外部访问
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dowork</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!myVar)&#123;</span><br><span class="line">		<span class="keyword">var</span> myVar = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(myVar); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>js 有一个内部机制,将所有变量和函数提取至作用域的顶部.<br>es6 提供了 let,const 等关键字定义的变量不会进行提升.</p>
<ol>
<li>闭包的实际应用</li>
</ol>
<p><strong>模拟私有变量</strong><br>js 并没有一个 private 修饰符来限定对象中私有变量和函数的访问,我们可以使用闭包来完成.<br>闭包还可以管理全局的命名空间,既模块模式,它采用立即执行函数表达式IIFE,在 封装内部变量的同时,有效减少了全局引用.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个模块框架的示例</span></span><br><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params">export</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 给 IIFE 一个名字方便栈追踪</span></span><br><span class="line">	<span class="keyword">let</span> _myprivateVar = ...;<span class="comment">//无法从外部访问这个变量,但对内的方法可以访问.</span></span><br><span class="line">	<span class="keyword">export</span>.method1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">export</span>.method2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">export</span>;</span><br><span class="line">&#125;(myModule || &#123;&#125;));</span><br></pre></td></tr></table></figure></p>
<p>对象 myModule 在全局作用域创建,之后传递给一个 IIFE 函数表达式并立即执行.由于 js 的函数作用域,变量_myprivateVar 和其他变量都是函数的局部变量,闭包使得返回的对象能够安全的访问模块中的所有内部属性.</p>
<p><strong>异步服务端调用</strong></p>
<p>js 中的函数可以作为回调函数传递给其他函数,假设需要对服务器发起一次请求,并在响应时得到通知,常用的方式就是提供一个回调函数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJson(<span class="string">'/student'</span>,(student) =&gt;&#123;</span><br><span class="line">	getJson(<span class="string">'/students/grades'</span>,</span><br><span class="line">		grades =&gt; processGrades(grades),</span><br><span class="line">		error =&gt; <span class="built_in">console</span>.log(error)),</span><br><span class="line">	error =&gt; <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>getJson 是一个高阶函数,它接收两个回调作为参数,一个处理成功的函数,一个处理失败的函数.如果需要多次请求很容易进入回调地狱.</p>
<h3 id="第三章-轻数据结构-重操作"><a href="#第三章-轻数据结构-重操作" class="headerlink" title="第三章 轻数据结构,重操作"></a>第三章 轻数据结构,重操作</h3><ol>
<li><p>理解程序的控制流<br>程序为实现业务目标进行的路径就是控制流.命令式程序需要通过暴露所有的必要步骤才能详细的描述其控制流,这里面通常涉及大量的循环和分支以及各种变量.然而函数式程序多使用简单拓扑链接的黑盒操作组合成较小的程序化控制流,这些链接在一起的操作只是一些能够将状态传递给下一个操作的高阶函数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opta().optb().optc()... <span class="comment">// 链式结构</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>链接方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'function programing'</span>.substring(<span class="number">0</span>,<span class="number">10</span>).toLowerCase() + <span class="string">'is fun'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过一系列变换后的结果与原字符串毫无引用关系,无副作用.如果用更加函数式的写法如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(toLowerCase(subString(<span class="string">'function programing'</span>,<span class="number">1</span>,<span class="number">10</span>)),<span class="string">'is fun'</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样虽然跟复合函数式的定义,但是较难阅读,需要一层层剥离外部函数,就行剥离洋葱一样.</p>
<ol>
<li>函数链<br>面向对象将继承作为代码重用的主要手段,比如在 java 中有继承与基础接口 List 的 ArrayList,LinkedLise 等.<br>但在函数式编程中是使用如数组这样的普通类型并施加在一套高阶操作上,通常接收函数作为参数,减少副作用等等.</li>
</ol>
<p>lambda 表达式,也被称为箭头函数.源自函数式编程,可以用较简介的语法声明一个匿名函数.它总是返回一个值.且能够与 map,reduce 等高阶函数配合使用.我们在接下来用 lodash 函数库来演示,它为了能够替换 underscore 采用了和它一样的 API.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 map 做数据变换</span></span><br><span class="line">_.map([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],v=&gt; <span class="number">2</span>*v); <span class="comment">//2,4,6</span></span><br></pre></td></tr></table></figure>
<p>我们不需要再写循环的代码,也不用处理奇怪的作用域问题了.由于其不可变,因此输出一个全新的数组.<br>函数式库可以辅助我们开发,写出纯函数式的代码.<br>map是一个只会从左到右遍历的操作,对应重右到左遍历必须反转数组,但 js 中的 Array.reverse() 会改变原数组,所以我们可以配合 lodash 中的 reverse 配合 map 进行操作.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).reverse().map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="number">2</span>*v); <span class="comment">// 6,4,2</span></span><br></pre></td></tr></table></figure></p>
<p>高阶函数 reduce 将一个数组中的元素精简为一个值,该值是每个元素累计而得.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).reduce( <span class="function">(<span class="params">memo,v</span>) =&gt;</span> memo+v,<span class="number">0</span> )</span><br></pre></td></tr></table></figure></p>
<p>除此之外,lodash 还提供了 every,some,filter 等辅助函数.</p>
<ol>
<li>代码推理<br>函数式编程中每个函数只完成一部分功能,但组合在一起就可以解决很多问题,下面介绍一种能够连接一组函数来构建程序的方法(声明式惰性计算函数链).<br>假设需要对一组姓名进行读取,去重,排序等操作,命令式代码如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names =[<span class="string">'alozno church'</span>,<span class="string">'Jaskell cjrl'</span>,<span class="string">'Terjdf'</span>,<span class="string">'asdfgg'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleName</span>(<span class="params">names</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = []</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;names.length;i++)&#123; <span class="comment">// 遍历数组</span></span><br><span class="line">		<span class="keyword">var</span> n = names[i]</span><br><span class="line">		<span class="keyword">if</span>(n !== <span class="literal">null</span> &amp;&amp; n !== <span class="literal">undefined</span>)&#123; <span class="comment">// 检查是否合法</span></span><br><span class="line">			<span class="keyword">var</span> ns = n.replace(<span class="regexp">/_/</span>,<span class="string">' '</span>).split(<span class="string">' '</span>) <span class="comment">// 规范数据</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt; ns.length;j++)&#123;</span><br><span class="line">				<span class="keyword">var</span> p = ns[j] <span class="comment">// 处理数据</span></span><br><span class="line">				p = p.charAt(<span class="number">0</span>).toUpperCase() + p.slice(<span class="number">1</span>);</span><br><span class="line">				ns[j] = p;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (result.indexOf(ns.join(<span class="string">' '</span>))&lt; <span class="number">0</span>) &#123; <span class="comment">// 去除重复元素</span></span><br><span class="line">				result.push(ns.join(<span class="string">' '</span>)) </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	result.sort(); <span class="comment">// 数组排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>用函数式代码实现如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.chain(names)  <span class="comment">// 初始化函数链</span></span><br><span class="line">	.filter(isValid) <span class="comment">// 去除非法值</span></span><br><span class="line">	.map(<span class="function"><span class="params">s</span> =&gt;</span> s.replace(<span class="regexp">/_/</span>,<span class="string">' '</span>)) <span class="comment">// 规范数据</span></span><br><span class="line">	.uniq() <span class="comment">// 去重</span></span><br><span class="line">	.map(_.startCase) <span class="comment">// 大写首字母</span></span><br><span class="line">	.sort() <span class="comment">// 排序</span></span><br><span class="line">	.value(); <span class="comment">// 返回封装对象的最终值</span></span><br></pre></td></tr></table></figure></p>
<p>对一个对象使用 chain 方法会封装这个对象,并之后的每次方法调用都返回这个封装的对象,当完成计算使用 value()函数取得最终值.<strong>使用 chain 链式调用的好处是可以创建具有惰性计算能力的复杂程序,在调用 value()之前并不会真正的执行任何操作.</strong> 链中的每个函数都以一种不可变的方式来处理换上一个函数构建的新数组.这有助于过渡到 point-free 编程风格的理解.</p>
<p>类 SQL 的数据:函数即数据.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p.firstname,p.birthYear <span class="keyword">from</span> person <span class="keyword">where</span> p.birthYear &gt; <span class="number">1903</span> <span class="keyword">and</span> p.country <span class="keyword">IS</span> <span class="keyword">Not</span> <span class="string">'US'</span></span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> p.firstname,p.birthYear</span><br></pre></td></tr></table></figure></p>
<p>lodash 支持一种称为 mixins 的函数,可以为核心库拓展新的函数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_.mixin(&#123;</span><br><span class="line">	<span class="string">'select'</span> : _.pluck,</span><br><span class="line">	<span class="string">'from'</span>: _.chain,</span><br><span class="line">	<span class="string">'where'</span>: _.filter,</span><br><span class="line">	<span class="string">'groupBy'</span>: _.sortByOrder</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>应用此 mixin 对象后就可以编写类 sql 的程序<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.from(persons)</span><br><span class="line">	.where(<span class="function"><span class="params">p</span> =&gt;</span> p.birthYear &gt; <span class="number">1903</span> &amp;&amp; p.country !== <span class="string">'US'</span>)</span><br><span class="line">	.groupBy([<span class="string">'firstname'</span>,<span class="string">'birthYear'</span>])</span><br><span class="line">	.select(<span class="string">'firstname'</span>,<span class="string">'birthYear'</span>)</span><br><span class="line">	.value();</span><br></pre></td></tr></table></figure></p>
<ol>
<li>递归<br>递归是一种通过将问题分解为较小的自相似问题来解决问题本身的技术,递归函数主要包含两方面,一是终止条件,二是递归条件.<br>来解决一个简单的问题,对数组中所有的值进行求和.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老规矩,先命令式,再函数式.</span></span><br><span class="line"><span class="keyword">var</span> acc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">	acc += nums[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数式</span></span><br><span class="line">_(nums).reduce(<span class="function">(<span class="params">acc,current</span>) =&gt;</span> acc + current, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>递归和迭代是一个硬币的两面,在不可变条件下递归提供了一种更强大的迭代替代方法.纯函数式语言甚至没有标准的循环结构,如 for,while 等,因为所有循环都是递归完成的.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归求和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(_.isEmpty(arr))&#123; <span class="comment">// 终止条件</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _.first(arr) + sum(_.rest(arr)); <span class="comment">// 递归条件</span></span><br><span class="line">&#125;</span><br><span class="line">sum([]); <span class="comment">// 0</span></span><br><span class="line">sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>从底层看,递归调用会在栈中不断堆叠,但算法满足终止条件时,运行时会展开调用栈并执行加操作,因此所有返回语句都将被执行,递归就是通过这种机制代替循环.但是注意编译器在处理循环的优化问题是很强大的,比如 es6 带来了<strong>尾调用优化</strong>,可以使递归和迭代的性能更加接近.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">arr,acc=<span class="number">0</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(_.isEmpty(arr))&#123; <span class="comment">// 终止条件</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum(_.rest(arr),acc+_.first(arr));<span class="comment">//发生在尾部的递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 我们之前已经利用函数式技术解析过一些扁平化数据,比如数组.但这些操作对树形数据结构是无效的.<br> 因为 js 没有内置的树形对象,所以需要基于节点,创建一种简单的数据结构.节点包括当前值,父节点引用,以及子节点数组的对象.<br> 树是包含了一个根节点的递归定义的数据结构.<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(root)&#123;</span><br><span class="line">		<span class="keyword">this</span>._root = root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> map(node,fn,tree = <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="comment">// 使用静态方法避免与 Array.prototype.map 混淆</span></span><br><span class="line">		node.value = fn(node.value);</span><br><span class="line">		<span class="keyword">if</span>(tree === <span class="literal">null</span>)&#123;</span><br><span class="line">			tree = <span class="keyword">new</span> Tree(node);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(node.hasChildren())&#123;</span><br><span class="line">			_.map(node.children,<span class="function"><span class="keyword">function</span>(<span class="params">child</span>)</span>&#123;</span><br><span class="line">				Tree.map(child,fn,tree);</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tree;</span><br><span class="line">	&#125;</span><br><span class="line">	get root()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>._root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="第四章-模块化且可重用的代码"><a href="#第四章-模块化且可重用的代码" class="headerlink" title="第四章 模块化且可重用的代码"></a>第四章 模块化且可重用的代码</h3><p>Unix  的脚本程序的编写如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr <span class="string">'A-Z'</span> <span class="string">'a-z'</span> &lt; words.in | uniq | sort</span><br></pre></td></tr></table></figure></p>
<p>这行代码对字符进行可一系列的变换,大小写转换,去除排序等.管道操作符 | 用于连接这些命令.</p>
<ol>
<li>方法链接函数管道的比较<br>在 Haskell 中私有一种符号<code>::</code>来描述函数,如下:<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;function-name&gt; :: &lt;<span class="type">Input</span>*&gt; -&gt; &lt;output&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在函数式编程中,函数是输入和输出类型之间的数学映射.如 isEmpty 函数接收一个字符串并返回一个布尔值,使用该符号表示为:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// haskell 描述</span></span><br><span class="line">isEmpty :: <span class="built_in">String</span> -&gt; <span class="built_in">Boolean</span></span><br><span class="line"><span class="comment">// js lambda 描述</span></span><br><span class="line"><span class="keyword">const</span> isEmpty = <span class="function"><span class="params">s</span> =&gt;</span> !s || !s.trim();</span><br></pre></td></tr></table></figure></p>
<p>链式调用<code>xxx.xxx().xxx()</code>虽然相比命令式代码提高了可读性,但是它与方法所属对象耦合在一起,只能使用由 Lodash 提供的操作,无法将不同函数库或自定义函数链接在一起.<br>而管道是松散结合的有向函数序列,一个函数的输出会作为下一个函数的输入.</p>
<ol>
<li>管道函数的兼容条件</li>
</ol>
<ul>
<li>类型: 函数的返回类型必须与接收函数的参数类型相匹配.</li>
<li>元数: 接收函数必须声明至少一个参数才能处理上一个函数的返回值.函数的参数长度和其复杂度成正比,只有一个单一参数的纯函数是最简单的,建议使用.但如何返回两个不同的值呢,函数式语言通过一个被称为元祖的类型达成.元组是不可变结构,将不同数据类型元素打包在一起,以便传递到其他函数中.如<code>(false,&#39;error message&#39;)</code>.但 js 并不原生的支持 tuple 类型,在 es6 的解构赋值特性下可以简明的键元祖值映射到变量中.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[first,last] = [<span class="literal">false</span>,<span class="string">'error message'</span>];</span><br><span class="line">first <span class="comment">// false</span></span><br><span class="line">last <span class="comment">// error message</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>元祖是减少函数元数的方式之一,但还可以引入函数柯里化来实现降低元数的同时,增强代码模块化和可重用性.</p>
<ol>
<li>柯里化的函数求值<br>js 允许在确实产生的情况下对常规或非柯里化函数进行调用,js 会将缺少的参数设置为 undefined ,这或许也是 js 并不原生支持柯里化的原因.如果不设置行参,仅仅依靠 arguments 对象问题会更糟糕.<br>再看柯里化函数,它要求所有参数都被明确定义,当使用部分参数调用时,它会返回一个新的函数,在真正运行之前等待外部提供剩余参数.柯里化是一种在所有参数提供之前,挂起或延迟函数执行,将多参函数转换为一元函数序列的技术.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具有三个参数的柯里化定义</span></span><br><span class="line">curry(f) :: (a,b,c) -&gt; f(a) -&gt; f(b) -&gt; f(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> y =&gt; <span class="function"><span class="params">z</span> =&gt;</span> x + y + z;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上代码表明,curry 是一种从函数到函数的映射,将输入(a,b,c)分解为多个分离的单参数调用.<br>在纯函数式语言中,柯里化是原生特性,是任何函数定义中的组成部分.由于 js 不支持自动柯里化函数,需要编写一些代码来启用它.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二元参数的手动柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry2</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">firstArg</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">secondArg</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> fn(firstArg,sencondArg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示,柯里化是一种词法作用域(闭包),其返回的函数只不过是一个接受后续参数的简单嵌套函数包装器.<br>像 lodash 一样,ramda.js 是一个函数式编程辅助库,之所以使用它是因为它很容易实现参数柯里化,惰性应用,和函数组合.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> checkType = curry2(<span class="function"><span class="keyword">function</span>(<span class="params">typeDef,actualType</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(R.is(typeDef,actualType))&#123;</span><br><span class="line">		<span class="comment">// 使用 ramda 中 is()检查类型信息</span></span><br><span class="line">		<span class="keyword">return</span> actualType;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'type  mismatch'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">checkType(<span class="built_in">String</span>)(<span class="string">'Curry'</span>); <span class="comment">// String</span></span><br><span class="line">checkType(<span class="built_in">String</span>)(<span class="number">42</span>); <span class="comment">// type  mismatch</span></span><br></pre></td></tr></table></figure></p>
<p>通过 R.curry 或 lodash 的curry 可以对任意数量参数的函数进行自动的柯里化.可以将自动柯里化想象为基于声明参数的数量而人工创建对应嵌套函数作用域的过程.</p>
<ol>
<li>部分应用(partial 偏函数)和函数绑定<br>部分应用是一种通过将函数的不可变参数子集初始化为固定值来创建更小元数函数的操作.简单说就是,如果存在一个具有五个参数的函数,给出三个参数后就会得到一个具有两个参数的函数.柯里化的函数本质上也是部分应用的函数.他们主要的区别在于参数传递的内部机制和控制.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//体积计算函数的部分应用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">volume</span>(<span class="params">l</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">w, h</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l * w * h</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>柯里化在每次分布调用时都会生成嵌套的一元函数,在底层函数的最终结果由这些一元函数逐步组合产生,所以可以完全控制函数求值的时间和方式.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partial 的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> fn = <span class="keyword">this</span>, boundArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">	<span class="keyword">let</span> placeholder = &lt;&lt;partialPlaceholderObj&gt;&gt; // 占位符,lodash 使用下划线对象作为占位符,其他实现使用 undefined 来表示应略过该参数</span><br><span class="line">	let bound = function()&#123;</span><br><span class="line">		// 使用部分参数创建新函数</span><br><span class="line">		let position = 0,length= args.length;</span><br><span class="line">		let args = Array(length);</span><br><span class="line">		for(let i=0;i&lt; length;i++)&#123;</span><br><span class="line">			args[i] = boundArgs[i] === placeholder ? arguments[position++]: boundArgs[i]</span><br><span class="line">		&#125;</span><br><span class="line">		while(positoion &lt; arguments.length)&#123;</span><br><span class="line">			args.push(arguments[positoion++])</span><br><span class="line">		&#125;</span><br><span class="line">		return fn.apple(this,args)</span><br><span class="line">	&#125;</span><br><span class="line">	return bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>部分应用将函数的参数与一些预设值绑定(赋值),从而产生一个拥有更少参数的新函数.该函数的闭包中包含这些已经赋值的参数,在之后的调用中完全被求值.一种类似的 js 原生技术被称为函数绑定,即 Function.prototype.bind()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.partial(finc,[params...])</span><br><span class="line"><span class="comment">// 创建一个函数,该函数会调用 func,并传入预设的参数,与 _.bind 不同的是,它不会绑定 this.</span></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> greet = <span class="function"><span class="keyword">function</span>(<span class="params">greeting,name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> greeting + <span class="string">' '</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sayHelloTo = _.partial(greet,<span class="string">'hello'</span>);</span><br><span class="line">sayHelloTo(<span class="string">'fred'</span>); <span class="comment">// hello fred</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>组合函数管道<br>我们来看一个例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">`we can only see a short</span></span><br><span class="line"><span class="string">distance</span></span><br><span class="line"><span class="string">three</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> explode = <span class="function"><span class="params">str</span> =&gt;</span> str.split(<span class="regexp">/\s+/</span>);</span><br><span class="line"><span class="keyword">const</span> count = <span class="function"><span class="params">arr</span> =&gt;</span> arr.length;</span><br><span class="line"><span class="keyword">const</span> countWords = R.compose(count,explode);</span><br><span class="line">countWords(str); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>这段程序有趣的地方在于,直到countWords被调用才会触发求值,用其名称传递的函数 explode 和 count 在组合中是静止的.这种<strong>将函数的描述和求值的行为分开</strong>正是函数式编程的强大之处.<br>我们来看一下 compose 的实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">	<span class="keyword">let</span> start = args.length <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> i = start;</span><br><span class="line">		<span class="keyword">let</span> result = args[start].apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">		<span class="keyword">while</span>(i --)&#123;</span><br><span class="line">			result = args[i].call(<span class="keyword">this</span>,result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Ramda 这种函数库的好处就是所有函数都已经正确的柯里化,在组合函数管道时更具有通用性.<br>我们注意到 compose 函数是从参数最右到最左的顺序,而unix管道符 | 是从左到右执行的.我们可以使用 compose 的镜像函数 pipe 来获得 管道符一样的效果.不必像原来那样正式的声明参数来创建新的函数,函数式鼓励这种风格,它被称为 point-free.<br>point-free 使得 js 代码更接近 haskell 和 unix 的理念.柯里化能够灵活地定义一个只差最后一个参数的内联函数,这种编码风格被称为 Tacit 编程.</p>
</li>
<li><p>使用函数组合子来管理程序的控制流.<br>命令式代码能够加 if-else 和 for 语句这样的过程控制机制,而函数式则不能.<br>组合器是一些可以组合其他函数和组合子,作为控制逻辑运行的高阶函数.除了 compose 和 pipe,常见的组合子如下:</p>
</li>
</ol>
<ul>
<li>identity,意为身份,特性.它是返回与参数同值得函数.<br>  <code>identity :: a -&gt; a</code> 它广泛用于函数数学特性的检验</li>
<li>tap,意为轻拍.它能够将无返回值的函数嵌入到函数组合中,而无需创建其他代码.<br>  <code>tap:: (a -&gt; *) -&gt; a -&gt; a</code>该函数接受一个输入对象a 和一个对 a 执行操作的函数,使用提供的对象调用给定的函数,然后在返回该对象.</li>
<li><p>alternation,alt 组合子又叫 OR 组合子,能够在提供函数响应的默认行为时执行简单的条件逻辑.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alt = <span class="function"><span class="keyword">function</span>(<span class="params">func1,func2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func1(val) || func2(val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sequence,seq 组合子用于遍历函数序列,它以两个或以上的函数作为参数并返回一个新函数,会用相同的值顺序调用这些函数.实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seq = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">const</span> funcs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">		funcs.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(val))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>seq 不会返回任何值,只会一个一个的执行一系列操作.</p>
<ul>
<li>fork(join) 组合子<br>fork 用于需要以两中不同的方式处理单个资源的情况,该组合子需要以单个函数作为参数,即以一个 join 函数和两个 fork 函数来处理提供的输入,两个分叉函数的结果传递给join 函数.</li>
</ul>
<h3 id="第五章-针对复杂应用的设计模式"><a href="#第五章-针对复杂应用的设计模式" class="headerlink" title="第五章 针对复杂应用的设计模式"></a>第五章 针对复杂应用的设计模式</h3><ol>
<li><p>命令式错误处理的不足<br>在命令式编程中,异常都是通过 try-catch 处理的.将可能出现问题的代码放在 try 代码块中,通过 catch 捕获异常.但是,这样的代码将不能组合或连在一起,这将严重影响代码设计.<br><strong>函数式程序不应抛出异常</strong>,因为抛出异常会导致难以与其他函数组合,违反了引用透明原则,会引起副作用.</p>
</li>
<li><p>一种更好的解决方案Functor(函子).<br>通常我们在判断 null 和 undefined 时会写啰嗦且重复的的判断代码.函数式以一种完全不同的方法应对软件系统的错误处理,其思想就是创建一个安全的容器来存放危险代码.<br>functor 和 map 很类似,它会首先打开容器,应用函数到值,最后把返回的值包裹到一个新的同类型容器中.这种函数类型被称为 functor.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 functor 完成 2 + 3 = 5</span></span><br><span class="line"><span class="keyword">const</span> plus = R.curry(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b);</span><br><span class="line"><span class="keyword">const</span> plus3 = plus(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 将 2 放到warp容器中</span></span><br><span class="line"><span class="keyword">const</span> two = warp(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 调用 functor 把 plus3 映射到容器上</span></span><br><span class="line"><span class="keyword">const</span> five = two.fmap(plus3); <span class="comment">// Warpper(5) 返回一个具有上下文包裹的值</span></span><br><span class="line">five.map(R.identity) ; <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// fmap 函数返回同类型的类型,可以链式调用</span></span><br><span class="line">two.fmap(plus3).fmap(R.tap(infoLogger)); <span class="comment">// 在控制台打印以下信息</span></span><br></pre></td></tr></table></figure>
<p>functor 是无副作用且可组合的,其实际目的只是创建一个上下文或一个抽象,以便可以安全的应用操作到值而不改变原始值.<br>函子是函数编程中最重要的数据类型,也是基本的运算单位和功能单元.一般约定,函子的标志就是容器拥有 map 方法,该方法将容器中的每一个值映射到另一个容器.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(val)&#123;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">	&#125;</span><br><span class="line">	map(f)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Functor(f(<span class="keyword">this</span>.val))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Functor(<span class="number">2</span>)).map(<span class="function"><span class="keyword">function</span>(<span class="params">two</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> two + <span class="number">3</span>;</span><br><span class="line">&#125;) <span class="comment">// Functor(5)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>还有一个更具体化的函数式数据类型 Monad,可以将电话代码中的错误处理,更流畅的进行函数组合,其实 Monad 就是 functor “伸入” 的容器.我们曾经写个这样的 jQuery 代码<code>$(&quot;#student&quot;).fadeIn(3000).text(student.fullname())</code>.jQuery 可以很安全的将 fadeIn 和 text 行为应用到 DOM 上,如果 student 的 id 不存在,方法会应用到空的 jQuery 对象上且什么也不发生,也不会抛出任何异常.Monad 在于安全的传送错误,这样代码才有较好的容错性.</p>
<ol>
<li>Monad 函数式的出路错误<br>我们来了解一下 functor 的局限性,当把两个 warp 包裹函数组合在一起的时候需要用两次 R.identity 函数来提取值,如果层数再多的话,monad 是更好的解决方案.</li>
</ol>
<p>假设有一个函数<code>half: number -&gt; number</code>,<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warpper(<span class="number">2</span>).fmap(half); <span class="comment">// warpper(1)</span></span><br></pre></td></tr></table></figure></p>
<p>functor只管应用到值并将结果包裹起来,并不能加额外的逻辑,如果想限制 half 只应用到偶数,而输入是一个奇数该怎么办.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> <span class="built_in">Number</span>.isFinite(n) &amp;&amp; (n%<span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">val</span>) =&gt;</span> isEven(val) ? Wrap(val/<span class="number">2</span>) : empty();</span><br><span class="line"><span class="comment">// half 如果是一个奇数则返回一个空的容器</span></span><br></pre></td></tr></table></figure>
<p>Monad 用于创建一个带有一定规则的容器,而 Functor 不需要了解其容器内的值.使用 Monadic 类型需要了解以下定义:</p>
<ul>
<li>创建 Monadic 类型(类似于 Warpper的构造函数)</li>
<li>unit 函数,可将特点类型的值放入 Monadic 结构中,类似于 empty 函数.</li>
<li>bind 函数,可以链式操作,functor的 fmap</li>
<li>join 函数,将两层 monadic 结构合并为一层.用于逐层扁平化嵌套结构,无需多次提取.<br>Monad 函数的fmap 函数也叫 flatmap 函数,在大多数函数库里 flatmap 叫做 chain .</li>
</ul>
<p>下面来看丰富的 Monad 实例,maybe,Either 和 IO.<br>函数式编程通常使用 maybe 和 either 来隔离不纯,合并判空逻辑,避免异常,支持函数组合,中心化逻辑提供默认值.<br>简单说 maybe 函子的 map 方法里设置了空值检查.<br>Either 一般用来提供默认值.either 函子内部有两个值,left 和 right,right 是正常情况的值.left 是 right 不存在时的默认值.总之就是 right 有值用 right,否则用 left.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addOne = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">either.of(<span class="number">5</span>,<span class="number">6</span>).map(addOne); <span class="comment">// either(5,7)</span></span><br><span class="line">either.of(<span class="number">1</span>,<span class="literal">null</span>).map(addTOne); <span class="comment">// either(2,null)</span></span><br></pre></td></tr></table></figure></p>
<p>Either 另一个用途就是代替 try…catch,使用 left 表示错误.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseJson</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Either.of(<span class="literal">null</span>,<span class="built_in">JSON</span>.parse(json))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="第六章-可测试的函数式"><a href="#第六章-可测试的函数式" class="headerlink" title="第六章 可测试的函数式"></a>第六章 可测试的函数式</h3><p>略</p>
<h3 id="第七章-函数式优化"><a href="#第七章-函数式优化" class="headerlink" title="第七章 函数式优化"></a>第七章 函数式优化</h3><ol>
<li><p>函数执行机制<br>js 中,每个函数调用都会在函数上下文堆栈中创建记录(帧),它负责管理函数执行以及关闭变量作用域.<br>全局的上下文帧永远在堆栈的底部,函数体声明的变量越多,就需要越大的堆栈帧.<br>函数柯里化过度使用会导致其占有大量的堆栈空间,进而导致程序运行速度显著降低.<br>递归也会导致堆栈的溢出.因为递归时函数调用自己也会创建新的函数上下文,如果你见过<code>range error: Maximum call stack exceeded or too much recursion</code>就知道是递归出问题了.堆栈大小跟硬件也有关系.<br>既然大量函数推入堆栈会增加程序的内存占用,为什么不避免不必要的调用呢?</p>
</li>
<li><p>使用惰性求值推迟执行<br>函数式语言 Haskell 内置了惰性函数求值,惰性求值的方法有很多,但目的都是尽可能的推迟求值,直到依赖的表达式被调用.<br>但是 js 使用的是更主流的函数求值策略 - 及早求值,它会在表达式绑定到变量时求值,不管结果是否用到,也称贪婪求值.</p>
</li>
</ol>
<p>2.1 使用函数式组合子避免重复计算.alt 组合子类似于 || 运算,先计算 func1 如果返回值为 假,在调用 func2.这是避免不必要计算的简单方法,还有一个更强大的方法 memoization.<br>2.2 函数式编程的 shortcut fusion(意为: 捷径 融合),是一种函数级别的优化,它通过合并函数执行,并压缩计算过程中使用的临时数据结构有效降低内存占用.之所以可以这样做事因为函数式编程引用透明带来的数学和代数的正确性.<br>比如 compose(map(f),map(g))可以由 map(compose(f,g))完全代替.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">Math</span>.pow(x,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">x</span> =&gt;</span> x%<span class="number">2</span> === <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> numbers = _.range(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = _.chain(numbers)</span><br><span class="line">	.map(square)</span><br><span class="line">	.filter(isEven)</span><br><span class="line">	.take(<span class="number">3</span>) <span class="comment">// 仅处理前三个</span></span><br><span class="line">	.value() <span class="comment">// [0,4,16]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map 和 filter 可以通过 compose 融合在一起</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2.3 记忆化 memorization</span></span><br><span class="line"><span class="string">加快程序执行的方法之一就是避免计算重复值,在传统的面向对象中,通过将函数结果赋予给唯一的键值对并持久化到缓存中.</span></span><br><span class="line"><span class="string">而在函数式中记忆化是一种很好的方式.它基于函数的参数创建与之对应的唯一的键,将结果存储到键上,当再次遇到相同的参数的函数时,立即返回储存的结果.</span></span><br><span class="line"><span class="string">给 FUnction 添加记忆化</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="built_in">Function</span>.prototype.memoized = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> Key = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);<span class="comment">//将参数字符串化以获取当前函数调用的键值</span></span><br><span class="line">	<span class="keyword">this</span>._chace = <span class="keyword">this</span>.cache || &#123;&#125;; <span class="comment">// 为当前函数实例创建一个内部缓存</span></span><br><span class="line">	<span class="keyword">this</span>._chace[key] = <span class="keyword">this</span>._chace[key] || <span class="keyword">this</span>.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)<span class="comment">// 先试图读取缓存,通过输入判断是否计算过,找到就离开返回,没找到这开始计算</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._chace[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.memoize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 激活函数记忆化</span></span><br><span class="line">	<span class="keyword">let</span> fn = <span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">if</span>(fn.length === <span class="number">0</span> || fn.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> fn; <span class="comment">// 只尝试记忆化一元函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fn.memoized.apply(fn,<span class="built_in">arguments</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设计多个参数的函数即使是纯函数也很难缓存,因为复杂度增加了,柯里化是解决方案之一.<br>递归和尾递归优化,es6 添加的尾部调用消除,可以再递归调用时不依赖当前帧,创建一个新的帧并回收旧的帧.</p>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2020/06/16/JS 函数式编程指南/" class="article-date">
  <time datetime="2020-06-16T05:19:21.000Z" itemprop="datePublished">2020-06-16</time>
</a>

        </li>
        
          <li>
            <span class="label">Categoría:</span>
            
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>


          </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript-函数式编程/">JavaScript 函数式编程</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2020/06/30/搭建 MOCK 服务/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Nuevo</strong>
      <div class="article-nav-title">
        
          搭建 MOCK 服务
        
      </div>
    </a>
  
  
    <a href="/2020/06/15/读<<上帝的骰子>>/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Viejo</strong>
      <div class="article-nav-title">读&lt;&lt;上帝的骰子&gt;&gt;</div>
    </a>
  
</nav>


  
</article>






      </div>
      
    <footer id="footer" class="post-footer footer">
      
        <ul class="footer-links">
          
            <li><a href="/archives/"><span class="fa fa-book"></span></a></li>
          
            <li><a href="https://github.com/valenzhou"><span class="fa fa-github-alt"></span></a></li>
          
            <li><a href="https://www.facebook.com/valen.zhou"><span class="fa fa-facebook"></span></a></li>
          
            <li><a href="https://twitter.com/valenzhou/"><span class="fa fa-twitter"></span></a></li>
          
            <li><a href="https://plus.google.com/"><span class="fa fa-google-plus"></span></a></li>
          
            <li><a href="https://www.google.com/"><span class="fa fa-globe"></span></a></li>
          
            <li><a href="/atom.xml"><span class="fa fa-rss"></span></a></li>
          
        </ul>
	    
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>ipsum dolor sit amet, <strong>consectetur adipiscing elit.</strong> Fusce eget urna vitae velit <em>eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque</em> penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Post</p>


      </div>
    </footer>

      



<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
