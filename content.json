{"meta":{"title":"Mr.喵的网络日志","subtitle":null,"description":null,"author":"ValenZhou","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"学习CSS Grid布局","slug":"学习CSS-Grid布局","date":"2017-12-13T07:39:20.000Z","updated":"2017-12-13T07:42:01.000Z","comments":true,"path":"2017/12/13/学习CSS-Grid布局/","link":"","permalink":"http://yoursite.com/2017/12/13/学习CSS-Grid布局/","excerpt":"","text":"CSS Grid 布局是CSS中最强大的布局系统,与flexbox的一维布局系统不同,CSS Grid是一个二维布局系统,它可以同时处理行和列. 第一个Grid布局css Grid布局由两个核心组成部分,warpper(父元素)和items(子元素).warpper是实际的grid(网格),items是网格的内容. 下面是一个warpper元素,内部包含了6个items: 12345678&lt;div class=\"warpper\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 要把warpper元素变成一个grid(网格),只需要把它的display属性设置为grid即可. 123.warpper&#123; display:grid;&#125; 这时我们还没有写任何样式,他会简单的将6个div堆叠在一起. Columns(列)和rows(行)为了使其成为二维的网格容器,我们需要定义行和列.让我们创建两行三列,使用grid-template-cloumns和grid-template-rows属性. 12345.warpper&#123; display:grid; grid-template-rows: 100px 50px; grid-template-cloumns: 100px 80px 60px;&#125; 我们为grid-template-cloumns写入了3个值,这样我们就得到了3列,每列的值代表列的宽度.而grid-template-rows代表行数及行的高度. 放置items(子元素)为了帮助理解,我们在每个items(子元素)加上单独的class. 12345678&lt;div class=\"warpper\"&gt; &lt;div class=\"item1\"&gt;1&lt;/div&gt; &lt;div class=\"item2\"&gt;2&lt;/div&gt; &lt;div class=\"item3\"&gt;3&lt;/div&gt; &lt;div class=\"item4\"&gt;4&lt;/div&gt; &lt;div class=\"item5\"&gt;5&lt;/div&gt; &lt;div class=\"item6\"&gt;6&lt;/div&gt;&lt;/div&gt; 现在我们来创建一个 3*3的grid: 12345.warpper&#123; display:grid; grid-template-rows: 100px 100px 100px; grid-template-cloumns:100px 100px 100px;&#125; 我们只在页面上看到3-2的grid,而我们定义的是3-3的grid.这是因为我们只有6个items来填充这个网格.我们我们再追加3个items,name最后一行也会被填满. 要定位和调整items大小,可以使用grid-cloumn和grid-row属性来设置. 1234.item1&#123; grid-cloumn-start: 1; grid-cloumn-end: 4;&#125; 上面的样式表示,我们希望item1占据从第一个网格线开始,到第四条网格线结束.换句话说它将独占一行.而剩下的items都推到了下一行. 这种形式也可以缩写为: 123456.item1&#123; grid-cloumn: 1/4;&#125;.item3&#123; grid-row: 2/4;&#125; 相关术语 网格容器(Grid):应用display:grid的元素,items的直接父级元素. 网格项(items): 网格容器的直接子元素,后代元素不是. 网格线(Grid-line):构成网格结构的分界线. 网格轨道(Grid-Track):两条相邻网格线之间的空间. 网格单元格(Grid-cell):两个相邻行与相邻列之间的空间. 网格区域(Grid-Area):四条网格线包围的总空间. 父元素 网格容器属性display将元素定义为网格容器,并为其建立新的网格式上下文. grid : 生成一个块级网格 inline-grid: 生成一个内联网格 subgrid: 嵌套的子网格. 在网格容器中使用float,clear,column,vertical-align不会产生任何效果. grid-template-cloumns/rows使用空格分割值列表,用来定义网格的行和列.可以是长度值和百分比,和自动分配(auto)或网格线名称. grid-template-areas指定Grid Area名称来定义网格模板.一个.号代表一个空的单元.你可以使用任意数量的.只要这些.之间没有空隙隔开就表示一个个的单元格. :由items的grid-area指定的区域名称 .(点号):代表一个空网格单元 none:不定义网格区域 12345678910111213141516.container&#123; display:grid; grid-template-rows:auto; grid-template-cloumns:50px 50px 50px 50px; grid-template-areas: \"header header header\" \"main main . sidebar\" \"footer footer footer footer\"&#125;.item-a&#123; grid-area:header;&#125;.item-b&#123; grid-area:main;&#125;... 当你命名网格区域后,该区域两端的网格线实际上是自动命名的,如果你的网格区域名字是foo,则起始行网格线和列网格线是foo-statrt,最后的网格线是foo-end.则意味着一个网格线可能有很多名称. grid-template用于定义grid-template-rows,grid-template-cloumns,和grid-template-areas的缩写. none:将所有的属性设置为初始值. subgrid:将rows和cloumns设置为subgrid,areas设置为初始值. /:将rows和cloumns设置为特定值,areas为none. grid-column-gap/grid-row-gap指定网格线的大小,可以把它想象为设置列/行之间间距的宽度.值为长度值. grid-gapgrid-column-gap/grid-row-gap的缩写语法 justify-items网格容器的水平对其方式,这些行为也可以通过items的justify-self属性设置: start 左侧对其 end 右侧对其 center 居中对齐 stretch 填满区域宽度 align-items网格容器的垂直对齐方式: start 顶部对齐 end 底部对齐 center 垂直居中 stretch 填满区域高度 justify-content/align-content有时,网格容器的内容小于整体容器的大小,可以设置内容在容器中的对齐方式. start 左对齐 end 右对齐 center 居中 stretch 填充 space-around 左右两边都有空间,空格之间距离相等 space-between 左右两边没有空间,空格之间距离相等 space-evenly 左右和每个空间距离相等 grid-auto-columns/grid-auto-rows指定自动生成隐式网格轨道,但定义行和列自动超出网格范围时,隐式网格轨道创建.值为长度,百分比等等. grid-auto-flow如果你有一些未明确放置的网格,自动放置算法会自动放置这些项. row: 依次填充每行 column:依次填充每列 dense: 出现较小的网格项时,尝试填充网格中较早的空缺.但它可能导致你的网格项出现混乱. 子元素 网格项items属性grid-column-start/end通过指定网格线来确定网格在容器中的列的起始位置 grid-row-start/end通过指定网格线来确定网格在容器中的行的起始位置 grid-column/grid-row上面两者的缩写 grid-area为网格项提供一个名词,一遍容器grid-template-areas属性创建模板进行引用.也可以作为grid-row和grid-cloumn的缩写. justify-self/align-selfitems的水平/垂直对其方式","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端 css","slug":"前端-css","permalink":"http://yoursite.com/tags/前端-css/"}]},{"title":"上海外滩随拍","slug":"上海外滩随拍","date":"2017-11-05T03:01:56.000Z","updated":"2017-12-26T07:09:39.000Z","comments":true,"path":"2017/11/05/上海外滩随拍/","link":"","permalink":"http://yoursite.com/2017/11/05/上海外滩随拍/","excerpt":"","text":"","categories":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/categories/旅行/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/tags/旅行/"}]},{"title":"浏览器数据持久化存储技术解析","slug":"浏览器数据持久化存储技术解析","date":"2017-11-04T07:09:36.000Z","updated":"2017-12-22T07:13:22.000Z","comments":true,"path":"2017/11/04/浏览器数据持久化存储技术解析/","link":"","permalink":"http://yoursite.com/2017/11/04/浏览器数据持久化存储技术解析/","excerpt":"","text":"打开Chrome浏览器的调试模式,Application就列举了现代浏览器的8种缓存机制:HTTP文件缓存,LocalStorage,SessionStorage,indexDB,webSQL,Cookie,CacheStorage,ApplicationCache. 从网址到网页展示 我们先看一个问题,从我们打开浏览器地址栏输入一个网址,到浏览器展示网页内容的这段时间,浏览器和服务端都发生了什么事情? 在接受到用户输入的网址后,浏览器会开启一个线程来处理这个请求,对用户输入的 URL 地址进行分析判断,如果是HTTP协议就按照HTTP方式来处理. 调用浏览器引擎中的对应方法,比如 WebView 中的 loadUrl 方法,分析并加载这个 URL 地址. 通过 DNS 解析获取该网站对应的 IP 地址,查询完成后连同浏览器的 Cookies,userAgent 等信息向网站目的地 IP 发送 Get 请求. 进行 HTTP 协议会话,浏览器客户端向 web 服务器发送报文. 进入网站后台上的 web 服务器处理请求, 如 Apache,Tomcat, Node.js服务器. 进入部署好的后端应用,如 PHP, java, Javascript, Python等后端程序,找到对应的请求处理逻辑,这期间可能会读取服务器缓存或查询数据库等. 服务器处理请求并返回响应报文,此时如果浏览器访问过该页面,缓存上有对应资源,会与服务器最后修改记录对比,一致则返回304,否则返回200与对应的内容. 浏览器开始下载 HTML 文档(响应报文状态码为200时) 或者从本地缓存读取文件内容(浏览器缓存有效或响应报文状态码为304时). 浏览器根据下载接收到的 HTML 文件解析结构建立 DOM文档树,并根据 HTML 中的标记请求下载指定的MIME文件(如CSS,JAvaScript脚本等),同时设置缓存等内容. 页面开始解析渲染DOM,CSS根据规则解析并结合DOM文档树进行网页内容布局和绘制渲染,JavaScript根据DOM API 操作DOM,并读取浏览器缓存,执行事件绑定等,页面整个展示过程完成. HTTP文件缓存HTTP文件缓存是基于HTTP协议的浏览器端文件级缓存机制,在文件重复请求的情况下,浏览器可以根据HTTP响应的协议头信息判断是从服务器端请求文件还是本地读取文件.以下是 文件缓存的过程. 1. 浏览器会先查询Cache-Control来判断内容是否过期,如果未过期,直接读取浏览器端缓存文件不发送HTTP请求,否则进入下一步. 2. 在浏览器端判断上次文件返回头中是否含有Etag信息,有则连同If-None-Match一起向服务器发生请求,服务端判断Etag未修改则返回状态304,修改则返回200,否则进入下一步. 3. 在浏览器端判断上次文件是否含有Last-Modified信息,有则一起向服务器发送请求,服务器判断是否失效,失效返回200,未失效返回304. 4. 如果Etag和Last-Modified都不存在,则向服务器请求内容. 在HTML中我们添加的meta标签中的Expires和Cache-Control,且一般Cache-Control设置的是秒,如果以上两个同时设置,只要Cache-Control的设置生效. 12&lt;meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2016 23:00:00 GMT\"/&gt;&lt;meta http-equiv=\"Cache-Control\" content=\"max-age=7200\"&gt; 同时服务端也要设置静态资源的缓存时间.我们可以结合Koa-static中间件设置实现. 12345const static = require('koa-static')const app = koa()app.use(static('./pages',&#123; maxage: 7200&#125;)) localStoragelocalStorage是HTML5的一种本地缓存方案,目前主要用于浏览器端保存体积较大的数据(如AJAX返回结果等).但它在各版本浏览器的长度限制不一.它的核心API只有4个. 1234localStorange.setItem(key,value)//设置存储记录localStorage.getItem(key)//获取储存记录localStorage.removeItem(key)//删除记录localStorage.clear()//清空 LocalStorage只支持简单数据类型的读取,为方便读取对象等格式内容,通常需要进行一层安全封装再引入使用. sessionStoragesessionStorage和LocalStorage功能类似,但sessionStorange在浏览器关闭时会自动清空.它的API和LocalStorage的API完全相同,但由于不能持久化数据存储,因此使用场景较少. cookiecookie是网站为了辨别用户身份或session追踪而存储在用户浏览器的数据,cookie一般会通过HTTP请求到服务器端.一条cookie主要由键,值,域,过期时间和大小组成,一般用于保存用户的网站认证信息.通常最大限制为4KB. cookie分为两种,sessionCookie和持久型Cookie.前者一般不设置过期时间,表示与浏览器会话期间保存在内存中,持久性Cookie会设置过期时间保存在本地硬盘中,知道过期或清空才失效. Cookie设置中有个HttpOnly参数,浏览器端通过doucument.cookie是读取不到HttpOnly类型的Cookie的,只能通过HTTP请求头发送到服务器进行读写操作.这样可以避免服务器端的Cookie记录被js修改,保证了服务端验证cookie的安全性. WebSQLwebSQL是浏览器端用于存储大量数据的缓存机制,以一个独立浏览器端数据存储规范的形式出现.它在HTML5前就已经出现,是单独的规范,它将数据以数据库二维表的形式存储在客户端,并且允许SQL语句的查询. webSQL的API主要包含上个核心方法:openDatabase(),transaction()和executeAql(). 1234567//openDatabase()打开已经存在的数据库,不存在就创建.他的五个参数是数据库名,版本号,描述,数据库大小,创建回调.let db = openDatabase('mydatabase','1.0','test',2*1024*1024)db.transaction(function(table)&#123; table.executeSql('INSERT INTO t1 (id,msg) VALUES (1,\"hello\")')&#125;)//transaction方法允许我们根据情况控制事物提交或回滚.//executeSql用于执行真实的SQL查询语句. IndexDBIndexDB也是客户端存储大量结构化数据并且能在这些数据上使用索引进行高性能检索的一套API.由于webSQL不是HTML5规范,一般推荐使用IndexDB进行大量数据存储,其基本实现和webSQL类似. 12345if(database)&#123; database.transaction(function(tx)&#123; tx.executeSql('INSERT INTO t1 (id,msg) VALUES (1,\"hello\")') &#125;)&#125; Application CacheApplication Cache是一种允许浏览器通过manifest配置文件在本地有选择性的存储js,css,图片等静态资源的缓存机制.当页面不是首次打开时,通过一个特定的manifest文件配置描述选择性新读取本地ApplicationCache的文件.所以它具有离线浏览,快速加载,服务器载荷小的优势.它的文件访问及更新机制如下: 1. 判断是否是第二次加载页面. 2. 是的话访问AppCache. 3. 检查manifest文件是否更新 4. 无更新从AppCache读取,有更新则重新拉取并更新AppCache. 使用方式 12345678&lt;html manifest=\"app.manifest\"&gt;//对应的描述文件如下CACHE MANIFEST#VERSION 1.0CACHE:xxx.cssXXX.jsXXX.png 浏览器也可以根据window.applicationCache来对其进行控制. 尽管ApplicationCache的实现很方便,但是已经开始被标准弃用,渐渐将会由ServiceWorkers来代替.总之,ApplicationCache仍是一个不成熟的本地缓存解决方案. cacheStoragecacheStorage是ServiceWorkers规范中定义的,用于保存每个ServiceWorker声明的Cache对象,是未来可代替ApplicationCache的离线方案. CacheStorage在浏览器端为window.caches,有open,match,has,delete,keys五个API. 12345caches.has();//检查如果包含cache对象,返回一个promisecaches.open();//打开一个cache对象,返回一个promsiecaches.delete();//删除一个cache对象,返回一个promisecaches.keys();//含有keys中字符串的任意一个,返回一个promisecaches.match();//匹配key中含有该字符的cache,返回一个promise Flash缓存Flash缓存主要基于网页端Flash,具有读写浏览器本地目录的功能,同时也可以向js提供调用的API,这样页面就可以通过js调用Flash读写本地指定的磁盘目录,达到本地数据缓存的目的. 本文摘自张成文编著&lt;&lt;现代前端技术解析&gt;&gt;,详情请点击张成文的Github","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端 数据储存","slug":"前端-数据储存","permalink":"http://yoursite.com/tags/前端-数据储存/"}]},{"title":"vue项目中的小总结","slug":"vue项目中的小总结","date":"2017-05-21T06:45:23.000Z","updated":"2017-11-22T08:06:23.000Z","comments":true,"path":"2017/05/21/vue项目中的小总结/","link":"","permalink":"http://yoursite.com/2017/05/21/vue项目中的小总结/","excerpt":"","text":"单文件组件中data必须是一个函数,然后返回一个对象.避免多个组件数据混乱.1234567 export default &#123; data()&#123; return &#123; a: \"123\", &#125; &#125;&#125; 列表循环时,尽量使用key,避免元素复用1&lt;div v-for=\"(item,index) in array\" :key=\"index\"&gt;&lt;/div&gt; 在vue中使用less安装less及less-loader依赖 1npm install less less-loader --save-dev 修改webpack配置文件 在单文件组件中使用 1&lt;style lang=\"less\" scoped&gt; $nextTick的用法异步更新队列:Vue在观察到数据变化时不会直接更新Dom,而是开启一个队列,并缓冲在同一事件循环中发生的所有数据变化,然后去除重复数据,避免重复计算和dom操作,然后在下一个事件循环tick中,刷新队列并执行实际(已去重)的工作.$nextTick就是用来知道什么时候dom更新完成的. 123&lt;div id=\"div\" v-if=\"isShow\"&gt;这是一段文本&lt;/div&gt;&lt;button @click=\"getText\"&gt;获取div内容&lt;/button&gt;&lt;!-- 当我们点击按钮时,获取div的文本 --&gt; 1234567getText: function()&#123; this.isShow = true; this.$nextTick(function()&#123; var text = document.getElementById('div').innerText; console.log(text); &#125;)&#125; webpack打包上传服务器后项目图片路径的问题1. 解决方式一: 修改config文件中index.js里assetsPublicPath为&apos;./&apos;, 然后修改webpack.base.conf.js里的url-loader的limit,根据文件大小相应的修改. 但是修改后打包的文件比较大,影响页面加载. 2. 解决方式二: 修改config文件中index.js里assetsPublicPath为&apos;./&apos;,然后修改源代码中css的图片路径为绝对路径, 静态资源由之前的src下的assets文件转移到src同级的static文件下新建一个img文件. 如果该项目有两级以上的域名,就在绝对路径前加上该子域名,如&apos;/XXX/static/img/a.png&apos; scoped下尽量不要使用标签选择器scoped下尽量不要使用标签选择器,会影响页面性能. vue组件添加原生事件vue组件添加原生事件,必须在事件后添加.native修饰符,否则事件不会生效. 在vue中使用TypeScript在vue中使用TypeScript 1. 安装依赖 12npm i vue-class-component vue-property-decorator --savenpm i ts-loader typescript tslint tslint-loader tslint-config-standard --save-dev 2. 配置webpack - 找到&apos;./build/webpack.base.conf.js&apos;添加 1resolve: &#123;extensions: ['.js', '.vue', '.json', '.ts'],&#125; - 找到module.rules,添加对.ts的解析 1234567891011121314&#123; test: /\\.ts$/, exclude: /node_modules/, enforce: 'pre', loader: 'tslint-loader'&#125;,&#123; test: /\\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: &#123; appendTsSuffixTo: [/\\.vue$/], &#125;&#125;, - 添加根路径tsconfig.json文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; // 编译选项 \"compilerOptions\": &#123; // 输出目录 \"outDir\": \"./output\", // 是否包含可以用于 debug 的 sourceMap \"sourceMap\": true, // 以严格模式解析 \"strict\": true, // 采用的模块系统 \"module\": \"esnext\", // 如何处理模块 \"moduleResolution\": \"node\", // 编译输出目标 ES 版本 \"target\": \"es5\", // 允许从没有设置默认导出的模块中默认导入 \"allowSyntheticDefaultImports\": true, // 将每个文件作为单独的模块 \"isolatedModules\": false, // 启用装饰器 \"experimentalDecorators\": true, // 启用设计类型元数据（用于反射） \"emitDecoratorMetadata\": true, // 在表达式和声明上有隐含的any类型时报错 \"noImplicitAny\": false, // 不是函数的所有返回路径都有返回值时报错。 \"noImplicitReturns\": true, // 从 tslib 导入外部帮助库: 比如__extends，__rest等 \"importHelpers\": true, // 编译过程中打印文件名 \"listFiles\": true, // 移除注释 \"removeComments\": true, \"suppressImplicitAnyIndexErrors\": true, // 允许编译javascript文件 \"allowJs\": true, // 解析非相对模块名的基准目录 \"baseUrl\": \"./\", // 指定特殊模块的路径 \"paths\": &#123; \"jquery\": [ \"node_modules/jquery/dist/jquery\" ] &#125;, // 编译过程中需要引入的库文件的列表 \"lib\": [ \"dom\", \"es2015\", \"es2015.promise\" ] &#125;&#125; - 添加根路径tslint.json文件 123456&#123; \"extends\": \"tslint-config-standard\", \"globals\": &#123; \"require\": true &#125;&#125; - 在src下创建vue-shim.d.ts 1234declare module \"*.vue\" &#123; import Vue from \"vue\"; export default Vue;&#125; 之后再代码中引入.vue文件时需要加上.vue后缀,因为ts默认只识别*.ts文件 - 改造APP.vue文件 12345678&lt;script lang=\"ts\"&gt; import Vue from 'vue' import Component from 'vue-class-component' @Component(&#123;&#125;) export default class App extends Vue &#123; &#125;&lt;/script&gt; - 修改main.js为main.ts,并修改&apos;./build/webpack.base.conf.js&apos;中的entry为 `{app: &apos;./src/main.ts&apos;}`","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"vue 前端","slug":"vue-前端","permalink":"http://yoursite.com/tags/vue-前端/"}]},{"title":"学习React","slug":"学习React","date":"2017-01-14T03:12:17.000Z","updated":"2017-12-14T03:35:54.000Z","comments":true,"path":"2017/01/14/学习React/","link":"","permalink":"http://yoursite.com/2017/01/14/学习React/","excerpt":"","text":"安装​ creat-react-app 脚手架安装 ​ npm install -g creat-react-app ​ 初始化安装 ​ creat-react-app hello-react ​ 启动 ​ cd hello-react ​ npm start 使用jsx12345678910111213141516import React,&#123;Component&#125; from 'react'import ReactDOM from 'react-dom'import './index.css'class Header extends Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;hello React&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;header/&gt;, document.getElementById(\"root\")) jsx在编译时会变成相应的js对象描述. react-dom负责把这个js对象描述变成dom元素并渲染. Reader方法我们在编写组件时,需要继承react的Component,一个组件类必须实现一个render方法,这个方法返回一个jsx对象,需要注意的是,必须用一个外层的元素把所有内容包裹起来,而不能是几个元素. 表达式插入在jsx中可以插入js表达式,表达式返回的结果会渲染在页面上,表达式用{}包裹,如果包裹的是一个对象,在对象的外面也要加上{}. {}内可以放任何js的代码.不仅仅可以放在标签内部,也可以放在标签属性上. &lt;a className={className}/&gt; 因为class,和for是js关键字,所以在react中用className和htmlFor代替. 条件返回我们可以根据不同的条件返回不同的jsx. 1234567891011121314render()&#123; const isGood = true return ( &lt;div&gt; &lt;h1&gt; &#123; isGood ?&lt;strong&gt;isGood&lt;/strong&gt; :&lt;span&gt;is bad&lt;/span&gt; &#125; &lt;/h1&gt; &lt;/div&gt; )&#125; 如果你想要隐藏一个元素,返回一个null即可. jsx元素变量jsx元素就是js对象,那么jsx元素其实可以像js对象一样赋值给变量,作为函数参数传递或作为函数返回值. 12345678910111213141516171819202122232425//作为变量render()&#123; const isGood = true const good = &lt;strong&gt;isGood&lt;/strong&gt; const bad = &lt;span&gt;isBad&lt;/span&gt; return( &lt;div&gt; &lt;h1&gt; &#123;isGood?good:bad&#125; &lt;/h1&gt; &lt;/div&gt; )&#125;//作为函数参数传递renderGood(good,bad)&#123; const isGood = true return isGood?good:bad&#125;render()&#123; return( &lt;div&gt; &#123;this.renderGood(&lt;strong&gt;isGood&lt;/strong&gt;,&lt;span&gt;isBad&lt;/span&gt;)&#125; &lt;/div&gt; )&#125; 组件的组合,嵌套和组件树自定义的组件必须用大写字母开头,普通html标签用小写字母开头. 组件之间可以组合,嵌套.就像普通的html标签一样使用就可以,这样组合嵌套最后构成一个组件树,来表示它们之间的关系. 事件监听在react中监听事件甚至需要给监听的元素加上类似于onClick和onKeyDown这样的属性,紧跟的是一个表达式插入,这个表达式返回一个实例方法. 在react中不需要调用浏览器原生的addEventListener进行事件监听,react帮我们封装好了一系列的on*的属性,而且不用考虑不同浏览器之间的兼容问题.如果需要用到事件对象event,在函数中传入e参数即可,react把event对象也做了封装. 一般在某个类的实例方法中,this指的就是这个实例本身,但在react中,调用你传给它方法的时候,并不是通过对象方法的方式调用(this.handleclick),而是通过函数调用(handleClick),所以在事件监听函数中的this是null或undefined.当你想在函数中使用当前实例的时候,需要手动将实例方法bind到当前实例再传给react,这种方式在react中非常常见. 这些on*事件只能用在普通的html元素上,不能用在组件标签上 组件的state和setState一个组件的显示形态是由它的数据状态和配置参数决定的.一个组件可以拥有自己的状态,就像一个点赞按钮,有点赞状态和未点赞状态,并可以再这两种状态之间来回切换.state就是存储这种可变化的状态的.改变状态时不能直接赋值,可以使用setState方法来改变状态.当我们调用setState时,react会更新组件状态,重新调用render方法,然后再把render方法所渲染的最新内容显示到页面上.state方法接受一个对象或函数作为参数如果我们用this.state=XXX,React就没办法知道你修改了组件的状态. state接收对象参数12345678910constructor(props)&#123; super(props) this.state = &#123; name: 'tom', isLicked: false &#125;&#125;handleClick()&#123; this.setState(&#123;isLicked: !this.state.isLicked&#125;)&#125; state接收函数作为参数再调用setState时,react不会马上修改state,而是把这个对象放到一个更新队列中,稍后才回从多个队列中把新状态计算合并提取出来合并到state,再触发更新 12345678910111213141516171819//对象作为参数handClick()&#123; this.setState(&#123;count:0&#125;)//this.state.count还是undefinedthis.setState(&#123;count: this.state.count+1&#125;)//undefined+1=NaNthis.setState(&#123;count:this.state.count+2&#125;)//NaN+2=NaN&#125;//函数作为参数可以接受一个参数作为上次setState的返回值handClick()&#123; this.setState((prevState)=&gt;&#123; return &#123;count:0&#125;//0 &#125;) this.setState((prevState)=&gt;&#123; return &#123;count: prevState.count +1&#125;//0+1=1 &#125;) this.setState((prevState)=&gt;&#123; return &#123;count: prevState.count+2&#125;//1+2=3 &#125;)&#125;//进行3次setState,但组件只会渲染一次.因为react会把所有事件循环中的消息队列中的state合并再渲染. 配置组件的props一个组件可能在不同的地方用到,所以组件要有一定的可配置性.每个组件都可以接收一个props参数,他是一个对象,包含你对这个组件的配置. 组件内部是通过this.props的方式来获取组件的参数,如果this.props有需要的属性就采用,没有的话就默认. 再使用一个组件的时候,可以把参数放在标签中的属性中,所以属性都会作为props对象的键值. 默认配置defaultProps我们可以通过||操作符来实现默认配置,const word = this.props.like || &#39;已赞&#39;React也提供了一种方式defaultProps来配置默认配置. 12345678910class LikeBtn extends Component&#123; static defaultProps = &#123; like: '取消', unlike: '点赞' &#125; constructor()&#123; super() this.state = &#123;isLike: false&#125; &#125;&#125; props不可变props一旦传入进来就不能改变.如果我们使用this.props.like=&#39;取消&#39;控制台会直接报错. 你不能改变一个组件被渲染时传进来的props,因为如果渲染过程中可以改变会导致组件的显示形态和行为变得不可预测. 但这并不意味这props永远不能修改,组件的使用者可以主动的通过重新渲染的方式把新的props传入到组件中. 1234&lt;div&gt; &lt;LikeBtn like=&#123;this.state.like&#125;&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;button&gt; &lt;/div&gt; 在这里,我们把state中的数据传给props,但我们点击按钮时,我们使用setState改变state的值,并导致页面重新渲染,改变后的state会传给新的props. state VS propsstate的主要作用是用于组件保存,控制,修改自己的状态.state在组件内部初始化,可以被自身修改,但不能被外界访问和修改.可以把state当做一个局部的只能被自身控制的数据源.通过this.setState进行更新,该方法会导致组件重新渲染. props主要作用是可以传入参数来配置该组件,组件内部无法控制和修改,除非外部主动传入新的props,否则组件的props永远保持不变. 一个组件的state中的数据可以传给子组件的props,一个组件也可以使用外部传入的props来初始化自己的state.但他们职责非常清晰state是让组件控制自己的状态,props是让外部对组件自己进行配置,尽量少的用state,尽量多的使用props 无状态组件12345678const HelloWorld = (props)=&gt;&#123; const sayHi = (event)=&gt;&#123; alert(\"helloWorld\") &#125; return( &lt;div onClick=&#123;sayHi&#125;&gt;helloWorld&lt;/div&gt; )&#125; 以前的一个组件时通过继承Component来构建,一个子类就是一个组件,而用函数式编写方式是一个函数就是一个组件,你可以和之前使用使用该组件.不同的是,函数式组件只能接受props而无法和类组件一样在constructor里面初始化state.函数式组件就是一种只接受props和提供render方法的类组件. 渲染列表数据渲染存放jsx元素的数组1234567891011render()&#123; return( &lt;div&gt; &#123;[ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; ]&#125; &lt;/div&gt; )&#125; 如果你往{}里放一个数组,react会把数组中的元素依次渲染出来. 使用map渲染列表数据123456789101112131415161718192021222324252627282930313233343536373839const users = [ &#123;userName:'tom',age:21,gender:'male'&#125;, &#123;userName:'jerry',age:23,gender:'male'&#125;, &#123;userName:'lily',age:41,gender:'male'&#125;, &#123;userName:'lucy',age:31,gender:'male'&#125;,]render()&#123; const userEle = []//保存渲染后的jsx数组 for(let user of users)&#123; userEle.push( &lt;div&gt; &lt;span&gt;&#123;user.userName&#125;&lt;/span&gt; &lt;span&gt;&#123;user.age&#125;&lt;/span&gt; &lt;span&gt;&#123;user.gender&#125;&lt;/span&gt; &lt;/div&gt; ) &#125; return( &lt;div&gt;&#123;userEle&#125;&lt;/div&gt; )&#125;//但我们一般不会手动写循环来构建jsx结构,而是用es6 的map方法render()&#123; return( &lt;div&gt; &#123; users.map((user,index,arr)=&gt;&#123; return( &lt;div&gt; &lt;span&gt;&#123;&#123;user.userName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;user.age&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;user.gender&#125;&#125;&lt;/span&gt; &lt;/div&gt; ) &#125;) &#125; &lt;/div&gt; )&#125; 然后你会发现,react报错了,因为对于用表达式套数组罗列到页面上的元素,都要为每个元素加上key属性,这个key必须是每个元素的标识 状态提升在编写组件时,当有别的组件依赖或影响某个组件的某个状态state时,我们通常将这种组件之间共享的状态交给组件最近的公共父节点保管,然后通过props把状态传递给子组件,这样就可以在组件之间共享数据了.这种方式在React中被称为状态提升. 如果这个公共的分组件只是组件树下很小的一个子树,我们需要一直把状态提升上去,一旦发生提升,就需要修改原来保存状态以及传递数据的所有代码,这种无限制的提升并不是一个好的方案. 如何更好的管理被多喝组件依赖的状态?React并没有提供更好的解决方案,我们可以引入Redux状态管理工具来帮助我们解决这种共享状态.对于不会被外界依赖和影响的状态,一般只保存在组件内部即可,不需要做提升. 挂载阶段组件的生命周期我们来看看下面这段代码发生了什么 123456789101112ReactDOM.render( &lt;Header/&gt;, document.getElementById('root'))//1.实例化一个Headerconst header = new Header(props,children)//2.调用header.renderconst headerJsx = header.render()//3.构建真正的DOM元素const headerDom = createDOM(...)//4. 把DOM元素追加到页面上document.getElementById('root').appendChild(headerDOm) 上面这个过程称为组件的挂载,这是一个从无到有的过程 React为了更好的掌握组件的挂载过程,提供了一系列等生命周期函数.包括了两个挂载函数. componentWillMount和componentDIdMount.当我们在页面渲染后删除了某个元素后,也有对应的函数componentWillUnmount. 他们之间的顺序为 1. constructor (指向prototype对象所在的构造函数,关于组件自身状态的初始化) 2. component will mount (组件将要挂载,一般组件启动的动作,包括ajax数据的拉取,设置定时器等等在此进行) 3. render (返回jsx元素) 4. component did mount (组件已经挂载,当组件的启动工作依赖dom时,例如动画,就可以放在这里.) 5. component will unmount (组件将要移除,在组件销毁时清除该组件定时器和其他数据清理工作) 更新阶段的组件生命周期除了挂载阶段,还有一种更新阶段.setState导致react重新渲染组件就是一个组件的变化过程. shouldComponentUpdate(nextProps,nextState): 你可以通过这个方法控制组件是否重新渲染,如果返回false就不重新渲染,该生命周期在性能优化上非常有用. componentWillReceiveProps(nextProps):组件从父组件接收到新的props之前调用. componentWillUpdate():组件重新渲染之前调用. componentDIdUpdate():重新渲染后调用. ref 和 React 中的 DOM 操作React中我们很少和打交道,有一系列的on*方法帮我们进行事件监听,我们不再需要调用addEventListener的DOM API,我们通过setState重新渲染组件,渲染时把新的props传给子组件达到页面更新效果,而不再借用jQuery进行页面更新. 但React并不能满足所有的DOM操作,比如进入页面自动focus到某个输入框,.比如你想获取某个元素的尺寸在做后续动画等等.所以它提供了ref属性帮助我们获取已经挂在的dom节点,你可以给某个JSX元素加上ref属性. &lt;input ref={(input)=&gt;{this.input = input}}&gt; 我们给input加了一个ref属性,该属性是一个函数,该元素在页面上挂载完毕后调用这个函数,并把这个挂载后的dom节点传给这个函数.我们把元素赋值给组件实例的一个属性,这样就可以通过this.input获取这个DOM元素. 如果给组件挂载ref,那么我们获取的是这个组件在react内部初始化的实例,这并不常用,不建议这样做. props.children 和容器类组件1234567891011121314151617ReactDOM.render( &lt;Card&gt; &lt;h1&gt;I'm H1&lt;/h1&gt; &lt;div&gt;I'm Div&lt;/div&gt; &lt;/Card&gt;, document.getElementById('root'))class Card extends Component&#123; render()&#123; return&#123; &lt;div&gt; &#123;this.props.children&#125; &#123;this.props.children[0]&#125; &lt;/div&gt; &#125; &#125;&#125; 在使用自定义组件时,可以再组件内部嵌套jsx结构.嵌套的结构可以再组件内部通过props.children获取到,这种组件编写方式在编写容器类型的组件当中非常有用,而在实际React项目中,我们几乎每天都需要用这种方式编写组件. dangerouslySetHTML 和 style 属性#####dangerouslySetHTML 出于安全因素(XSS攻击),React会把所有表达式插入的内容都自动转义.类似于jQuery的text(). 12345const header = '&lt;h1&gt;helloWorld&lt;/h1&gt;'&lt;div&gt; &#123;header&#125; &lt;/div&gt;//因为react的自动转义,并不会渲染&lt;h1&gt;元素,而是显示文本形式 如何做到动态设置HTML效果呢?我们可以给元素设置一个dangerouslySetHTML属性传入一个对象,这个对象的__html属性值就相当于innerHTML,就可以动态渲染元素结构了. 1234&lt;div dangerouslySetHTML=&#123;&#123;__html:'&lt;h1&gt;helloworld&lt;/h1&gt;'&#125;&#125; className=\"container\"&gt;&lt;div&gt; 之所以搞这么复杂是因为设置这个属性可能会导致跨站脚本攻击,不必要的情况就不要使用. style普通DOM元素中的style 1&lt;div style=\"font-size:14px;color:red;\"&gt;&lt;div&gt; React中需要把css属性变为对象再传给元素 1&lt;h1 style=&#123;&#123;fontSize:'14px',color:'red'&#125;&#125;&gt;&lt;/h1&gt; style接收一个对象,里面是css属性键值对,原来css带’-‘的属性都需要换成驼峰命名法.我们可以用props或者state中的数据生成样式对象再传给元素,再用setState修改样式,非常灵活. 12&lt;h1 style=&#123;&#123;fontSize:'14px',color:this.state.color&#125;&#125;&gt;&lt;/h1&gt;this.setState(&#123;color:'blue'&#125;) PropTypes和组件参数验证React提供一种机制,可以给组件的配置参数加上类型验证.我们需要安装React提供的第三方库prop-types npminstall --save prop-types 12345678910import React,&#123; Component &#125; from 'react'import PropTypes from 'prop-types'class Card extends Component&#123; static propTypes = &#123; text: PropTypes.string.isRequired &#125;static defaultProps = &#123; ...&#125;&#125; PropTypes提供的参数有:array,bool,func,number,object,string,node,element… react规范组件和方法命名1. static开头的类属性,如`defaultProps`,`propTypes` 2. 构造函数,constructor 3. getter/setter 4. 组件生命周期 5. _开头的私有方法 6. 事件监听方法,handle** 7. render*()表示不同render()内容的函数 高阶组件高阶组件就是一个函数,传给它一个组件作为函数的参数,它返回一个新的组件. 1234567891011121314151617import React,&#123;Component&#125; from 'react'export default (OldComponent,name)=&gt;&#123; class NewComponent extends Component&#123; constructor()&#123; super() this.state = &#123;data:null&#125; &#125; componentWillMount()&#123; let data = localStorage.getItem(name) this.setState(&#123;data&#125;) &#125; render()&#123; return &lt;OldComponent data=&#123;this.state.data&#125;&gt;&lt;/OldComponent&gt; &#125; &#125; return NewComponent&#125; 怎么使用这个高阶组件呢? 12345678import NewComponent from './NewComponent'class InputName extends Component&#123; render()&#123; return &lt;input value=&#123;this.props.data&#125;&gt; &#125;&#125;InputName = NewComponent(InputName,'username')export default InputName 其实高阶组件就是为了组件之间的代码复用.组件可能有着相同的逻辑,把这些逻辑抽取出来,放在高阶组件里进行复用.高阶组件内部包装的组件和被包装的组件通过props传递数据. contextcontext(上下文)是React中一个比较特殊的东西.某个组件只要往自己的context里面放一些状态,这个组件下的所有子组件都可以直接访问而不用通过中间组件一层层传递,它的父组件则不能访问到. context打破了组件之间通过props传递数据的规范,增强了组件间的耦合性.就像全局变量一样,每个组件都能随意访问和修改,这会让程序运行不可预料. 一些第三方状态管理的库就是充分利用了这种机制给我们提供了极大地便利,所以我们一般不手写context,也不要用它,需要时用这些第三方的应用状态管理库即可. 本文参考胡子大哈的React小书,详情请点击","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端 React","slug":"前端-React","permalink":"http://yoursite.com/tags/前端-React/"}]},{"title":"用NodeJS写一个爬虫","slug":"用NodeJS写一个爬虫","date":"2016-12-05T07:45:03.000Z","updated":"2017-12-05T07:51:45.000Z","comments":true,"path":"2016/12/05/用NodeJS写一个爬虫/","link":"","permalink":"http://yoursite.com/2016/12/05/用NodeJS写一个爬虫/","excerpt":"","text":"简介用NodeJS下一个爬虫,用来获取简书首页的文章,然后保存以txt文件的形式保存在本地,数量为20篇. 初始化项目​ npm init || yarn init 安装依赖​ npm install superagent cheerio —save || yarn add superagent cheerio 页面数据下载123456789101112131415161718192021const fs = require(\"fs\")const request = require(\"superagent\")const cheerio = require(\"cheerio\")let reptileUrl = \"http://www.jianshu.com/\"request .get(reptileUrl) .end(function(err,res)&#123; if(err)&#123; &#125; else&#123; let $ = cheerio.load(res.text,&#123;decodeEntities:false&#125;) //每页有20篇文章,找到标题及其href的值 $(\"#list-container .note-list li\").each(function(index,value)&#123; let url = $(v).find(\".title\").attr(\"href\") //url即文章的链接,需要和reptileUrl拼接起来 getContent(url) &#125;) &#125; &#125;) 获取文章内容,保存在本地1234567891011121314151617181920212223242526272829303132function getContent(url)&#123; let adress = reptileUrl + url request .get(adress) .end(function(err,res)&#123; if(err)&#123; &#125;else&#123; let $ = cherrio.load(res.text,&#123;decodeEntities:false&#125;) //文章标题 let title = $(\".article .title\").text() //文章内容 let content = '' $(\".article .show-content p\").each(function(i, v, a) &#123; content += $(v).text(); &#125;) //要写入的数据 let data = &#123; title: title, content: content &#125; //本地保存 fs.writeFile('../data/' + title + '.txt', JSON.stringify(data), 'utf-8', function(err) &#123; if (err) &#123; &#125; else &#123; console.log(\"It's OK !\") &#125; &#125;) &#125; &#125;)&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"node 爬虫","slug":"node-爬虫","permalink":"http://yoursite.com/tags/node-爬虫/"}]},{"title":"鼓楼,什刹海随拍","slug":"鼓楼,什刹海随拍","date":"2016-10-13T10:19:50.000Z","updated":"2017-12-26T06:58:23.000Z","comments":true,"path":"2016/10/13/鼓楼,什刹海随拍/","link":"","permalink":"http://yoursite.com/2016/10/13/鼓楼,什刹海随拍/","excerpt":"","text":"","categories":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/categories/旅行/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/tags/旅行/"}]},{"title":"[阮一峰ES6标准]学习笔记","slug":"阮一峰ES6标准-学习笔记","date":"2016-03-21T02:43:25.000Z","updated":"2017-12-21T02:47:11.000Z","comments":true,"path":"2016/03/21/阮一峰ES6标准-学习笔记/","link":"","permalink":"http://yoursite.com/2016/03/21/阮一峰ES6标准-学习笔记/","excerpt":"","text":"let let声明的变量只在代码块内有效 不存在变量提升 let声明变量之前,该变量都是不可用的,称为暂时性死区 相同作用域内不允许重复声明同一个变量 const const声明一个只读的常量,一旦声明,常量的值不能改变. const一旦声明变量,必须初始化,不赋值就会报错. const保证的其实是保存变量的内存地址不得改动.对于简单数据类型,值就保存在变量指向的内存地址,等同于常量.对于复合类型的数据,变量指向的地址保存的是一个指针. var和function声明的全局变量,是顶层对象的属性.而let,const,class声明的全局变量不再属于顶层对象. 变量的解构赋值从数组和对象中提取值,对变量进行赋值,这就称为解构. 12let [a,b,c] = [1,2,3];//a=1,b=2,c=3let [a,b,c] = [1,2] //解构不成功变量值为undefined 如果等号右边不是数组(或不是可遍历的解构),会报错. 1let [a] = false;//false不是可遍历解构,报错 解构赋值允许指定默认值 1let [a,b=666] = [1]//a=1,b=666 对象也可以用于解构赋值 1234567let &#123;foo,bar&#125; = &#123;foo:'a',bar:'b'&#125;;//foo='a',bar='b'//属性名相同才能取到值let &#123;foo,bar&#125; = &#123;foo:'a',baszz:'b'&#125;;//bar为undefined//&#123;foo&#125;其实就是&#123;foo:foo&#125;的简写let &#123;foo:bar&#125; = &#123;foo:'a'&#125;//bar='a',foo未定义//对象解构赋值也可以指定默认值let &#123;x,y=3&#125;=&#123;x:1&#125;//x=1,y=3 字符串也可用于解构赋值,因此此时,字符串被转换为一个类似数组的对象. 1let [a,b,c,d,e] = 'hello';//a='h',b='e' 函数的参数也可用于解构赋值. 1234function add([x,y=3])&#123; return x + y;&#125;add([1,2]); 字符串的扩展ES6为字符串添加了便利器接口,使得字符串可以被for…of循环遍历. ES5有indexOf用来确定一个字符串是否在另一个字符串中. ES6又提供了三种方法: includes():返回布尔值,表示是否找到了参数字符串 startsWith():返回布尔值,表示是否在原字符串的头部 endsWith():返回布尔值,表示是否在原字符串的尾部 这三个方法都提供了第二个参数,表示搜索的位置. 1234let s =\"hello World\"s.includes(\"hello\")//trues.startsWith(\"hel\")//trues.endsWith(\"rld\")//true repeat()方法返回一个新字符串,表示将元字符串重复n次. 1'hello'.repeat(2);//'hellohello' 模板字符串 12let s = 'world'let a = `hello $&#123;s&#125; !`//a='hello world !' ${}里面不仅可以嵌入变量,还可以嵌入函数. 数值的扩展 Number.isFinite()用来检查一个数值是否为有限的(finite) Number.isNaN()用来检查一个数值是否为NaN. 上面两个方法与传统的全局方法isFinite()和isNaN()的区别在于,传统方法会先调用Number()将非数值转换为数值在判断,新的两个方法只对数值有效,非数组一律返回false. Number.parseInt(); Number.parseFloat();将全局方法移植到Number对象上,使语言逐步模块化. Number.isInteger();用来判断一个值是否为整数. 指数运算符,例如2**3===8; 函数的扩展函数参数的默认值 123456789function log(x,y='world')&#123; console.log(x,y)&#125;log('hello')//hello world//参数是默认声明的,所以不能用let和const再次声明function foo(x=5)&#123; let x = 1;//error const x = 2;//error&#125; rest参数 ES6引入rest参数,用于获取函数的多余参数,rest参数搭配的变量是一个数组,该变量将多余的参数放入数组中.rest参数只能是最后一个参数,否则会报错. 12345678function(...values)&#123; let sum = 0; for(var val of values)&#123; sum += val; &#125; return sum;&#125;add(2,3,5)//10 函数的name属性返回该函数的函数名. 箭头函数 12var f = v=&gt; v;var f = ()=&gt;5;//没有参数或多个参数用()包括,多个函数语句用&#123;&#125; 箭头函数内的this是定义时所在的对象,不是使用时的对象 不可以当做构造函数 不可以使用arguments对象 不可以使用yield命令,不能作为Generator函数 箭头函数中的this的指向是固定的,不可变的. 尾调用就是在函数的最后一步调用另外一个函数. 尾递归函数在最后一步调用自身就是尾递归.尾递归不会发生栈溢出,相对节省内存. 1234function factorrial(n,total)&#123; if(n === 1) return total; return factorial(n-1,n*total)&#125; 函数式编程有一个概念,叫做柯里化,意思就是将多参数的函数转换成单参数的函数形式. 数组的扩展扩展运算符是三个点....它好比rest参数的逆运算,将一个数组转为用逗号分隔的参数序列. 1console.log(...[1,2,3])//1 2 3 由于扩展运算符可以展开数组,所以不再需要apply方法将数组转为函数的函数了. 12345678//ES5function f(x,y,z)&#123;...&#125;var args = [1,2,3]f.apply(null,args)//ES6function f(x,y,z)&#123;...&#125;let args = [1,2,3]f(...args) 扩展运算符的应用 复制数组 12345//ES5const a1 = [1,2,3]const a2 = a1.concat();//ES6cionst a2 = [...a1] 合并数组 1234//ES5arr1.concat(arr2,arr3)//ES6[...arr1,...arr2,...arr3] 字符串转为数组 1[...\"hello\"]//['h','e','l','l','o'] 只要是有Iterator接口的对象都可以用扩展运算符转为数组. Array.from()将类似数组的对象和可遍历对象转换为真正的数组. 扩展运算符转换为数组调用的是遍历器接口Iterator,Array.from()不仅可以支持可遍历对象还支持类似数组的对象,既任何拥有length属性的对象都可以通过Array.from转换为数组,而扩展运算符不行. 12345let arrayLike = &#123;'0':'a','1':'b',length:2&#125;//ES5var arr1 = [].slice.call(arrayLike)//ES6let arr2 = Array.from(arrayLike) Array.of()用于将一组值转换为数组.因为Array()和new Array(),由于参数不同导致行为不统一.一个参数指定数组的长度,不少于两个才能组成新数组,这样会导致行为有差异.Array.of()基本可以替代Array()和new Array(). 1Array.of(1,2,3);//[1,2,3] find()用于找出第一个符合条件的数组成员.他的第一个参数是一个回调函数,所有成员依次执行该函数,直到找到第一个为true的成员,没有找到返回undefined.该回调函数一个接受3个参数,分别是value,index,arr. 1234[1,4,-5,10].find((n)=&gt;&#123;n&lt;0&#125;)//-5[1,4,-5,10].find(function(v,i,a)&#123; return value &gt; 9&#125;)//10 findIndex()与find()用法类似,用于找出符合条件成员的索引,都不符合返回-1.由于数组的IndexOf方法无法识别数组的NaN成员,而find和findIndex弥补了数组indexOf的不足. 123[1,4,-5,10].findIndex(function(v,i,a)&#123; return value === 4;//1&#125;) fill()填充一个数组.接受第二和第三个参数分别为起始位置和结束位置之前. 1['a','b','c'].fill(7,1,2)//['a',7,'c'] entries(),keys(),values()都返回一个遍历器对象,可以用for…of进行遍历.entries()是对键值对的遍历,keys()是对键名的遍历,values()是对值得遍历. 123for(let index of ['a','b'].keys())&#123; console.log(index);//0 //1&#125; 数组的includes()返回一个布尔值表示数组是否包含给定的值,与字符串的includes()方法类似.另外Map和Set数据结构有一个has方法,需要注意与includes区分.Map的has用来查找key,Set的has用来查找value. 1[1,2,3].includes(3)//true 对象的扩展属性的简写形式 123var foo = &#123;x:x,y:y&#125;;//等同于let foo = &#123;x,y&#125; 属性名表达式 ES6允许字面量定义对象时,用表达式作为对象的属性名. 123456let name = 'foo'let obj = &#123; [name]: 'foo', ['a'+'bc']: 123&#125;//&#123;foo:'foo','abc':123&#125; Object.is()用来比较两个值是否严格相等,与===行为基本一致.不同之处在于+0不等于-0,NaN等于NaN 1234+0 === -0;//trueObject.is(+0,-0)//falseNaN === NaN;//falseObject.is(NaN,NaN);//true Object.assign()用于对象合并,将源对象所有可枚举属性复制到目标对象. 如果只有一个参数,直接返回该对象. 同名属性,后者会覆盖前者 Object.assign方法实行的是浅拷贝.如果某个属性的值是对象,那么目标对象拷贝的是这个对象的引用. Object.assign的用途. 为对象添加属性 为对象添加方法(将函数放在空对象中) 克隆对象(和一个空对象合并) Object.setPrototypeOf()设置一个对象的prototype对象,返回参数对象本身,它是ES6整数推荐的设置原型对象的方法. 1234let a = &#123;a:1&#125;let proto = &#123;b: 2&#125;Object.setPrototypeOf(a,proto);//a.b === 2//上面代码将proto对象设置为a对象的原型 Object.getPrototypeOf()用于读取一个对象的原型对象. 1Object.getPrototypeOf(a);//&#123;b:2&#125; super关键字指向当前对象的原型对象. Object.keys()返回一个数组,成员是对象所有可遍历属性的键名. Object.values()返回一个数组,成员是对象所有可遍历属性的值. Object.entries()返回一个数组,成员是对象所有可遍历属性的键值对数组. 对象也可用于解构赋值以及扩展运算符 1234let &#123;x,...y&#125; = &#123;x:1,y:2,z:3&#125;x // 1y// &#123;y:2,z:3&#125;let z = &#123;...y&#125;//&#123;y:2,z:3&#125; Null传导运算符?. 123const first = (msg &amp;&amp; msg.body&amp;&amp;msg.body.user || 'default')//使用null传导运算符const first = (msg?.body?.user || 'default') SymbolES6引入了一种原始数据类型Symbol,表示独一无二的值.它是js第七种数据类型,分别是undefined,null,Boolean,String,Number,Object,Symbol 由于symbol不是对象,而是数据类型,所以不能使用new,他是一种类似于字符串的的数据类型. 12345let s = Symbol();let s1 = Symbol();s === s1;//false,Symbol不能参与运算.let obj = &#123;&#125;;obj[s] = 'hello'//Symbol作为属性名不能用.运算形式,且不能被遍历到 Set和MapES6提供了新的数据结构Set,它类似于数组,但是成员都是唯一的,没有重复的值. 12//去除数组的重复成员[...new Set(2,3,2,1,2,3)] Set,prototype.constructor: 构造函数,默认就是Set函数 Set.prototype.size: 返回set实例的成员总数 Set的4个操作方法 add(value): 添加某个值,返回set结构本身 delete(value):删除某个值,返回一个布尔值,表示是否成功 has(value): 返回一个布尔值,表示是否为Set成员. clear():清除所有成员. Set的4个遍历方法 keys():返回键名的遍历器 values():返回值得遍历器(默认遍历生成函数) entries():返回键值对的遍历器 forEach():使用回调函数遍历每个成员 ES6提供了Map数据类型,类似于对象,但他的”键”的范围不限于字符串,各种类型的值都可以作为键. Map的实例属性与操作方法: size: Map结构的成员总数 set(key,value):设置键值,返回整个结构 get(key): 读取某个键的值,找不到key返回undefined has(key):返回布尔值,表示某个键是否在当前Map对象中 delete(key):删除某个键,返回布尔值表示是否成功. clear():清除所有. Map结构提供的遍历方法与Set相同. promise对象promise是异步编程的一种解决方案.它接受一个函数作为参数,函数有两个参数resolve和reject有js引擎提供,resolve函数将promise有未完成变为成功,reject由未完成变为失败. promise实例生成后可以用then指定resolved和rejected状态的回调函数,并且then返回一个新的promise实例,所以可以链式调用. 12345678910111213const promise = new Promise(function(resolve,reject)&#123; if(/*成功*/)&#123; resolve(value) &#125;else&#123; reject(error) &#125;&#125;)promise.then(function(value)&#123; //success&#125;,function(error)&#123; //error&#125;)//一般来说,不要再then中定义rejected状态的回调函数,既then的第二个参数,而应该总是使用catch方法. promise.catch是.then(null,rejection)的别名,指定发生错误是的回调函数. promise.all将多个promise实例包装成一个promise实例.全部成功才成功,有一个失败就是失败. promise.race将多个promise包装为一个,只要其中有一个先改变状态,整个状态就会改变. promise.finally方法用于指定不管promise的最后状态无论怎样都会执行,它接受一个普通的回调函数作为参数,不管怎样都必须执行. Iterator和for…of循环当使用for…of循环某种数据结构时,该循环会自动寻找Iterator接口. 一个对象只要具备Symbol.iterator属性就代表该对象可遍历. 默认调用Iterator接口的场合: 解构赋值let [x,y] = [1,2] 扩展运算符[...arr] yield后面如果跟的是可遍历结构就会调用遍历器接口`yield\\ [2,3,4]` for…of,Array.from()… 遍历器对象除了具有next()函数,还要return()和throw() for..of与其他遍历语法比较. for循环 数组的forEach(无法跳出循环,break,return都不行) for …in(主要是循环对象而设计,不适用于遍历数组) for…of,与for..in一样简洁,可以跳出循环… Generator函数Generator是ES6题提供的异步编程解决方案.可以把它理解为一个状态机,封装了多个状态.还是一个遍历器对象生成函数. Generator函数的特征:function与函数名之间有一个*号,函数体内部使用yield表达式定义不同的内部状态. 12345678910function* helloWorld()&#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorld();//generator函数调用后该函数并不执行,返回的也不是函数运行结果,而是遍历器对象Iterator.然后调用遍历器对象的next方法使得指针移动到下一个状态.hw.next();//&#123;value:'hello',done:fasle&#125;hw.next();//&#123;value:'world',done:false&#125;hw.next();//&#123;value:'ending',done:true&#125; 由于Generator函数返回一个遍历器对象,调用next才会遍历下一个内部状态,所以其实他是一个可以暂停执行的函数,yield就是暂停标志.next()遇到yield就会暂停后面的操作,并把yield后面表达式的值作为返回的value值,下一次调用next,再继续执行,知道遇到yield或return为止.另外yield表达式在其他地方使用都会报错. next()可以带一个参数,作为上一次yield表达式的返回值. 12345678910111213function* foo(x)&#123; var y = 2*(yield (x+1)); var z = yield (y/3); return (x+y+z);&#125;var a = foo(5);a.next();//&#123;value:6,done:fasle&#125;a.next();//&#123;value:NaN,done:fasle&#125;a.next();//&#123;value:NaN,done:fasle&#125;var b = foo(5);b.next();//&#123;value:6,done:fasle&#125;b.next(12);//&#123;value:8,done:fasle&#125;b.next(13);//&#123;value:42,done:fasle&#125; for…of可以自动遍历Generator函数生成的遍历器对象,并且不再需要调用next方法.但函数return 的值不会再循环中. 在Generator函数中调用Generator函数是没有效果的,这就需要用到yield*表达式,用来达成以上目的.并且任何数据结构只要有Iterator接口,就可以使用yield*遍历 123456function* bar()&#123; yield 'a'; yield* foo(); yield 'b'; yield* [1,2,3]&#125; async函数ES6引入了async函数,使异步操作更加方便.async函数就是Generator函数的语法糖.它将*替换成async,将yield替换成await,仅此而已. 12345678910111213const gen = function* ()&#123; cosnt f1 = yield readFile('/etc/a.txt') const f2 = yield readFile('/etc/b.txt') console.log(f1.toString()); console.log(f2.toString());&#125;const gen = async function()&#123; const f1 = await readFile('/etc/a.txt') const f2 = await readFile('/etc/b.txt') console.log(f1.toString()); console.log(f2.toString());&#125; async对generator的改进 内置执行器.async函数的执行与普通函数一样gen() 更好的语义.比起*与yield,语义更清楚. 更广的适用性.async函数的await命令后面可以是promise对象和原始类型的值(但此时等同于同步操作). 返回值是promise对象,而generator返回的是一个Iterator遍历器.而async可以看做多个异步操作包装的promise对象,而await命令就是内部then的语法糖. async函数内部return语句返回的值会成为then方法回调函数的参数 1234async function f()&#123; return 'helloWorld'&#125;f().then(v=&gt;console,log(v))//'helloWorld' async函数内部抛出错误会导致promise对象变为reject状态.错误对象会被catch方法回调函数接收. 正常情况下await后面是一个peomise对象,如果不是,会转成一个立即resolve的promise for await of 用来遍历异步的iterator接口. classES6引入class的概念,作为对象的模板,通过class关键字来定义类. class其实只是一个语法糖,他的大部分功能ES5都可以做到,只是让对象原型的写法更像面向对象编程语法而已. 123456789101112131415161718192021//ES5function Point (x,y)&#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function()&#123; return this.x+','+this.y&#125;var p = new Point(1,2)//ES6class Point&#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; toString()&#123; return this.x+','+this.y &#125;&#125;Point === Point.prototype.constructor//truevar p = new Point(); toString是Point类内部定义的方法,它是不可枚举的,这与ES5不一致. 类不存在变量提升 class的静态方法,类相当于实例的原型,所有类中定义的方法都会被实例继承,如果在一个方法前加上static关键字就表示该方法不会被实例继承,而是直接通过类来调用,这就成为静态方法.静态方法中的this指的是类而不是实例. 12345678class Foo()&#123; static hello()&#123; return 'helloWorld' &#125;&#125;Foo.hello()//'helloWorld'var h = new Foo();h.hello()//报错typeError... 父的静态方法可以被子类继承 123456789101112131415161718192021class Foo()&#123; constructor(x,y)&#123; &#125; static hello()&#123; return 'helloWorld' &#125; toString()&#123; ... &#125;&#125;class Bar extends Foo()&#123; constructor(x,y,z)&#123; super(x,y)//调用父类的constructor(x,y) this.z = z; &#125; toString()&#123; return this.z +','+super.toString &#125;&#125;Bar.hello()//'helloWorld' super关键字表示父类的构造函数,用来新建父类的this对象. 子类必须在constructor方法中调用super方法,否则新建实例会报错,这是因为子类没有自己的this对象而是继承父类的this对象,然后对其加工,不调用super()子类就得不到this对象. 如果子类没有定义constructor,这个方法会被默认添加,super也会默认添加.只要调用super才能使用this关键字. 修饰器修饰器函数用来修改类的行为,是对一个类进行处理的函数,修饰器函数的第一个参数就是说要修身的目标类.如果觉得一个参数不够用,可以再修饰器外再封装一层函数. 123456789@testableclass MyTest()&#123; ...&#125; function testable(target)&#123; target.isTest = true;//静态属性 target.prototype.isOk = false;//实例属性 &#125; MyTest.isTest // true 修饰器实在代码编译时发生的,这意味着修饰器本质就是编译时执行的函数. Moduleexport 用于规定模块的对外接口. 1234567export var a = 'a'export var b = 'b'export &#123;a,b&#125;export default&#123; a, b&#125; import 用于输入其他模块提供的功能. 123import &#123;a,b&#125; from './xxx'import a as A from './xxx'import * as num from './xxx' 如果import要取代Node的require方法就形成了障碍,因为require是运行时加载模块,而import无法取代require的动态加载功能.CommonJS输出的是一个值得拷贝,而ES6模块输出的是值得引用. 浏览器加载ES6模块,也使用&lt;script&gt;,但要加入type=’module’属性告诉浏览器这是一个ES6模块. 1&lt;script type=\"module\" src=\"./foo.js\"&gt;&lt;/script&gt;","categories":[],"tags":[]},{"title":"深圳大梅沙看海","slug":"深圳大梅沙看海","date":"2015-10-29T06:18:00.000Z","updated":"2017-12-26T06:30:29.000Z","comments":true,"path":"2015/10/29/深圳大梅沙看海/","link":"","permalink":"http://yoursite.com/2015/10/29/深圳大梅沙看海/","excerpt":"","text":"昨日风和日丽,携友出行,至大梅沙海滨公园,拍数照以作留念.","categories":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/categories/旅行/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/tags/旅行/"}]},{"title":"重温<<计算机操作系统>>","slug":"重温-计算机操作系统","date":"2015-10-18T07:19:25.000Z","updated":"2017-11-14T06:02:28.000Z","comments":true,"path":"2015/10/18/重温-计算机操作系统/","link":"","permalink":"http://yoursite.com/2015/10/18/重温-计算机操作系统/","excerpt":"","text":"并发与并行概念并行是指两个或多个事件在同一时刻发生,而并发是两个或多个事件在同一时间间隔内发生.在多道程序环境下,并发性是指在一段时间内宏观上有多个程序在同时运行,但在单处理机系统中,每一时刻却仅能有一道程序执行,故微观上这些程序只能是分时的交替执行.倘若在多处理机,这些可以并发执行的程序便可分配到多个处理机上,实现并行执行. 理解如果某个系统支持两个或多个动作同时存在,name这个系统就是一个并发系统.如果某个系统支持两个或多个动作同时执行,那么这个系统就是一个并行系统.并发系统与并行系统这两个定义之间的关键差异在于存在这个词. 在并发程序中可以同时拥有两个或多个线程,这意味着,如果程序在单核处理器上运行,那么这两个线程将交替换入或换出内存.这些线程是同时存在的,每个线程都处于执行过程中的某个状态.如果程序能够并行执行,那么就一定是运行在多核处理器上的.此时,程序中的每个线程都将分配到一个独立的处理器核上,因此可以同时运行. 我相信你已经能够得出结论:”并行概念是并发概念的一个子集”.也就是说,你可以编写一个拥有多个线程或进程的并发程序,但如果没有多核处理器来执行这个程序,那么就不能以并行的方式来运行代码.因此,凡是在求解单个问题涉及多个执行流程的编程模式或执行行为,都属于并发编程的范畴. 摘自:&lt;&lt;并发的艺术&gt;&gt;-[美]布雷谢斯 Erlang 之父 Joe Armstrong 用一张5岁小孩都能看懂的图解释了并发与并行的区别.从图中可以看出,并发是两个队列交替使用一台咖啡机,并行是两个队列同时使用两台咖啡机.如果串行,一个队列使用一台咖啡机.并发和并行都可以是多个线程,就看这些线程能不能同时被多个CPU执行,如果可以说明是并行,而并发是多个线程被一个CPU轮流切换着执行. 进程与线程概念对进程较为经典的定义有: 1. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动. 2. 进程是程序在一个数据集合上运行的过程,它是系统进行资源分配和调度的一个独立单位. 3. 系统为每个进程定义了一个数据结构-进程控制块(PCB).OS根据PCB来对并发执行的进程进行控制和管理. 线程和进程的比较: 1. 再引入线程的操作系统中,通常一个进程都拥有若干个线程,至少有一个线程. 2. 进程为资源拥有的最小单位,而线程作为调度和分派的基本单位,线程不拥有系统资源,可以访问资源. 理解进程和线程的主要差别在于他们是不同的操作系统资源的管理方式.进程有独立的地址空间,一个进程崩溃后,在保护模式下不会对其他进程产生影响,而线程只是一个进程中的不同执行路径.线程有自己的堆栈和局部变量,但线程没有单独的地址空间,一个线程死掉就等于整个进程死掉,所以在进程切换时,耗费资源较大,效率变差.但对于一些要求同时进行并且又要共享某些变量的并发操作,只能用进程,不能用线程. 生产者消费者问题概念生产者消费者问题是一个经典的多进程同步问题,也叫缓存绑定问题. 既有两个进程:一组生产者进程和一组消费者进程共享一个初始值为空固定大小为n的缓存区.生产者的工作是制造一段数据,只要缓存没满就放入缓存区,否则必须等待,如此反复.同时,只要缓存区不为空,消费者才能从中取出消息,一个取出一段数据,否则只能等待.由于缓存区是临界资源,它只允许一个生产者放入消息,或一个消费者从中取出消息. 问题的核心是要保证不让生产者在缓存满的时候还要向内写数据,不让消费者试图从空的缓存中取出数据. 理解生产者和消费者对缓存区互斥访问是互斥关系,同时又是相互协作关系,即同步关系.那么需要解决的是互斥和同步PV操作的位置.使用”进程间通信”即可解决唤醒问题: 我们使用了两个信号标:full和empty.信号量mutex作为互斥信号量.用于控制互斥访问缓存池,互斥信号量初始值为1.信号量full用于记录当前缓冲池中”满”缓冲区数,初始值为0.信号量empty用于记录当前缓存区”空”缓存区数,初始值为n.新的数据增加后,full增加,empty减少.如果生产和试图在empty为0时减少其值,生产者就会被”催眠”.下一轮中有数据消费掉时,empty就会增加,生产者就会被”唤醒”.1234567891011121314151617181920212223semaphore mutex = 1;//临界区互斥信号量semaphore empty = n;//空闲缓存区semaphore full = 1;//缓存区初始化为空produce()&#123; while(1)&#123; produce an item in dextp;//生产数据 P(empty);//获取空缓存区单元 P(mutex);//进入临界区 add nextp to buffer;//将数据放入缓存区 V(mutex);//离开临界区,释放互斥信号量 V(full)//满缓存区加1 &#125;&#125;consume()&#123; while(1)&#123; P(full);//获取满缓存区单元 P(mutex);//进入临界区 remove an item from buffer;//拿走数据 V(mutex);//离开临界区 V(empty);//空缓存区单元加1 consume the item//消费数据 &#125;&#125;","categories":[{"name":"理解计算机","slug":"理解计算机","permalink":"http://yoursite.com/categories/理解计算机/"}],"tags":[{"name":"计算机基础 操作系统","slug":"计算机基础-操作系统","permalink":"http://yoursite.com/tags/计算机基础-操作系统/"}]}]}