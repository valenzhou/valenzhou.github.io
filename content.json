{"meta":{"title":"Mr.喵的网络日志","subtitle":null,"description":null,"author":"ValenZhou","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"学习CSS Grid布局","slug":"学习CSS-Grid布局","date":"2017-12-13T07:39:20.000Z","updated":"2017-12-13T07:42:01.000Z","comments":true,"path":"2017/12/13/学习CSS-Grid布局/","link":"","permalink":"http://yoursite.com/2017/12/13/学习CSS-Grid布局/","excerpt":"","text":"CSS Grid 布局是CSS中最强大的布局系统,与flexbox的一维布局系统不同,CSS Grid是一个二维布局系统,它可以同时处理行和列. 第一个Grid布局css Grid布局由两个核心组成部分,warpper(父元素)和items(子元素).warpper是实际的grid(网格),items是网格的内容. 下面是一个warpper元素,内部包含了6个items: 12345678&lt;div class=\"warpper\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 要把warpper元素变成一个grid(网格),只需要把它的display属性设置为grid即可. 123.warpper&#123; display:grid;&#125; 这时我们还没有写任何样式,他会简单的将6个div堆叠在一起. Columns(列)和rows(行)为了使其成为二维的网格容器,我们需要定义行和列.让我们创建两行三列,使用grid-template-cloumns和grid-template-rows属性. 12345.warpper&#123; display:grid; grid-template-rows: 100px 50px; grid-template-cloumns: 100px 80px 60px;&#125; 我们为grid-template-cloumns写入了3个值,这样我们就得到了3列,每列的值代表列的宽度.而grid-template-rows代表行数及行的高度. 放置items(子元素)为了帮助理解,我们在每个items(子元素)加上单独的class. 12345678&lt;div class=\"warpper\"&gt; &lt;div class=\"item1\"&gt;1&lt;/div&gt; &lt;div class=\"item2\"&gt;2&lt;/div&gt; &lt;div class=\"item3\"&gt;3&lt;/div&gt; &lt;div class=\"item4\"&gt;4&lt;/div&gt; &lt;div class=\"item5\"&gt;5&lt;/div&gt; &lt;div class=\"item6\"&gt;6&lt;/div&gt;&lt;/div&gt; 现在我们来创建一个 3*3的grid: 12345.warpper&#123; display:grid; grid-template-rows: 100px 100px 100px; grid-template-cloumns:100px 100px 100px;&#125; 我们只在页面上看到3-2的grid,而我们定义的是3-3的grid.这是因为我们只有6个items来填充这个网格.我们我们再追加3个items,name最后一行也会被填满. 要定位和调整items大小,可以使用grid-cloumn和grid-row属性来设置. 1234.item1&#123; grid-cloumn-start: 1; grid-cloumn-end: 4;&#125; 上面的样式表示,我们希望item1占据从第一个网格线开始,到第四条网格线结束.换句话说它将独占一行.而剩下的items都推到了下一行. 这种形式也可以缩写为: 123456.item1&#123; grid-cloumn: 1/4;&#125;.item3&#123; grid-row: 2/4;&#125; 相关术语 网格容器(Grid):应用display:grid的元素,items的直接父级元素. 网格项(items): 网格容器的直接子元素,后代元素不是. 网格线(Grid-line):构成网格结构的分界线. 网格轨道(Grid-Track):两条相邻网格线之间的空间. 网格单元格(Grid-cell):两个相邻行与相邻列之间的空间. 网格区域(Grid-Area):四条网格线包围的总空间. 父元素 网格容器属性display将元素定义为网格容器,并为其建立新的网格式上下文. grid : 生成一个块级网格 inline-grid: 生成一个内联网格 subgrid: 嵌套的子网格. 在网格容器中使用float,clear,column,vertical-align不会产生任何效果. grid-template-cloumns/rows使用空格分割值列表,用来定义网格的行和列.可以是长度值和百分比,和自动分配(auto)或网格线名称. grid-template-areas指定Grid Area名称来定义网格模板.一个.号代表一个空的单元.你可以使用任意数量的.只要这些.之间没有空隙隔开就表示一个个的单元格. :由items的grid-area指定的区域名称 .(点号):代表一个空网格单元 none:不定义网格区域 12345678910111213141516.container&#123; display:grid; grid-template-rows:auto; grid-template-cloumns:50px 50px 50px 50px; grid-template-areas: \"header header header\" \"main main . sidebar\" \"footer footer footer footer\"&#125;.item-a&#123; grid-area:header;&#125;.item-b&#123; grid-area:main;&#125;... 当你命名网格区域后,该区域两端的网格线实际上是自动命名的,如果你的网格区域名字是foo,则起始行网格线和列网格线是foo-statrt,最后的网格线是foo-end.则意味着一个网格线可能有很多名称. grid-template用于定义grid-template-rows,grid-template-cloumns,和grid-template-areas的缩写. none:将所有的属性设置为初始值. subgrid:将rows和cloumns设置为subgrid,areas设置为初始值. /:将rows和cloumns设置为特定值,areas为none. grid-column-gap/grid-row-gap指定网格线的大小,可以把它想象为设置列/行之间间距的宽度.值为长度值. grid-gapgrid-column-gap/grid-row-gap的缩写语法 justify-items网格容器的水平对其方式,这些行为也可以通过items的justify-self属性设置: start 左侧对其 end 右侧对其 center 居中对齐 stretch 填满区域宽度 align-items网格容器的垂直对齐方式: start 顶部对齐 end 底部对齐 center 垂直居中 stretch 填满区域高度 justify-content/align-content有时,网格容器的内容小于整体容器的大小,可以设置内容在容器中的对齐方式. start 左对齐 end 右对齐 center 居中 stretch 填充 space-around 左右两边都有空间,空格之间距离相等 space-between 左右两边没有空间,空格之间距离相等 space-evenly 左右和每个空间距离相等 grid-auto-columns/grid-auto-rows指定自动生成隐式网格轨道,但定义行和列自动超出网格范围时,隐式网格轨道创建.值为长度,百分比等等. grid-auto-flow如果你有一些未明确放置的网格,自动放置算法会自动放置这些项. row: 依次填充每行 column:依次填充每列 dense: 出现较小的网格项时,尝试填充网格中较早的空缺.但它可能导致你的网格项出现混乱. 子元素 网格项items属性grid-column-start/end通过指定网格线来确定网格在容器中的列的起始位置 grid-row-start/end通过指定网格线来确定网格在容器中的行的起始位置 grid-column/grid-row上面两者的缩写 grid-area为网格项提供一个名词,一遍容器grid-template-areas属性创建模板进行引用.也可以作为grid-row和grid-cloumn的缩写. justify-self/align-selfitems的水平/垂直对其方式","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端 css","slug":"前端-css","permalink":"http://yoursite.com/tags/前端-css/"}]},{"title":"vue项目中的小总结","slug":"vue项目中的小总结","date":"2017-05-21T06:45:23.000Z","updated":"2017-11-22T08:06:23.000Z","comments":true,"path":"2017/05/21/vue项目中的小总结/","link":"","permalink":"http://yoursite.com/2017/05/21/vue项目中的小总结/","excerpt":"","text":"单文件组件中data必须是一个函数,然后返回一个对象.避免多个组件数据混乱.1234567 export default &#123; data()&#123; return &#123; a: \"123\", &#125; &#125;&#125; 列表循环时,尽量使用key,避免元素复用1&lt;div v-for=\"(item,index) in array\" :key=\"index\"&gt;&lt;/div&gt; 在vue中使用less安装less及less-loader依赖 1npm install less less-loader --save-dev 修改webpack配置文件 在单文件组件中使用 1&lt;style lang=\"less\" scoped&gt; $nextTick的用法异步更新队列:Vue在观察到数据变化时不会直接更新Dom,而是开启一个队列,并缓冲在同一事件循环中发生的所有数据变化,然后去除重复数据,避免重复计算和dom操作,然后在下一个事件循环tick中,刷新队列并执行实际(已去重)的工作.$nextTick就是用来知道什么时候dom更新完成的. 123&lt;div id=\"div\" v-if=\"isShow\"&gt;这是一段文本&lt;/div&gt;&lt;button @click=\"getText\"&gt;获取div内容&lt;/button&gt;&lt;!-- 当我们点击按钮时,获取div的文本 --&gt; 1234567getText: function()&#123; this.isShow = true; this.$nextTick(function()&#123; var text = document.getElementById('div').innerText; console.log(text); &#125;)&#125; webpack打包上传服务器后项目图片路径的问题1. 解决方式一: 修改config文件中index.js里assetsPublicPath为&apos;./&apos;, 然后修改webpack.base.conf.js里的url-loader的limit,根据文件大小相应的修改. 但是修改后打包的文件比较大,影响页面加载. 2. 解决方式二: 修改config文件中index.js里assetsPublicPath为&apos;./&apos;,然后修改源代码中css的图片路径为绝对路径, 静态资源由之前的src下的assets文件转移到src同级的static文件下新建一个img文件. 如果该项目有两级以上的域名,就在绝对路径前加上该子域名,如&apos;/XXX/static/img/a.png&apos; scoped下尽量不要使用标签选择器scoped下尽量不要使用标签选择器,会影响页面性能. vue组件添加原生事件vue组件添加原生事件,必须在事件后添加.native修饰符,否则事件不会生效. 在vue中使用TypeScript在vue中使用TypeScript 1. 安装依赖 12npm i vue-class-component vue-property-decorator --savenpm i ts-loader typescript tslint tslint-loader tslint-config-standard --save-dev 2. 配置webpack - 找到&apos;./build/webpack.base.conf.js&apos;添加 1resolve: &#123;extensions: ['.js', '.vue', '.json', '.ts'],&#125; - 找到module.rules,添加对.ts的解析 1234567891011121314&#123; test: /\\.ts$/, exclude: /node_modules/, enforce: 'pre', loader: 'tslint-loader'&#125;,&#123; test: /\\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: &#123; appendTsSuffixTo: [/\\.vue$/], &#125;&#125;, - 添加根路径tsconfig.json文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; // 编译选项 \"compilerOptions\": &#123; // 输出目录 \"outDir\": \"./output\", // 是否包含可以用于 debug 的 sourceMap \"sourceMap\": true, // 以严格模式解析 \"strict\": true, // 采用的模块系统 \"module\": \"esnext\", // 如何处理模块 \"moduleResolution\": \"node\", // 编译输出目标 ES 版本 \"target\": \"es5\", // 允许从没有设置默认导出的模块中默认导入 \"allowSyntheticDefaultImports\": true, // 将每个文件作为单独的模块 \"isolatedModules\": false, // 启用装饰器 \"experimentalDecorators\": true, // 启用设计类型元数据（用于反射） \"emitDecoratorMetadata\": true, // 在表达式和声明上有隐含的any类型时报错 \"noImplicitAny\": false, // 不是函数的所有返回路径都有返回值时报错。 \"noImplicitReturns\": true, // 从 tslib 导入外部帮助库: 比如__extends，__rest等 \"importHelpers\": true, // 编译过程中打印文件名 \"listFiles\": true, // 移除注释 \"removeComments\": true, \"suppressImplicitAnyIndexErrors\": true, // 允许编译javascript文件 \"allowJs\": true, // 解析非相对模块名的基准目录 \"baseUrl\": \"./\", // 指定特殊模块的路径 \"paths\": &#123; \"jquery\": [ \"node_modules/jquery/dist/jquery\" ] &#125;, // 编译过程中需要引入的库文件的列表 \"lib\": [ \"dom\", \"es2015\", \"es2015.promise\" ] &#125;&#125; - 添加根路径tslint.json文件 123456&#123; \"extends\": \"tslint-config-standard\", \"globals\": &#123; \"require\": true &#125;&#125; - 在src下创建vue-shim.d.ts 1234declare module \"*.vue\" &#123; import Vue from \"vue\"; export default Vue;&#125; 之后再代码中引入.vue文件时需要加上.vue后缀,因为ts默认只识别*.ts文件 - 改造APP.vue文件 12345678&lt;script lang=\"ts\"&gt; import Vue from 'vue' import Component from 'vue-class-component' @Component(&#123;&#125;) export default class App extends Vue &#123; &#125;&lt;/script&gt; - 修改main.js为main.ts,并修改&apos;./build/webpack.base.conf.js&apos;中的entry为 `{app: &apos;./src/main.ts&apos;}`","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"vue 前端","slug":"vue-前端","permalink":"http://yoursite.com/tags/vue-前端/"}]},{"title":"学习React","slug":"学习React","date":"2017-01-14T03:12:17.000Z","updated":"2017-12-14T03:35:54.000Z","comments":true,"path":"2017/01/14/学习React/","link":"","permalink":"http://yoursite.com/2017/01/14/学习React/","excerpt":"","text":"安装​ creat-react-app 脚手架安装 ​ npm install -g creat-react-app ​ 初始化安装 ​ creat-react-app hello-react ​ 启动 ​ cd hello-react ​ npm start 使用jsx12345678910111213141516import React,&#123;Component&#125; from 'react'import ReactDOM from 'react-dom'import './index.css'class Header extends Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;hello React&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;header/&gt;, document.getElementById(\"root\")) jsx在编译时会变成相应的js对象描述. react-dom负责把这个js对象描述变成dom元素并渲染. Reader方法我们在编写组件时,需要继承react的Component,一个组件类必须实现一个render方法,这个方法返回一个jsx对象,需要注意的是,必须用一个外层的元素把所有内容包裹起来,而不能是几个元素. 表达式插入在jsx中可以插入js表达式,表达式返回的结果会渲染在页面上,表达式用{}包裹,如果包裹的是一个对象,在对象的外面也要加上{}. {}内可以放任何js的代码.不仅仅可以放在标签内部,也可以放在标签属性上. &lt;a className={className}/&gt; 因为class,和for是js关键字,所以在react中用className和htmlFor代替. 条件返回我们可以根据不同的条件返回不同的jsx. 1234567891011121314render()&#123; const isGood = true return ( &lt;div&gt; &lt;h1&gt; &#123; isGood ?&lt;strong&gt;isGood&lt;/strong&gt; :&lt;span&gt;is bad&lt;/span&gt; &#125; &lt;/h1&gt; &lt;/div&gt; )&#125; 如果你想要隐藏一个元素,返回一个null即可. jsx元素变量jsx元素就是js对象,那么jsx元素其实可以像js对象一样赋值给变量,作为函数参数传递或作为函数返回值. 12345678910111213141516171819202122232425//作为变量render()&#123; const isGood = true const good = &lt;strong&gt;isGood&lt;/strong&gt; const bad = &lt;span&gt;isBad&lt;/span&gt; return( &lt;div&gt; &lt;h1&gt; &#123;isGood?good:bad&#125; &lt;/h1&gt; &lt;/div&gt; )&#125;//作为函数参数传递renderGood(good,bad)&#123; const isGood = true return isGood?good:bad&#125;render()&#123; return( &lt;div&gt; &#123;this.renderGood(&lt;strong&gt;isGood&lt;/strong&gt;,&lt;span&gt;isBad&lt;/span&gt;)&#125; &lt;/div&gt; )&#125; 组件的组合,嵌套和组件树自定义的组件必须用大写字母开头,普通html标签用小写字母开头. 组件之间可以组合,嵌套.就像普通的html标签一样使用就可以,这样组合嵌套最后构成一个组件树,来表示它们之间的关系. 事件监听在react中监听事件甚至需要给监听的元素加上类似于onClick和onKeyDown这样的属性,紧跟的是一个表达式插入,这个表达式返回一个实例方法. 在react中不需要调用浏览器原生的addEventListener进行事件监听,react帮我们封装好了一系列的on*的属性,而且不用考虑不同浏览器之间的兼容问题.如果需要用到事件对象event,在函数中传入e参数即可,react把event对象也做了封装. 一般在某个类的实例方法中,this指的就是这个实例本身,但在react中,调用你传给它方法的时候,并不是通过对象方法的方式调用(this.handleclick),而是通过函数调用(handleClick),所以在事件监听函数中的this是null或undefined.当你想在函数中使用当前实例的时候,需要手动将实例方法bind到当前实例再传给react,这种方式在react中非常常见. 这些on*事件只能用在普通的html元素上,不能用在组件标签上 组件的state和setState一个组件的显示形态是由它的数据状态和配置参数决定的.一个组件可以拥有自己的状态,就像一个点赞按钮,有点赞状态和未点赞状态,并可以再这两种状态之间来回切换.state就是存储这种可变化的状态的.改变状态时不能直接赋值,可以使用setState方法来改变状态.当我们调用setState时,react会更新组件状态,重新调用render方法,然后再把render方法所渲染的最新内容显示到页面上.state方法接受一个对象或函数作为参数如果我们用this.state=XXX,React就没办法知道你修改了组件的状态. state接收对象参数12345678910constructor(props)&#123; super(props) this.state = &#123; name: 'tom', isLicked: false &#125;&#125;handleClick()&#123; this.setState(&#123;isLicked: !this.state.isLicked&#125;)&#125; state接收函数作为参数再调用setState时,react不会马上修改state,而是把这个对象放到一个更新队列中,稍后才回从多个队列中把新状态计算合并提取出来合并到state,再触发更新 12345678910111213141516171819//对象作为参数handClick()&#123; this.setState(&#123;count:0&#125;)//this.state.count还是undefinedthis.setState(&#123;count: this.state.count+1&#125;)//undefined+1=NaNthis.setState(&#123;count:this.state.count+2&#125;)//NaN+2=NaN&#125;//函数作为参数可以接受一个参数作为上次setState的返回值handClick()&#123; this.setState((prevState)=&gt;&#123; return &#123;count:0&#125;//0 &#125;) this.setState((prevState)=&gt;&#123; return &#123;count: prevState.count +1&#125;//0+1=1 &#125;) this.setState((prevState)=&gt;&#123; return &#123;count: prevState.count+2&#125;//1+2=3 &#125;)&#125;//进行3次setState,但组件只会渲染一次.因为react会把所有事件循环中的消息队列中的state合并再渲染. 配置组件的props一个组件可能在不同的地方用到,所以组件要有一定的可配置性.每个组件都可以接收一个props参数,他是一个对象,包含你对这个组件的配置. 组件内部是通过this.props的方式来获取组件的参数,如果this.props有需要的属性就采用,没有的话就默认. 再使用一个组件的时候,可以把参数放在标签中的属性中,所以属性都会作为props对象的键值. 默认配置defaultProps我们可以通过||操作符来实现默认配置,const word = this.props.like || &#39;已赞&#39;React也提供了一种方式defaultProps来配置默认配置. 12345678910class LikeBtn extends Component&#123; static defaultProps = &#123; like: '取消', unlike: '点赞' &#125; constructor()&#123; super() this.state = &#123;isLike: false&#125; &#125;&#125; props不可变props一旦传入进来就不能改变.如果我们使用this.props.like=&#39;取消&#39;控制台会直接报错. 你不能改变一个组件被渲染时传进来的props,因为如果渲染过程中可以改变会导致组件的显示形态和行为变得不可预测. 但这并不意味这props永远不能修改,组件的使用者可以主动的通过重新渲染的方式把新的props传入到组件中. 1234&lt;div&gt; &lt;LikeBtn like=&#123;this.state.like&#125;&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;button&gt; &lt;/div&gt; 在这里,我们把state中的数据传给props,但我们点击按钮时,我们使用setState改变state的值,并导致页面重新渲染,改变后的state会传给新的props. state VS propsstate的主要作用是用于组件保存,控制,修改自己的状态.state在组件内部初始化,可以被自身修改,但不能被外界访问和修改.可以把state当做一个局部的只能被自身控制的数据源.通过this.setState进行更新,该方法会导致组件重新渲染. props主要作用是可以传入参数来配置该组件,组件内部无法控制和修改,除非外部主动传入新的props,否则组件的props永远保持不变. 一个组件的state中的数据可以传给子组件的props,一个组件也可以使用外部传入的props来初始化自己的state.但他们职责非常清晰state是让组件控制自己的状态,props是让外部对组件自己进行配置,尽量少的用state,尽量多的使用props 无状态组件12345678const HelloWorld = (props)=&gt;&#123; const sayHi = (event)=&gt;&#123; alert(\"helloWorld\") &#125; return( &lt;div onClick=&#123;sayHi&#125;&gt;helloWorld&lt;/div&gt; )&#125; 以前的一个组件时通过继承Component来构建,一个子类就是一个组件,而用函数式编写方式是一个函数就是一个组件,你可以和之前使用使用该组件.不同的是,函数式组件只能接受props而无法和类组件一样在constructor里面初始化state.函数式组件就是一种只接受props和提供render方法的类组件. 渲染列表数据渲染存放jsx元素的数组1234567891011render()&#123; return( &lt;div&gt; &#123;[ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; ]&#125; &lt;/div&gt; )&#125; 如果你往{}里放一个数组,react会把数组中的元素依次渲染出来. 使用map渲染列表数据123456789101112131415161718192021222324252627282930313233343536373839const users = [ &#123;userName:'tom',age:21,gender:'male'&#125;, &#123;userName:'jerry',age:23,gender:'male'&#125;, &#123;userName:'lily',age:41,gender:'male'&#125;, &#123;userName:'lucy',age:31,gender:'male'&#125;,]render()&#123; const userEle = []//保存渲染后的jsx数组 for(let user of users)&#123; userEle.push( &lt;div&gt; &lt;span&gt;&#123;user.userName&#125;&lt;/span&gt; &lt;span&gt;&#123;user.age&#125;&lt;/span&gt; &lt;span&gt;&#123;user.gender&#125;&lt;/span&gt; &lt;/div&gt; ) &#125; return( &lt;div&gt;&#123;userEle&#125;&lt;/div&gt; )&#125;//但我们一般不会手动写循环来构建jsx结构,而是用es6 的map方法render()&#123; return( &lt;div&gt; &#123; users.map((user,index,arr)=&gt;&#123; return( &lt;div&gt; &lt;span&gt;&#123;&#123;user.userName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;user.age&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;user.gender&#125;&#125;&lt;/span&gt; &lt;/div&gt; ) &#125;) &#125; &lt;/div&gt; )&#125; 然后你会发现,react报错了,因为对于用表达式套数组罗列到页面上的元素,都要为每个元素加上key属性,这个key必须是每个元素的标识 状态提升在编写组件时,当有别的组件依赖或影响某个组件的某个状态state时,我们通常将这种组件之间共享的状态交给组件最近的公共父节点保管,然后通过props把状态传递给子组件,这样就可以在组件之间共享数据了.这种方式在React中被称为状态提升. 如果这个公共的分组件只是组件树下很小的一个子树,我们需要一直把状态提升上去,一旦发生提升,就需要修改原来保存状态以及传递数据的所有代码,这种无限制的提升并不是一个好的方案. 如何更好的管理被多喝组件依赖的状态?React并没有提供更好的解决方案,我们可以引入Redux状态管理工具来帮助我们解决这种共享状态.对于不会被外界依赖和影响的状态,一般只保存在组件内部即可,不需要做提升. 挂载阶段组件的生命周期我们来看看下面这段代码发生了什么 123456789101112ReactDOM.render( &lt;Header/&gt;, document.getElementById('root'))//1.实例化一个Headerconst header = new Header(props,children)//2.调用header.renderconst headerJsx = header.render()//3.构建真正的DOM元素const headerDom = createDOM(...)//4. 把DOM元素追加到页面上document.getElementById('root').appendChild(headerDOm) 上面这个过程称为组件的挂载,这是一个从无到有的过程 React为了更好的掌握组件的挂载过程,提供了一系列等生命周期函数.包括了两个挂载函数. componentWillMount和componentDIdMount.当我们在页面渲染后删除了某个元素后,也有对应的函数componentWillUnmount. 他们之间的顺序为 1. constructor (指向prototype对象所在的构造函数,关于组件自身状态的初始化) 2. component will mount (组件将要挂载,一般组件启动的动作,包括ajax数据的拉取,设置定时器等等在此进行) 3. render (返回jsx元素) 4. component did mount (组件已经挂载,当组件的启动工作依赖dom时,例如动画,就可以放在这里.) 5. component will unmount (组件将要移除,在组件销毁时清除该组件定时器和其他数据清理工作) 更新阶段的组件生命周期除了挂载阶段,还有一种更新阶段.setState导致react重新渲染组件就是一个组件的变化过程. shouldComponentUpdate(nextProps,nextState): 你可以通过这个方法控制组件是否重新渲染,如果返回false就不重新渲染,该生命周期在性能优化上非常有用. componentWillReceiveProps(nextProps):组件从父组件接收到新的props之前调用. componentWillUpdate():组件重新渲染之前调用. componentDIdUpdate():重新渲染后调用. ref 和 React 中的 DOM 操作React中我们很少和打交道,有一系列的on*方法帮我们进行事件监听,我们不再需要调用addEventListener的DOM API,我们通过setState重新渲染组件,渲染时把新的props传给子组件达到页面更新效果,而不再借用jQuery进行页面更新. 但React并不能满足所有的DOM操作,比如进入页面自动focus到某个输入框,.比如你想获取某个元素的尺寸在做后续动画等等.所以它提供了ref属性帮助我们获取已经挂在的dom节点,你可以给某个JSX元素加上ref属性. &lt;input ref={(input)=&gt;{this.input = input}}&gt; 我们给input加了一个ref属性,该属性是一个函数,该元素在页面上挂载完毕后调用这个函数,并把这个挂载后的dom节点传给这个函数.我们把元素赋值给组件实例的一个属性,这样就可以通过this.input获取这个DOM元素. 如果给组件挂载ref,那么我们获取的是这个组件在react内部初始化的实例,这并不常用,不建议这样做. props.children 和容器类组件1234567891011121314151617ReactDOM.render( &lt;Card&gt; &lt;h1&gt;I'm H1&lt;/h1&gt; &lt;div&gt;I'm Div&lt;/div&gt; &lt;/Card&gt;, document.getElementById('root'))class Card extends Component&#123; render()&#123; return&#123; &lt;div&gt; &#123;this.props.children&#125; &#123;this.props.children[0]&#125; &lt;/div&gt; &#125; &#125;&#125; 在使用自定义组件时,可以再组件内部嵌套jsx结构.嵌套的结构可以再组件内部通过props.children获取到,这种组件编写方式在编写容器类型的组件当中非常有用,而在实际React项目中,我们几乎每天都需要用这种方式编写组件. dangerouslySetHTML 和 style 属性#####dangerouslySetHTML 出于安全因素(XSS攻击),React会把所有表达式插入的内容都自动转义.类似于jQuery的text(). 12345const header = '&lt;h1&gt;helloWorld&lt;/h1&gt;'&lt;div&gt; &#123;header&#125; &lt;/div&gt;//因为react的自动转义,并不会渲染&lt;h1&gt;元素,而是显示文本形式 如何做到动态设置HTML效果呢?我们可以给元素设置一个dangerouslySetHTML属性传入一个对象,这个对象的__html属性值就相当于innerHTML,就可以动态渲染元素结构了. 1234&lt;div dangerouslySetHTML=&#123;&#123;__html:'&lt;h1&gt;helloworld&lt;/h1&gt;'&#125;&#125; className=\"container\"&gt;&lt;div&gt; 之所以搞这么复杂是因为设置这个属性可能会导致跨站脚本攻击,不必要的情况就不要使用. style普通DOM元素中的style 1&lt;div style=\"font-size:14px;color:red;\"&gt;&lt;div&gt; React中需要把css属性变为对象再传给元素 1&lt;h1 style=&#123;&#123;fontSize:'14px',color:'red'&#125;&#125;&gt;&lt;/h1&gt; style接收一个对象,里面是css属性键值对,原来css带’-‘的属性都需要换成驼峰命名法.我们可以用props或者state中的数据生成样式对象再传给元素,再用setState修改样式,非常灵活. 12&lt;h1 style=&#123;&#123;fontSize:'14px',color:this.state.color&#125;&#125;&gt;&lt;/h1&gt;this.setState(&#123;color:'blue'&#125;) PropTypes和组件参数验证React提供一种机制,可以给组件的配置参数加上类型验证.我们需要安装React提供的第三方库prop-types npminstall --save prop-types 12345678910import React,&#123; Component &#125; from 'react'import PropTypes from 'prop-types'class Card extends Component&#123; static propTypes = &#123; text: PropTypes.string.isRequired &#125;static defaultProps = &#123; ...&#125;&#125; PropTypes提供的参数有:array,bool,func,number,object,string,node,element… react规范组件和方法命名1. static开头的类属性,如`defaultProps`,`propTypes` 2. 构造函数,constructor 3. getter/setter 4. 组件生命周期 5. _开头的私有方法 6. 事件监听方法,handle** 7. render*()表示不同render()内容的函数 高阶组件高阶组件就是一个函数,传给它一个组件作为函数的参数,它返回一个新的组件. 1234567891011121314151617import React,&#123;Component&#125; from 'react'export default (OldComponent,name)=&gt;&#123; class NewComponent extends Component&#123; constructor()&#123; super() this.state = &#123;data:null&#125; &#125; componentWillMount()&#123; let data = localStorage.getItem(name) this.setState(&#123;data&#125;) &#125; render()&#123; return &lt;OldComponent data=&#123;this.state.data&#125;&gt;&lt;/OldComponent&gt; &#125; &#125; return NewComponent&#125; 怎么使用这个高阶组件呢? 12345678import NewComponent from './NewComponent'class InputName extends Component&#123; render()&#123; return &lt;input value=&#123;this.props.data&#125;&gt; &#125;&#125;InputName = NewComponent(InputName,'username')export default InputName 其实高阶组件就是为了组件之间的代码复用.组件可能有着相同的逻辑,把这些逻辑抽取出来,放在高阶组件里进行复用.高阶组件内部包装的组件和被包装的组件通过props传递数据. contextcontext(上下文)是React中一个比较特殊的东西.某个组件只要往自己的context里面放一些状态,这个组件下的所有子组件都可以直接访问而不用通过中间组件一层层传递,它的父组件则不能访问到. context打破了组件之间通过props传递数据的规范,增强了组件间的耦合性.就像全局变量一样,每个组件都能随意访问和修改,这会让程序运行不可预料. 一些第三方状态管理的库就是充分利用了这种机制给我们提供了极大地便利,所以我们一般不手写context,也不要用它,需要时用这些第三方的应用状态管理库即可. 本文参考胡子大哈的React小书,详情请点击","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端 React","slug":"前端-React","permalink":"http://yoursite.com/tags/前端-React/"}]},{"title":"用NodeJS写一个爬虫","slug":"用NodeJS写一个爬虫","date":"2016-12-05T07:45:03.000Z","updated":"2017-12-05T07:51:45.000Z","comments":true,"path":"2016/12/05/用NodeJS写一个爬虫/","link":"","permalink":"http://yoursite.com/2016/12/05/用NodeJS写一个爬虫/","excerpt":"","text":"简介用NodeJS下一个爬虫,用来获取简书首页的文章,然后保存以txt文件的形式保存在本地,数量为20篇. 初始化项目​ npm init || yarn init 安装依赖​ npm install superagent cheerio —save || yarn add superagent cheerio 页面数据下载123456789101112131415161718192021const fs = require(\"fs\")const request = require(\"superagent\")const cheerio = require(\"cheerio\")let reptileUrl = \"http://www.jianshu.com/\"request .get(reptileUrl) .end(function(err,res)&#123; if(err)&#123; &#125; else&#123; let $ = cheerio.load(res.text,&#123;decodeEntities:false&#125;) //每页有20篇文章,找到标题及其href的值 $(\"#list-container .note-list li\").each(function(index,value)&#123; let url = $(v).find(\".title\").attr(\"href\") //url即文章的链接,需要和reptileUrl拼接起来 getContent(url) &#125;) &#125; &#125;) 获取文章内容,保存在本地1234567891011121314151617181920212223242526272829303132function getContent(url)&#123; let adress = reptileUrl + url request .get(adress) .end(function(err,res)&#123; if(err)&#123; &#125;else&#123; let $ = cherrio.load(res.text,&#123;decodeEntities:false&#125;) //文章标题 let title = $(\".article .title\").text() //文章内容 let content = '' $(\".article .show-content p\").each(function(i, v, a) &#123; content += $(v).text(); &#125;) //要写入的数据 let data = &#123; title: title, content: content &#125; //本地保存 fs.writeFile('../data/' + title + '.txt', JSON.stringify(data), 'utf-8', function(err) &#123; if (err) &#123; &#125; else &#123; console.log(\"It's OK !\") &#125; &#125;) &#125; &#125;)&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"node 爬虫","slug":"node-爬虫","permalink":"http://yoursite.com/tags/node-爬虫/"}]},{"title":"重温<<计算机操作系统>>","slug":"重温-计算机操作系统","date":"2015-10-18T07:19:25.000Z","updated":"2017-11-14T06:02:28.000Z","comments":true,"path":"2015/10/18/重温-计算机操作系统/","link":"","permalink":"http://yoursite.com/2015/10/18/重温-计算机操作系统/","excerpt":"","text":"并发与并行概念并行是指两个或多个事件在同一时刻发生,而并发是两个或多个事件在同一时间间隔内发生.在多道程序环境下,并发性是指在一段时间内宏观上有多个程序在同时运行,但在单处理机系统中,每一时刻却仅能有一道程序执行,故微观上这些程序只能是分时的交替执行.倘若在多处理机,这些可以并发执行的程序便可分配到多个处理机上,实现并行执行. 理解如果某个系统支持两个或多个动作同时存在,name这个系统就是一个并发系统.如果某个系统支持两个或多个动作同时执行,那么这个系统就是一个并行系统.并发系统与并行系统这两个定义之间的关键差异在于存在这个词. 在并发程序中可以同时拥有两个或多个线程,这意味着,如果程序在单核处理器上运行,那么这两个线程将交替换入或换出内存.这些线程是同时存在的,每个线程都处于执行过程中的某个状态.如果程序能够并行执行,那么就一定是运行在多核处理器上的.此时,程序中的每个线程都将分配到一个独立的处理器核上,因此可以同时运行. 我相信你已经能够得出结论:”并行概念是并发概念的一个子集”.也就是说,你可以编写一个拥有多个线程或进程的并发程序,但如果没有多核处理器来执行这个程序,那么就不能以并行的方式来运行代码.因此,凡是在求解单个问题涉及多个执行流程的编程模式或执行行为,都属于并发编程的范畴. 摘自:&lt;&lt;并发的艺术&gt;&gt;-[美]布雷谢斯 Erlang 之父 Joe Armstrong 用一张5岁小孩都能看懂的图解释了并发与并行的区别.从图中可以看出,并发是两个队列交替使用一台咖啡机,并行是两个队列同时使用两台咖啡机.如果串行,一个队列使用一台咖啡机.并发和并行都可以是多个线程,就看这些线程能不能同时被多个CPU执行,如果可以说明是并行,而并发是多个线程被一个CPU轮流切换着执行. 进程与线程概念对进程较为经典的定义有: 1. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动. 2. 进程是程序在一个数据集合上运行的过程,它是系统进行资源分配和调度的一个独立单位. 3. 系统为每个进程定义了一个数据结构-进程控制块(PCB).OS根据PCB来对并发执行的进程进行控制和管理. 线程和进程的比较: 1. 再引入线程的操作系统中,通常一个进程都拥有若干个线程,至少有一个线程. 2. 进程为资源拥有的最小单位,而线程作为调度和分派的基本单位,线程不拥有系统资源,可以访问资源. 理解进程和线程的主要差别在于他们是不同的操作系统资源的管理方式.进程有独立的地址空间,一个进程崩溃后,在保护模式下不会对其他进程产生影响,而线程只是一个进程中的不同执行路径.线程有自己的堆栈和局部变量,但线程没有单独的地址空间,一个线程死掉就等于整个进程死掉,所以在进程切换时,耗费资源较大,效率变差.但对于一些要求同时进行并且又要共享某些变量的并发操作,只能用进程,不能用线程. 生产者消费者问题概念生产者消费者问题是一个经典的多进程同步问题,也叫缓存绑定问题. 既有两个进程:一组生产者进程和一组消费者进程共享一个初始值为空固定大小为n的缓存区.生产者的工作是制造一段数据,只要缓存没满就放入缓存区,否则必须等待,如此反复.同时,只要缓存区不为空,消费者才能从中取出消息,一个取出一段数据,否则只能等待.由于缓存区是临界资源,它只允许一个生产者放入消息,或一个消费者从中取出消息. 问题的核心是要保证不让生产者在缓存满的时候还要向内写数据,不让消费者试图从空的缓存中取出数据. 理解生产者和消费者对缓存区互斥访问是互斥关系,同时又是相互协作关系,即同步关系.那么需要解决的是互斥和同步PV操作的位置.使用”进程间通信”即可解决唤醒问题: 我们使用了两个信号标:full和empty.信号量mutex作为互斥信号量.用于控制互斥访问缓存池,互斥信号量初始值为1.信号量full用于记录当前缓冲池中”满”缓冲区数,初始值为0.信号量empty用于记录当前缓存区”空”缓存区数,初始值为n.新的数据增加后,full增加,empty减少.如果生产和试图在empty为0时减少其值,生产者就会被”催眠”.下一轮中有数据消费掉时,empty就会增加,生产者就会被”唤醒”.1234567891011121314151617181920212223semaphore mutex = 1;//临界区互斥信号量semaphore empty = n;//空闲缓存区semaphore full = 1;//缓存区初始化为空produce()&#123; while(1)&#123; produce an item in dextp;//生产数据 P(empty);//获取空缓存区单元 P(mutex);//进入临界区 add nextp to buffer;//将数据放入缓存区 V(mutex);//离开临界区,释放互斥信号量 V(full)//满缓存区加1 &#125;&#125;consume()&#123; while(1)&#123; P(full);//获取满缓存区单元 P(mutex);//进入临界区 remove an item from buffer;//拿走数据 V(mutex);//离开临界区 V(empty);//空缓存区单元加1 consume the item//消费数据 &#125;&#125;","categories":[{"name":"理解计算机","slug":"理解计算机","permalink":"http://yoursite.com/categories/理解计算机/"}],"tags":[{"name":"计算机基础 操作系统","slug":"计算机基础-操作系统","permalink":"http://yoursite.com/tags/计算机基础-操作系统/"}]}]}