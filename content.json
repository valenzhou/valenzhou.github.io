{"meta":{"title":"Mr.喵的网络日志","subtitle":null,"description":null,"author":"ValenZhou","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"学习CSS Grid布局","slug":"学习CSS-Grid布局","date":"2017-12-13T07:39:20.000Z","updated":"2017-12-13T07:42:01.000Z","comments":true,"path":"2017/12/13/学习CSS-Grid布局/","link":"","permalink":"http://yoursite.com/2017/12/13/学习CSS-Grid布局/","excerpt":"","text":"CSS Grid 布局是CSS中最强大的布局系统,与flexbox的一维布局系统不同,CSS Grid是一个二维布局系统,它可以同时处理行和列. 第一个Grid布局css Grid布局由两个核心组成部分,warpper(父元素)和items(子元素).warpper是实际的grid(网格),items是网格的内容. 下面是一个warpper元素,内部包含了6个items: 12345678&lt;div class=\"warpper\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 要把warpper元素变成一个grid(网格),只需要把它的display属性设置为grid即可. 123.warpper&#123; display:grid;&#125; 这时我们还没有写任何样式,他会简单的将6个div堆叠在一起. Columns(列)和rows(行)为了使其成为二维的网格容器,我们需要定义行和列.让我们创建两行三列,使用grid-template-cloumns和grid-template-rows属性. 12345.warpper&#123; display:grid; grid-template-rows: 100px 50px; grid-template-cloumns: 100px 80px 60px;&#125; 我们为grid-template-cloumns写入了3个值,这样我们就得到了3列,每列的值代表列的宽度.而grid-template-rows代表行数及行的高度. 放置items(子元素)为了帮助理解,我们在每个items(子元素)加上单独的class. 12345678&lt;div class=\"warpper\"&gt; &lt;div class=\"item1\"&gt;1&lt;/div&gt; &lt;div class=\"item2\"&gt;2&lt;/div&gt; &lt;div class=\"item3\"&gt;3&lt;/div&gt; &lt;div class=\"item4\"&gt;4&lt;/div&gt; &lt;div class=\"item5\"&gt;5&lt;/div&gt; &lt;div class=\"item6\"&gt;6&lt;/div&gt;&lt;/div&gt; 现在我们来创建一个 3*3的grid: 12345.warpper&#123; display:grid; grid-template-rows: 100px 100px 100px; grid-template-cloumns:100px 100px 100px;&#125; 我们只在页面上看到3-2的grid,而我们定义的是3-3的grid.这是因为我们只有6个items来填充这个网格.我们我们再追加3个items,name最后一行也会被填满. 要定位和调整items大小,可以使用grid-cloumn和grid-row属性来设置. 1234.item1&#123; grid-cloumn-start: 1; grid-cloumn-end: 4;&#125; 上面的样式表示,我们希望item1占据从第一个网格线开始,到第四条网格线结束.换句话说它将独占一行.而剩下的items都推到了下一行. 这种形式也可以缩写为: 123456.item1&#123; grid-cloumn: 1/4;&#125;.item3&#123; grid-row: 2/4;&#125; 相关术语 网格容器(Grid):应用display:grid的元素,items的直接父级元素. 网格项(items): 网格容器的直接子元素,后代元素不是. 网格线(Grid-line):构成网格结构的分界线. 网格轨道(Grid-Track):两条相邻网格线之间的空间. 网格单元格(Grid-cell):两个相邻行与相邻列之间的空间. 网格区域(Grid-Area):四条网格线包围的总空间. 父元素 网格容器属性display将元素定义为网格容器,并为其建立新的网格式上下文. grid : 生成一个块级网格 inline-grid: 生成一个内联网格 subgrid: 嵌套的子网格. 在网格容器中使用float,clear,column,vertical-align不会产生任何效果. grid-template-cloumns/rows使用空格分割值列表,用来定义网格的行和列.可以是长度值和百分比,和自动分配(auto)或网格线名称. grid-template-areas指定Grid Area名称来定义网格模板.一个.号代表一个空的单元.你可以使用任意数量的.只要这些.之间没有空隙隔开就表示一个个的单元格. :由items的grid-area指定的区域名称 .(点号):代表一个空网格单元 none:不定义网格区域 12345678910111213141516.container&#123; display:grid; grid-template-rows:auto; grid-template-cloumns:50px 50px 50px 50px; grid-template-areas: \"header header header\" \"main main . sidebar\" \"footer footer footer footer\"&#125;.item-a&#123; grid-area:header;&#125;.item-b&#123; grid-area:main;&#125;... 当你命名网格区域后,该区域两端的网格线实际上是自动命名的,如果你的网格区域名字是foo,则起始行网格线和列网格线是foo-statrt,最后的网格线是foo-end.则意味着一个网格线可能有很多名称. grid-template用于定义grid-template-rows,grid-template-cloumns,和grid-template-areas的缩写. none:将所有的属性设置为初始值. subgrid:将rows和cloumns设置为subgrid,areas设置为初始值. /:将rows和cloumns设置为特定值,areas为none. grid-column-gap/grid-row-gap指定网格线的大小,可以把它想象为设置列/行之间间距的宽度.值为长度值. grid-gapgrid-column-gap/grid-row-gap的缩写语法 justify-items网格容器的水平对其方式,这些行为也可以通过items的justify-self属性设置: start 左侧对其 end 右侧对其 center 居中对齐 stretch 填满区域宽度 align-items网格容器的垂直对齐方式: start 顶部对齐 end 底部对齐 center 垂直居中 stretch 填满区域高度 justify-content/align-content有时,网格容器的内容小于整体容器的大小,可以设置内容在容器中的对齐方式. start 左对齐 end 右对齐 center 居中 stretch 填充 space-around 左右两边都有空间,空格之间距离相等 space-between 左右两边没有空间,空格之间距离相等 space-evenly 左右和每个空间距离相等 grid-auto-columns/grid-auto-rows指定自动生成隐式网格轨道,但定义行和列自动超出网格范围时,隐式网格轨道创建.值为长度,百分比等等. grid-auto-flow如果你有一些未明确放置的网格,自动放置算法会自动放置这些项. row: 依次填充每行 column:依次填充每列 dense: 出现较小的网格项时,尝试填充网格中较早的空缺.但它可能导致你的网格项出现混乱. 子元素 网格项items属性grid-column-start/end通过指定网格线来确定网格在容器中的列的起始位置 grid-row-start/end通过指定网格线来确定网格在容器中的行的起始位置 grid-column/grid-row上面两者的缩写 grid-area为网格项提供一个名词,一遍容器grid-template-areas属性创建模板进行引用.也可以作为grid-row和grid-cloumn的缩写. justify-self/align-selfitems的水平/垂直对其方式","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端 css","slug":"前端-css","permalink":"http://yoursite.com/tags/前端-css/"}]},{"title":"vue项目中的小总结","slug":"vue项目中的小总结","date":"2017-05-21T06:45:23.000Z","updated":"2017-11-22T08:06:23.000Z","comments":true,"path":"2017/05/21/vue项目中的小总结/","link":"","permalink":"http://yoursite.com/2017/05/21/vue项目中的小总结/","excerpt":"","text":"单文件组件中data必须是一个函数,然后返回一个对象.避免多个组件数据混乱.1234567 export default &#123; data()&#123; return &#123; a: \"123\", &#125; &#125;&#125; 列表循环时,尽量使用key,避免元素复用1&lt;div v-for=\"(item,index) in array\" :key=\"index\"&gt;&lt;/div&gt; 在vue中使用less安装less及less-loader依赖 1npm install less less-loader --save-dev 修改webpack配置文件 在单文件组件中使用 1&lt;style lang=\"less\" scoped&gt; $nextTick的用法异步更新队列:Vue在观察到数据变化时不会直接更新Dom,而是开启一个队列,并缓冲在同一事件循环中发生的所有数据变化,然后去除重复数据,避免重复计算和dom操作,然后在下一个事件循环tick中,刷新队列并执行实际(已去重)的工作.$nextTick就是用来知道什么时候dom更新完成的. 123&lt;div id=\"div\" v-if=\"isShow\"&gt;这是一段文本&lt;/div&gt;&lt;button @click=\"getText\"&gt;获取div内容&lt;/button&gt;&lt;!-- 当我们点击按钮时,获取div的文本 --&gt; 1234567getText: function()&#123; this.isShow = true; this.$nextTick(function()&#123; var text = document.getElementById('div').innerText; console.log(text); &#125;)&#125; webpack打包上传服务器后项目图片路径的问题1. 解决方式一: 修改config文件中index.js里assetsPublicPath为&apos;./&apos;, 然后修改webpack.base.conf.js里的url-loader的limit,根据文件大小相应的修改. 但是修改后打包的文件比较大,影响页面加载. 2. 解决方式二: 修改config文件中index.js里assetsPublicPath为&apos;./&apos;,然后修改源代码中css的图片路径为绝对路径, 静态资源由之前的src下的assets文件转移到src同级的static文件下新建一个img文件. 如果该项目有两级以上的域名,就在绝对路径前加上该子域名,如&apos;/XXX/static/img/a.png&apos; scoped下尽量不要使用标签选择器scoped下尽量不要使用标签选择器,会影响页面性能. vue组件添加原生事件vue组件添加原生事件,必须在事件后添加.native修饰符,否则事件不会生效. 在vue中使用TypeScript在vue中使用TypeScript 1. 安装依赖 12npm i vue-class-component vue-property-decorator --savenpm i ts-loader typescript tslint tslint-loader tslint-config-standard --save-dev 2. 配置webpack - 找到&apos;./build/webpack.base.conf.js&apos;添加 1resolve: &#123;extensions: ['.js', '.vue', '.json', '.ts'],&#125; - 找到module.rules,添加对.ts的解析 1234567891011121314&#123; test: /\\.ts$/, exclude: /node_modules/, enforce: 'pre', loader: 'tslint-loader'&#125;,&#123; test: /\\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: &#123; appendTsSuffixTo: [/\\.vue$/], &#125;&#125;, - 添加根路径tsconfig.json文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; // 编译选项 \"compilerOptions\": &#123; // 输出目录 \"outDir\": \"./output\", // 是否包含可以用于 debug 的 sourceMap \"sourceMap\": true, // 以严格模式解析 \"strict\": true, // 采用的模块系统 \"module\": \"esnext\", // 如何处理模块 \"moduleResolution\": \"node\", // 编译输出目标 ES 版本 \"target\": \"es5\", // 允许从没有设置默认导出的模块中默认导入 \"allowSyntheticDefaultImports\": true, // 将每个文件作为单独的模块 \"isolatedModules\": false, // 启用装饰器 \"experimentalDecorators\": true, // 启用设计类型元数据（用于反射） \"emitDecoratorMetadata\": true, // 在表达式和声明上有隐含的any类型时报错 \"noImplicitAny\": false, // 不是函数的所有返回路径都有返回值时报错。 \"noImplicitReturns\": true, // 从 tslib 导入外部帮助库: 比如__extends，__rest等 \"importHelpers\": true, // 编译过程中打印文件名 \"listFiles\": true, // 移除注释 \"removeComments\": true, \"suppressImplicitAnyIndexErrors\": true, // 允许编译javascript文件 \"allowJs\": true, // 解析非相对模块名的基准目录 \"baseUrl\": \"./\", // 指定特殊模块的路径 \"paths\": &#123; \"jquery\": [ \"node_modules/jquery/dist/jquery\" ] &#125;, // 编译过程中需要引入的库文件的列表 \"lib\": [ \"dom\", \"es2015\", \"es2015.promise\" ] &#125;&#125; - 添加根路径tslint.json文件 123456&#123; \"extends\": \"tslint-config-standard\", \"globals\": &#123; \"require\": true &#125;&#125; - 在src下创建vue-shim.d.ts 1234declare module \"*.vue\" &#123; import Vue from \"vue\"; export default Vue;&#125; 之后再代码中引入.vue文件时需要加上.vue后缀,因为ts默认只识别*.ts文件 - 改造APP.vue文件 12345678&lt;script lang=\"ts\"&gt; import Vue from 'vue' import Component from 'vue-class-component' @Component(&#123;&#125;) export default class App extends Vue &#123; &#125;&lt;/script&gt; - 修改main.js为main.ts,并修改&apos;./build/webpack.base.conf.js&apos;中的entry为 `{app: &apos;./src/main.ts&apos;}`","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"vue 前端","slug":"vue-前端","permalink":"http://yoursite.com/tags/vue-前端/"}]},{"title":"用NodeJS写一个爬虫","slug":"用NodeJS写一个爬虫","date":"2016-12-05T07:45:03.000Z","updated":"2017-12-05T07:51:45.000Z","comments":true,"path":"2016/12/05/用NodeJS写一个爬虫/","link":"","permalink":"http://yoursite.com/2016/12/05/用NodeJS写一个爬虫/","excerpt":"","text":"简介用NodeJS下一个爬虫,用来获取简书首页的文章,然后保存以txt文件的形式保存在本地,数量为20篇. 初始化项目​ npm init || yarn init 安装依赖​ npm install superagent cheerio —save || yarn add superagent cheerio 页面数据下载123456789101112131415161718192021const fs = require(\"fs\")const request = require(\"superagent\")const cheerio = require(\"cheerio\")let reptileUrl = \"http://www.jianshu.com/\"request .get(reptileUrl) .end(function(err,res)&#123; if(err)&#123; &#125; else&#123; let $ = cheerio.load(res.text,&#123;decodeEntities:false&#125;) //每页有20篇文章,找到标题及其href的值 $(\"#list-container .note-list li\").each(function(index,value)&#123; let url = $(v).find(\".title\").attr(\"href\") //url即文章的链接,需要和reptileUrl拼接起来 getContent(url) &#125;) &#125; &#125;) 获取文章内容,保存在本地1234567891011121314151617181920212223242526272829303132function getContent(url)&#123; let adress = reptileUrl + url request .get(adress) .end(function(err,res)&#123; if(err)&#123; &#125;else&#123; let $ = cherrio.load(res.text,&#123;decodeEntities:false&#125;) //文章标题 let title = $(\".article .title\").text() //文章内容 let content = '' $(\".article .show-content p\").each(function(i, v, a) &#123; content += $(v).text(); &#125;) //要写入的数据 let data = &#123; title: title, content: content &#125; //本地保存 fs.writeFile('../data/' + title + '.txt', JSON.stringify(data), 'utf-8', function(err) &#123; if (err) &#123; &#125; else &#123; console.log(\"It's OK !\") &#125; &#125;) &#125; &#125;)&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"node 爬虫","slug":"node-爬虫","permalink":"http://yoursite.com/tags/node-爬虫/"}]},{"title":"重温<<计算机操作系统>>","slug":"重温-计算机操作系统","date":"2015-10-18T07:19:25.000Z","updated":"2017-11-14T06:02:28.000Z","comments":true,"path":"2015/10/18/重温-计算机操作系统/","link":"","permalink":"http://yoursite.com/2015/10/18/重温-计算机操作系统/","excerpt":"","text":"并发与并行概念并行是指两个或多个事件在同一时刻发生,而并发是两个或多个事件在同一时间间隔内发生.在多道程序环境下,并发性是指在一段时间内宏观上有多个程序在同时运行,但在单处理机系统中,每一时刻却仅能有一道程序执行,故微观上这些程序只能是分时的交替执行.倘若在多处理机,这些可以并发执行的程序便可分配到多个处理机上,实现并行执行. 理解如果某个系统支持两个或多个动作同时存在,name这个系统就是一个并发系统.如果某个系统支持两个或多个动作同时执行,那么这个系统就是一个并行系统.并发系统与并行系统这两个定义之间的关键差异在于存在这个词. 在并发程序中可以同时拥有两个或多个线程,这意味着,如果程序在单核处理器上运行,那么这两个线程将交替换入或换出内存.这些线程是同时存在的,每个线程都处于执行过程中的某个状态.如果程序能够并行执行,那么就一定是运行在多核处理器上的.此时,程序中的每个线程都将分配到一个独立的处理器核上,因此可以同时运行. 我相信你已经能够得出结论:”并行概念是并发概念的一个子集”.也就是说,你可以编写一个拥有多个线程或进程的并发程序,但如果没有多核处理器来执行这个程序,那么就不能以并行的方式来运行代码.因此,凡是在求解单个问题涉及多个执行流程的编程模式或执行行为,都属于并发编程的范畴. 摘自:&lt;&lt;并发的艺术&gt;&gt;-[美]布雷谢斯 Erlang 之父 Joe Armstrong 用一张5岁小孩都能看懂的图解释了并发与并行的区别.从图中可以看出,并发是两个队列交替使用一台咖啡机,并行是两个队列同时使用两台咖啡机.如果串行,一个队列使用一台咖啡机.并发和并行都可以是多个线程,就看这些线程能不能同时被多个CPU执行,如果可以说明是并行,而并发是多个线程被一个CPU轮流切换着执行. 进程与线程概念对进程较为经典的定义有: 1. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动. 2. 进程是程序在一个数据集合上运行的过程,它是系统进行资源分配和调度的一个独立单位. 3. 系统为每个进程定义了一个数据结构-进程控制块(PCB).OS根据PCB来对并发执行的进程进行控制和管理. 线程和进程的比较: 1. 再引入线程的操作系统中,通常一个进程都拥有若干个线程,至少有一个线程. 2. 进程为资源拥有的最小单位,而线程作为调度和分派的基本单位,线程不拥有系统资源,可以访问资源. 理解进程和线程的主要差别在于他们是不同的操作系统资源的管理方式.进程有独立的地址空间,一个进程崩溃后,在保护模式下不会对其他进程产生影响,而线程只是一个进程中的不同执行路径.线程有自己的堆栈和局部变量,但线程没有单独的地址空间,一个线程死掉就等于整个进程死掉,所以在进程切换时,耗费资源较大,效率变差.但对于一些要求同时进行并且又要共享某些变量的并发操作,只能用进程,不能用线程. 生产者消费者问题概念生产者消费者问题是一个经典的多进程同步问题,也叫缓存绑定问题. 既有两个进程:一组生产者进程和一组消费者进程共享一个初始值为空固定大小为n的缓存区.生产者的工作是制造一段数据,只要缓存没满就放入缓存区,否则必须等待,如此反复.同时,只要缓存区不为空,消费者才能从中取出消息,一个取出一段数据,否则只能等待.由于缓存区是临界资源,它只允许一个生产者放入消息,或一个消费者从中取出消息. 问题的核心是要保证不让生产者在缓存满的时候还要向内写数据,不让消费者试图从空的缓存中取出数据. 理解生产者和消费者对缓存区互斥访问是互斥关系,同时又是相互协作关系,即同步关系.那么需要解决的是互斥和同步PV操作的位置.使用”进程间通信”即可解决唤醒问题: 我们使用了两个信号标:full和empty.信号量mutex作为互斥信号量.用于控制互斥访问缓存池,互斥信号量初始值为1.信号量full用于记录当前缓冲池中”满”缓冲区数,初始值为0.信号量empty用于记录当前缓存区”空”缓存区数,初始值为n.新的数据增加后,full增加,empty减少.如果生产和试图在empty为0时减少其值,生产者就会被”催眠”.下一轮中有数据消费掉时,empty就会增加,生产者就会被”唤醒”.1234567891011121314151617181920212223semaphore mutex = 1;//临界区互斥信号量semaphore empty = n;//空闲缓存区semaphore full = 1;//缓存区初始化为空produce()&#123; while(1)&#123; produce an item in dextp;//生产数据 P(empty);//获取空缓存区单元 P(mutex);//进入临界区 add nextp to buffer;//将数据放入缓存区 V(mutex);//离开临界区,释放互斥信号量 V(full)//满缓存区加1 &#125;&#125;consume()&#123; while(1)&#123; P(full);//获取满缓存区单元 P(mutex);//进入临界区 remove an item from buffer;//拿走数据 V(mutex);//离开临界区 V(empty);//空缓存区单元加1 consume the item//消费数据 &#125;&#125;","categories":[{"name":"理解计算机","slug":"理解计算机","permalink":"http://yoursite.com/categories/理解计算机/"}],"tags":[{"name":"计算机基础 操作系统","slug":"计算机基础-操作系统","permalink":"http://yoursite.com/tags/计算机基础-操作系统/"}]}]}