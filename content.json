{"meta":{"title":"Mr.喵的网络日志","subtitle":null,"description":null,"author":"ValenZhou","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"vue项目中的小总结","slug":"vue项目中的小总结","date":"2017-05-21T06:45:23.000Z","updated":"2017-11-22T08:06:23.000Z","comments":true,"path":"2017/05/21/vue项目中的小总结/","link":"","permalink":"http://yoursite.com/2017/05/21/vue项目中的小总结/","excerpt":"","text":"单文件组件中data必须是一个函数,然后返回一个对象.避免多个组件数据混乱.1234567 export default &#123; data()&#123; return &#123; a: \"123\", &#125; &#125;&#125; 列表循环时,尽量使用key,避免元素复用1&lt;div v-for=\"(item,index) in array\" :key=\"index\"&gt;&lt;/div&gt; 在vue中使用less安装less及less-loader依赖 1npm install less less-loader --save-dev 修改webpack配置文件 在单文件组件中使用 1&lt;style lang=\"less\" scoped&gt; $nextTick的用法异步更新队列:Vue在观察到数据变化时不会直接更新Dom,而是开启一个队列,并缓冲在同一事件循环中发生的所有数据变化,然后去除重复数据,避免重复计算和dom操作,然后在下一个事件循环tick中,刷新队列并执行实际(已去重)的工作.$nextTick就是用来知道什么时候dom更新完成的. 123&lt;div id=\"div\" v-if=\"isShow\"&gt;这是一段文本&lt;/div&gt;&lt;button @click=\"getText\"&gt;获取div内容&lt;/button&gt;&lt;!-- 当我们点击按钮时,获取div的文本 --&gt; 1234567getText: function()&#123; this.isShow = true; this.$nextTick(function()&#123; var text = document.getElementById('div').innerText; console.log(text); &#125;)&#125; webpack打包上传服务器后项目图片路径的问题1. 解决方式一: 修改config文件中index.js里assetsPublicPath为&apos;./&apos;, 然后修改webpack.base.conf.js里的url-loader的limit,根据文件大小相应的修改. 但是修改后打包的文件比较大,影响页面加载. 2. 解决方式二: 修改config文件中index.js里assetsPublicPath为&apos;./&apos;,然后修改源代码中css的图片路径为绝对路径, 静态资源由之前的src下的assets文件转移到src同级的static文件下新建一个img文件. 如果该项目有两级以上的域名,就在绝对路径前加上该子域名,如&apos;/XXX/static/img/a.png&apos; scoped下尽量不要使用标签选择器scoped下尽量不要使用标签选择器,会影响页面性能. vue组件添加原生事件vue组件添加原生事件,必须在事件后添加.native修饰符,否则事件不会生效. 在vue中使用TypeScript在vue中使用TypeScript 1. 安装依赖 12npm i vue-class-component vue-property-decorator --savenpm i ts-loader typescript tslint tslint-loader tslint-config-standard --save-dev 2. 配置webpack - 找到&apos;./build/webpack.base.conf.js&apos;添加 1resolve: &#123;extensions: ['.js', '.vue', '.json', '.ts'],&#125; - 找到module.rules,添加对.ts的解析 1234567891011121314&#123; test: /\\.ts$/, exclude: /node_modules/, enforce: 'pre', loader: 'tslint-loader'&#125;,&#123; test: /\\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: &#123; appendTsSuffixTo: [/\\.vue$/], &#125;&#125;, - 添加根路径tsconfig.json文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; // 编译选项 \"compilerOptions\": &#123; // 输出目录 \"outDir\": \"./output\", // 是否包含可以用于 debug 的 sourceMap \"sourceMap\": true, // 以严格模式解析 \"strict\": true, // 采用的模块系统 \"module\": \"esnext\", // 如何处理模块 \"moduleResolution\": \"node\", // 编译输出目标 ES 版本 \"target\": \"es5\", // 允许从没有设置默认导出的模块中默认导入 \"allowSyntheticDefaultImports\": true, // 将每个文件作为单独的模块 \"isolatedModules\": false, // 启用装饰器 \"experimentalDecorators\": true, // 启用设计类型元数据（用于反射） \"emitDecoratorMetadata\": true, // 在表达式和声明上有隐含的any类型时报错 \"noImplicitAny\": false, // 不是函数的所有返回路径都有返回值时报错。 \"noImplicitReturns\": true, // 从 tslib 导入外部帮助库: 比如__extends，__rest等 \"importHelpers\": true, // 编译过程中打印文件名 \"listFiles\": true, // 移除注释 \"removeComments\": true, \"suppressImplicitAnyIndexErrors\": true, // 允许编译javascript文件 \"allowJs\": true, // 解析非相对模块名的基准目录 \"baseUrl\": \"./\", // 指定特殊模块的路径 \"paths\": &#123; \"jquery\": [ \"node_modules/jquery/dist/jquery\" ] &#125;, // 编译过程中需要引入的库文件的列表 \"lib\": [ \"dom\", \"es2015\", \"es2015.promise\" ] &#125;&#125; - 添加根路径tslint.json文件 123456&#123; \"extends\": \"tslint-config-standard\", \"globals\": &#123; \"require\": true &#125;&#125; - 在src下创建vue-shim.d.ts 1234declare module \"*.vue\" &#123; import Vue from \"vue\"; export default Vue;&#125; 之后再代码中引入.vue文件时需要加上.vue后缀,因为ts默认只识别*.ts文件 - 改造APP.vue文件 12345678&lt;script lang=\"ts\"&gt; import Vue from 'vue' import Component from 'vue-class-component' @Component(&#123;&#125;) export default class App extends Vue &#123; &#125;&lt;/script&gt; - 修改main.js为main.ts,并修改&apos;./build/webpack.base.conf.js&apos;中的entry为 `{app: &apos;./src/main.ts&apos;}`","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"vue 前端","slug":"vue-前端","permalink":"http://yoursite.com/tags/vue-前端/"}]},{"title":"用NodeJS写一个爬虫","slug":"用NodeJS写一个爬虫","date":"2016-12-05T07:45:03.000Z","updated":"2017-12-05T07:51:45.000Z","comments":true,"path":"2016/12/05/用NodeJS写一个爬虫/","link":"","permalink":"http://yoursite.com/2016/12/05/用NodeJS写一个爬虫/","excerpt":"","text":"简介用NodeJS下一个爬虫,用来获取简书首页的文章,然后保存以txt文件的形式保存在本地,数量为20篇. 初始化项目​ npm init || yarn init 安装依赖​ npm install superagent cheerio —save || yarn add superagent cheerio 页面数据下载123456789101112131415161718192021const fs = require(\"fs\")const request = require(\"superagent\")const cheerio = require(\"cheerio\")let reptileUrl = \"http://www.jianshu.com/\"request .get(reptileUrl) .end(function(err,res)&#123; if(err)&#123; &#125; else&#123; let $ = cheerio.load(res.text,&#123;decodeEntities:false&#125;) //每页有20篇文章,找到标题及其href的值 $(\"#list-container .note-list li\").each(function(index,value)&#123; let url = $(v).find(\".title\").attr(\"href\") //url即文章的链接,需要和reptileUrl拼接起来 getContent(url) &#125;) &#125; &#125;) 获取文章内容,保存在本地1234567891011121314151617181920212223242526272829303132function getContent(url)&#123; let adress = reptileUrl + url request .get(adress) .end(function(err,res)&#123; if(err)&#123; &#125;else&#123; let $ = cherrio.load(res.text,&#123;decodeEntities:false&#125;) //文章标题 let title = $(\".article .title\").text() //文章内容 let content = '' $(\".article .show-content p\").each(function(i, v, a) &#123; content += $(v).text(); &#125;) //要写入的数据 let data = &#123; title: title, content: content &#125; //本地保存 fs.writeFile('../data/' + title + '.txt', JSON.stringify(data), 'utf-8', function(err) &#123; if (err) &#123; &#125; else &#123; console.log(\"It's OK !\") &#125; &#125;) &#125; &#125;)&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"node 爬虫","slug":"node-爬虫","permalink":"http://yoursite.com/tags/node-爬虫/"}]},{"title":"重温<<计算机操作系统>>","slug":"重温-计算机操作系统","date":"2015-10-18T07:19:25.000Z","updated":"2017-11-14T06:02:28.000Z","comments":true,"path":"2015/10/18/重温-计算机操作系统/","link":"","permalink":"http://yoursite.com/2015/10/18/重温-计算机操作系统/","excerpt":"","text":"并发与并行概念并行是指两个或多个事件在同一时刻发生,而并发是两个或多个事件在同一时间间隔内发生.在多道程序环境下,并发性是指在一段时间内宏观上有多个程序在同时运行,但在单处理机系统中,每一时刻却仅能有一道程序执行,故微观上这些程序只能是分时的交替执行.倘若在多处理机,这些可以并发执行的程序便可分配到多个处理机上,实现并行执行. 理解如果某个系统支持两个或多个动作同时存在,name这个系统就是一个并发系统.如果某个系统支持两个或多个动作同时执行,那么这个系统就是一个并行系统.并发系统与并行系统这两个定义之间的关键差异在于存在这个词. 在并发程序中可以同时拥有两个或多个线程,这意味着,如果程序在单核处理器上运行,那么这两个线程将交替换入或换出内存.这些线程是同时存在的,每个线程都处于执行过程中的某个状态.如果程序能够并行执行,那么就一定是运行在多核处理器上的.此时,程序中的每个线程都将分配到一个独立的处理器核上,因此可以同时运行. 我相信你已经能够得出结论:”并行概念是并发概念的一个子集”.也就是说,你可以编写一个拥有多个线程或进程的并发程序,但如果没有多核处理器来执行这个程序,那么就不能以并行的方式来运行代码.因此,凡是在求解单个问题涉及多个执行流程的编程模式或执行行为,都属于并发编程的范畴. 摘自:&lt;&lt;并发的艺术&gt;&gt;-[美]布雷谢斯 Erlang 之父 Joe Armstrong 用一张5岁小孩都能看懂的图解释了并发与并行的区别.从图中可以看出,并发是两个队列交替使用一台咖啡机,并行是两个队列同时使用两台咖啡机.如果串行,一个队列使用一台咖啡机.并发和并行都可以是多个线程,就看这些线程能不能同时被多个CPU执行,如果可以说明是并行,而并发是多个线程被一个CPU轮流切换着执行. 进程与线程概念对进程较为经典的定义有: 1. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动. 2. 进程是程序在一个数据集合上运行的过程,它是系统进行资源分配和调度的一个独立单位. 3. 系统为每个进程定义了一个数据结构-进程控制块(PCB).OS根据PCB来对并发执行的进程进行控制和管理. 线程和进程的比较: 1. 再引入线程的操作系统中,通常一个进程都拥有若干个线程,至少有一个线程. 2. 进程为资源拥有的最小单位,而线程作为调度和分派的基本单位,线程不拥有系统资源,可以访问资源. 理解进程和线程的主要差别在于他们是不同的操作系统资源的管理方式.进程有独立的地址空间,一个进程崩溃后,在保护模式下不会对其他进程产生影响,而线程只是一个进程中的不同执行路径.线程有自己的堆栈和局部变量,但线程没有单独的地址空间,一个线程死掉就等于整个进程死掉,所以在进程切换时,耗费资源较大,效率变差.但对于一些要求同时进行并且又要共享某些变量的并发操作,只能用进程,不能用线程. 生产者消费者问题概念生产者消费者问题是一个经典的多进程同步问题,也叫缓存绑定问题. 既有两个进程:一组生产者进程和一组消费者进程共享一个初始值为空固定大小为n的缓存区.生产者的工作是制造一段数据,只要缓存没满就放入缓存区,否则必须等待,如此反复.同时,只要缓存区不为空,消费者才能从中取出消息,一个取出一段数据,否则只能等待.由于缓存区是临界资源,它只允许一个生产者放入消息,或一个消费者从中取出消息. 问题的核心是要保证不让生产者在缓存满的时候还要向内写数据,不让消费者试图从空的缓存中取出数据. 理解生产者和消费者对缓存区互斥访问是互斥关系,同时又是相互协作关系,即同步关系.那么需要解决的是互斥和同步PV操作的位置.使用”进程间通信”即可解决唤醒问题: 我们使用了两个信号标:full和empty.信号量mutex作为互斥信号量.用于控制互斥访问缓存池,互斥信号量初始值为1.信号量full用于记录当前缓冲池中”满”缓冲区数,初始值为0.信号量empty用于记录当前缓存区”空”缓存区数,初始值为n.新的数据增加后,full增加,empty减少.如果生产和试图在empty为0时减少其值,生产者就会被”催眠”.下一轮中有数据消费掉时,empty就会增加,生产者就会被”唤醒”.1234567891011121314151617181920212223semaphore mutex = 1;//临界区互斥信号量semaphore empty = n;//空闲缓存区semaphore full = 1;//缓存区初始化为空produce()&#123; while(1)&#123; produce an item in dextp;//生产数据 P(empty);//获取空缓存区单元 P(mutex);//进入临界区 add nextp to buffer;//将数据放入缓存区 V(mutex);//离开临界区,释放互斥信号量 V(full)//满缓存区加1 &#125;&#125;consume()&#123; while(1)&#123; P(full);//获取满缓存区单元 P(mutex);//进入临界区 remove an item from buffer;//拿走数据 V(mutex);//离开临界区 V(empty);//空缓存区单元加1 consume the item//消费数据 &#125;&#125;","categories":[{"name":"理解计算机","slug":"理解计算机","permalink":"http://yoursite.com/categories/理解计算机/"}],"tags":[{"name":"计算机基础 操作系统","slug":"计算机基础-操作系统","permalink":"http://yoursite.com/tags/计算机基础-操作系统/"}]}]}