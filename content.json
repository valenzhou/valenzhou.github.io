{"meta":{"title":"Mr.喵的网络日志","subtitle":null,"description":null,"author":"ValenZhou","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"<CSS世界>读书笔记","slug":"CSS世界-读书笔记","date":"2018-04-12T03:11:01.000Z","updated":"2018-04-12T03:22:42.223Z","comments":true,"path":"2018/04/12/CSS世界-读书笔记/","link":"","permalink":"http://yoursite.com/2018/04/12/CSS世界-读书笔记/","excerpt":"","text":"最近在看张鑫旭的&lt;&lt;CSS世界&gt;&gt;,对里面说的一些干货做了点总结,如果希望看到更多知识,请自行购买. 概论何为流?“流”实际上是CSS世界中的一种基本的定位和布局机制,可以理解为现实世界的一套物理规则,”流”和现实世界的”水流”有异曲同工之妙.就好像我们把水流入一个容器,水面一定是平整的,我们在水中放入物体,水面升高物体依次排列.所以”流”就是CSS世界中引导元素排列和定位的一条看不见的水流. 流,元素与基本尺寸块级元素“块级元素”和display:block;不是一个概念.比如&lt;li&gt;元素默认的display是list-item,&lt;table&gt;对应的display是table,但它们都是块级元素,因为它们符合块级元素的特征,也就是一个水平流上只能单独显示一个元素,多个元素则换行显示.正是由于块级元素的换行特性,理论上它都可以配合clear属性来清除浮动. 12345.clear:after&#123; content: ''; display: table;//或block等. clear: both;&#125; 外部尺寸和内部尺寸当一个元素的尺寸由外部元素决定就称为外部尺寸,当一个元素的尺寸由内部元素决定就称为内部尺寸. 深藏不漏的width: auto 正常流宽度 在页面中随便扔一个div元素,它就会具备block容器的流特性. 1234a&#123; display: block; width: 100%;&#125; a元素的display 默认是 inline,当它设置为 block的时候使其具有块状化.但width设置为100%则完全没有必要.”鑫三无原则”,即”无宽度,无图片,无浮动”.为何无宽度?因为表现为”外部尺寸的”块级元素一旦设置了宽度,流动性就失去了.所谓流动性,并不是看上去宽度为100%那么简单,而是一直margin/border/padding以及content内容区域自动分配水平空间的机制. 格式化宽度 格式化宽度值出现在”绝对定位模型”中,也就是当position为absolute或fixed元素中,默认情况下,绝对定位元素的宽度是由内部尺寸决定的,但是有一种情况宽度由外部尺寸决定.对于非替换元素(…)当left/right或top/bottom对立的属性值同时存在时,元素的宽度为格式化宽度 123456789div1&#123; width: 1000px; position: relative; div2&#123; position: absolute; left: 20px; right: 20px; &#125;&#125; 由以上样式可知,div2的宽度为1000-20-20 = 960 内部尺寸和流式特性 button按钮是CSS极具代表的inline-block元素,是展示”包裹性”最好的例子,具体表现为:按钮文字越多宽度越宽(内部尺寸特性),但文字足够多,在容器宽度处自动换行(自适应特性). 包裹性在实际开发中的用处: 页面某个模块文字内容是动态的,希望文字少的时候居中显示,文字多的时候居左显示.代码如下: 1234567.box&#123; text-align: center;&#125;.content&#123; display: inline-block; text-align: left;&#125; width值作用的细节 CSS盒模型的组成模式有两种: 一种是border-box.即padding和border也被包含在width和height中的怪异下的盒模型,还有一种是content-box为标准模式下的盒模型. 给width属性赋一个值,该值作用在content上,且一旦设定width值,该元素就没有了流动性,所以提出”无宽度准则”,这样会更灵活,容错性更强. CSS流体布局下的宽度分离原则(便于维护) 也就是CSS中的width属性不与其他影响宽度的padding/border/margin属性共存.width属性独占一层标签,而padding/border等属性利用流动性在内部自适应实现. 12345678.father&#123; width: 180px; .son&#123; margin: 0 20px; padding: 20px; border: 1px solid; &#125;&#125; 相对简单单纯的height: autoCSS的默认流是水平方向的,宽度是稀缺的,高度是无限的,所以宽度的分配规则比较复杂,高度显得比较随意. 关于height: 100% 对于width属性就算父元素的width是auto,其百分比值也是支持的.但是,对于height属性,如果父元素的height为auto,只要子元素在文档流中,其百分比的值就被忽略了.我们发现百分比高度值想要生效,其父级必须有一个可以生效的高度值. 要明白其中的原因要先了解浏览器渲染的基本原理.首先下载文档内容,加载头部的样式资源,然后从上而下,自外而内的顺序渲染DOM内容.因此,当渲染到父元素的时候,子元素的width:100%;并没有渲染,宽度就是内容的宽度,等渲染到子元素时,父元素宽度已经固定,此时width:100%;就是父元素的宽度.宽度不够溢出就好了.overflow属性就是为此而生的.为什么宽度支持,高度不支持呢?规范中给出了答案,如果包含块的高度没有显式指定(即高度由内容决定),并且该元素不是绝对定位,则计算值为auto.一句话总结就是,高度没有显式指定则解释为auto,再和百分比计算结果为NaN 想要他生效只有如下设置: 123html,body&#123; height:100%;&#125; 1234div&#123; height:100%; position: absolute;&#125; max-width/height,min-width/height与width/height区别 width/height的默认值是auto,而min-width/height 的默认值是0,max-width/height的默认值是none. 他们三者也有一套相互覆盖的规则:超越!important,超越最大 1234&lt;img src=\"1.jpg\" style=\"width: 480px!important\"/&gt;img&#123; max-width: 260px;//max-width会覆盖width.&#125; 12345div&#123; min-width: 1400px; max-width: 1200px; //当min比max还要大的时候,遵循'超越最大'原则&#125; 内联元素​ inline和block是流式布局的本质所在.从作用上来讲,块级负责结构,内联负责内容.且内联元素设计的属性非常多,且往往具有继承属性. ​ 从定义看,内联元素与display:inline不是一个概念.因为display:inline-block;与display:inline-table;也是内联元素,因为他们的外在盒子都是内联元素. 从表现上,内联元素的典型特征就是可以和文字显示在一行.因此,文字是内联元素,按钮也是内联元素,输入框下拉框都是. 盒尺寸四大家族深入理解content 什么是替换元素? 根据”外在盒子”是内联还是块级,我们把元素分为内联元素和块级元素.而根据是否具有可替换内容我们把元素分为替换元素和非替换元素.举个例子,&lt;img src=&quot;1.jpg&quot;&gt;但我们把src换为2.jpg图片就会替换,这种通过修改某个属性值就可以被替换的元素称为”替换元素”.所以的替换元素都是内联水平元素. 替换元素有三种尺寸,分别为固有尺寸,HTML尺寸,CSS尺寸. 1234567&lt;img src=\"1.jpg\"&gt; /如果没有HTML尺寸和CSS尺寸,则使用固有尺寸即图片的尺寸/&lt;img src=\"1.jpg\" width=\"128\" height=\"96\"&gt; /如果没有CSS尺寸则使用HTML尺寸/&lt;img src=\"1.jpg\"&gt;img&#123; width:200px; height:100px;/如果有css尺寸则使用css尺寸/&#125; CSS世界中的替换元素有一个很重要的特性,那就是’我们无法改变这个替换元素内容的固有尺寸’.那为什么我们设置width和height会影响图片尺寸呢?那是因为图片中的content替换内容的默认适配方式是”填充”,不管设置的尺寸有多大,就填充多大.在CSS3之前这种适配方式是不能修改的.CSS3我们可以通过object-fit属性修改该方式,例如&lt;img&gt;元素的默认声明是object-fit:fill;如果我们设置为object-fit:none;那么图片的尺寸就完全不受控制.如果我们设置为object-fit: contain;则图片保持比例尽可能的利用HTML的尺寸但又不会超出的方式显示. 替换元素和非替换元素的区别主要在于src和content. content生成辅助元素 实际项目中,content属性主要用于::before以及::after这两个伪元素中.此应用的核心点不在content上,而在伪元素上,所以我们通常会写content:&#39;&#39;; 生成辅助元素后再实现特定布局或实现图形效果.辅助元素最常用的应用是清除浮动.如下: 12345.clear:after&#123; content: ''; display: block; clear: both;&#125; content字符内容生成 content字符内容生成就是直接写入字符内容,中英文都可以,比较常见的就是配合@font-face规则实现图标字体效果. content图片生成 content图片生成指的是直接使用url功能符显示图片. 123div:before&#123; content: url(1.jpg);&#125; 但我们对于图片的宽高不好控制,无法改变图片的固有尺寸.所以我们通常使用background-image. 1234div:before&#123; content: ''; background: url(1.jpg)&#125; content计数器 主要是两个属性和一个方法. counter-reset: 计数器名字 计数器的默认值; counter-increment: 计数器名字 递增的值(省略的话默认是1); 方法:counter(name) 显示计数. ​ 温和的padding属性 padding和元素的尺寸 因为CSS默认的box-sizing是content-box,所以使用padding会影响元素的尺寸.但对于内联元素(不包括替换元素)而言,padding影响水平方向,而不影响垂直方向,这样的说法也不完全准确.由于内联元素没有可视宽度和可视高度的说法,垂直方向完全受line-height和vertical-align的影响,所以从视觉上来说,padding在垂直方向上没有起作用,但是我们给它加个背景色会发现其尺寸确实受到影响了.在实际开发中,我们可以在不影响布局的前提下,优雅的增加链接或按钮的点击区域大小. padding的百分比取值 padding的值和margin值不同之处在于,padding的值不可以是负数.还有,padding的值如果是百分比,不论是水平方向还是垂直方向都是相对于宽度来说的. padding与图像绘制 padding和background-clip属性配合可以在有限的标签下实现一些CSS绘制效果. 比如如何用一个标签绘制”大队长”三道杠的分类图标效果. 12345678910.menu&#123; display: inline-block; width: 140px; height: 10px;//中间的杠 padding: 35px 0; border-top: 10px solid;//上面的杠 border-bottom: 10px solid;//下面的杠 background-color: currentColor; background-clip: content-box;&#125; 激进的margin属性 相关概念 元素尺寸: border + padding + content 元素内部尺寸: padding + content 元素外部尺寸: margin + border + padding + content margin与元素尺寸以及相关布局 一旦宽度设定,margin就无法改变元素尺寸. 1234.div&#123; width: 100px; margin: 0 -20px;//元素宽度还是100px&#125; ​ 只要元素的尺寸表现符合’充分利用可用空间’无论是垂直方向还是水平方向都可以通过margin改变尺寸. 123456.father&#123; width: 100px;&#125;.son&#123; margin: 0 -20px; //该元素空间为140px;&#125; 正是这种具有流体特性下的改变尺寸特性,margin可以很方便的实现很多流体布局效果,比如说一侧定宽,一侧自适应. 123456789.left&#123; width:100px; height:100px; float: left;&#125;.right&#123; height: 100px; margin-left: 100px;&#125; margin的百分比值 和padding一样,margin的百分比值无论是水平方向还是垂直方向都是相对于宽度计算的. margin的合并 块级元素的margin-top和margin-bottom通常会合并为一个margin.我们可以捕获两点重要信息,一是块级元素,二是垂直方向. margin合并的计算规则:正正取大值,正负值相加,负负最负值. 深入理解margin: auto; 我们首先要知道,有时候元素就算没有设置height和width,也会自动填充和自动填充对应的方位.假设一个外部的容器宽度是300px, 而内部的容器因为设置宽度为200px而导致原本应该自动填满的空间现在有100px闲置了,margin: auto就是为了填充这个闲置的尺寸的.margin:auto;的填充规则是: 如果一侧定值,一侧auto,则auto为剩余的空间大小.如果两侧都是auto,则平分剩余空间. 当我们想要某个块级元素右对齐时,脑子里不要就一个float:right;,很多时候margin-left:auto;才是最佳实践.浮动毕竟是个”魔鬼”,margin属性的auto计算就是为了块级元素左右对齐而设计的,和内联元素的text-align控制左右对齐相呼应. 我们可能会发现margin:auto;并不能实现垂直居中,但是我们可以利用绝对定位实现这个需求.因为绝对定位后,top/bottom/left/right会自动填充,但又因为设置了宽高,导致多余的空间闲置,这时margin:auto;就可以计算空间了. 123456.son&#123; position: absolute; top:0; right: 0; bottom: 0: left:0; width:200px; height:100px; margin: auto;//实现垂直居中.&#125; 功勋卓越的border属性 border与透明边框技巧 优雅的增加点击区域大小. 12345.click&#123; width:16px; height: 16px; border: 11px solid transparent;&#125; 三角形图形绘制 12345div&#123; width: 0; border: 10px solid; border-color: #f30 transparent transparent;&#125; 内联元素与流字母x是CSS中隐匿的举重若轻的角色各种内联相关模型中,凡是涉及垂直方向的排版或是对齐的,都离不开最基本的基线.字母x下的下边缘就是基线. vertical-align:middle;并不是绝对的垂直居中对齐,这里的middle是基线往上1/2 x-height的高度,也就是字母x的交叉点的位置.所以middle得垂直居中只是一种近似效果. 字母X衍生了x-height(字母x的高度)的概念,并进一步衍生出了ex,ex是css中的一个尺寸单位,是一个相对单位,指的是小写字母x的高度.其实就是x-height. 内联元素的基石 line-height思考下面的问题,一个默认的空div高度是0,里面写上几个文字后高度就有了,这个高度从何而来? 不少人认为是由文字把内容撑开的,但本质上是由line-height属性所决定的,对于文本这样的纯内联元素,line-height就是高度计算的基石. 为什么line-height可以让内联元素垂直居中?这是一个误区,要想让单行文字垂直居中只要设置line-height大小就可以了,和height没有任何关系. 1234567.title&#123; height: 24px; line-height: 24px;&#125;.title2&#123; line-height:24px;&#125; 多行文本和替换元素的垂直居中和单行文本不一样, 需要用到vertical-align:middle的帮助. 123456.content&#123; display: inline-block; line-height: 20px; margin: 0 20px; vertical-align: middle;&#125; line-height的值一般为固定长度值,也可以是数值和是百分比,两者的值都是与font-size相乘后的值. 内联元素的大值特性:无论内联元素的line-height如何设置,最终父级元素的高度都是由数值最大的那个line-height所决定的. line-height的好朋友vertical-align为什么说他们是好朋友呢,因为凡是line-height起作用的地方vertical-align也一定起作用.因为vertical-align的默认值是baseline基线对齐,而基线的定义是x的下边缘.它等同于vertical-align:0; ####基于vertical-align属性的水平垂直居中大小不固定弹框 12345&lt;div class=\"container\"&gt; &lt;div class=\"dialog\"&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.container&#123; position: fixed; top:0;right:0;bottom:0;left:0; background-color: rgba(0,0,0,.5); text-align: center; font-size:0; white-space: nowarp; overflow: auto;&#125;.container:after&#123; content: ''; display: inline-block; height: 100%; vertical-align:middle;&#125;.dialog&#123; display: inline-block; vertical-align:middle; text-align:left; font-size:14px; white-space: nowarp;&#125; 流的破坏与保护魔鬼属性float浮动的本质就是为了实现文字环绕效果,这种文字环绕主要指文字环绕图片的显示效果.理论上可以通过float把整个页面结构都弄出来,但这种方式太脆弱缺乏弹性.一旦某个元素宽高发生变化,就会发生布局错位. float的特性: 包裹性 假设浮动元素的父元素width为200px,浮动元素子元素是一个宽度为128px的图片,此时元素宽度表现为”包裹”,就是里面图片的宽度128px; 123456789.father&#123; width:200px; .float&#123; float: left;//该元素宽度为128px; img&#123; width:128px; &#125; &#125;&#125; 如果浮动元素的子元素不止是一张图片,还有许多文字,就会出现”自适应性”,此时浮动元素的宽度为父元素的宽度200px; 块状化并格式化上下文 块状化即float的值只要不是none,其display就会成为block或table. 破坏文档流 没有任何margin合并 float的作用机制float的最著名的特性表现就是会让父元素的高度塌陷.但只要父元素设置了一个具体的值就不需要担心高度塌陷的问题了.但不建议这样做,比较稳妥的做法还是采用一些手段清除浮动带来的影响. float与流体布局我们可以利用float破坏css正常流的特性,实现两栏或多栏的自适应布局. 一侧定宽,一侧自适应布局. 123456789.left&#123; width:100px;//不定宽可以设置为百分比 height:100px; float:left;&#125;.right&#123; height:100px; margin-left: 100px;//不定宽可以设置为百分比&#125; float的天然克星clear其语法如下: clear : none | left | right | both; clear属性本质上并不是清除浮动,而是让自身不能和浮动元素相邻,但clear属性只对块级元素有效.这也就是我们在借助::after等伪元素(内联)清除浮动时需要设置display的原因. 12345.clear:after&#123; content: ''; display: block; clear: both;&#125; CSS的结界-BFCBFC全称 block formatting context,中文为”块级格式化上下文”. 它的表现原则为: 如果一个元素具有BFC,内部子元素再怎么样也不会影响外部的元素,所以BFC不可能发生margin重叠的.BFC也可以用来清除浮动的影响,因为不清除浮动会影响后面的布局和定位. 什么时候会触发BFC呢? &lt;html&gt;根元素 float的值不为none; overflow的值为auto, scroll 或 hidden; display 的值为: inline-block,table-cell,table-caption中的任何一个; position的值不为static和relative; 只要元素符合上面的任何一个条件就无需使用clear:both;去清除浮动的影响了. 最佳结界overflow要想彻底清除浮动的影响,最适合的属性不是clear而是overflow.一般使用overflow:hidden; HTML中有两个标签是可以默认产生进度条的,一个是根元素&lt;html&gt;,另一个是文本域&lt;textarea&gt;,之所以出现滚动条是因为这两个标签的overflow的默认值不是visible. 滚动条是可以自定义的.支持-webkit-前缀的浏览器可以这样设置. 123456789101112::-webkit-scrollbar&#123; width: 8px;/*血槽宽度*/ height: 8px;&#125;::-webkit-scrollbar-thumb&#123; background-color: rgba(0,0,0,.3);/*拖动条*/ border-radius: 6px;&#125;::-webkit-scrollbar-track&#123; background-color: #ddd;/*背景槽*/ border-radius: 6px;&#125; overflow与锚点定位:锚点就是可以让页面定位到某个位置的点,本质上是通过改变容器滚动高度或者宽度来实现的.设置了overflow属性为auto,scroll,hidden的元素是可以滚动的,overflow:hidden与scroll 和 auto的区别就在于有没有那个滚动条.高度溢出,滚动依旧存在,只是滚动条不存在,牢记这一点可以让我们更简单更原生的方式实现一些交互效果. CSS世界的层叠规则在css中,z-index属性只有和定位元素(position不为static的元素)在一起的时候才有用,可以是正数也可以是负数.但随着css3到来,flex盒子也可以使用z-index属性. CSS层叠顺序类型如下:(由低到高) 层叠上下文background/border -&gt; 负z-index -&gt; block盒子 -&gt; float浮动盒子 -&gt; inline水平盒子 -&gt; z-index: auto或0 -&gt; 正z-index. CSS3新时代的层叠上下文: 元素为flex布局的元素. 元素opacity不是1 元素的transform不是none 元素mix-blend-mode不是 normal 元素isolation是isolate 元素will-change属性为上面2-6的任意一个 元素filter不是none 元素的-webkit-overflow-scrolling为touch z-index”不犯二”准则:对于非浮层元素,避免设置z-index的值,z-index的值没有任何道理需要超过2. 强大的文本处理能力font-size的能力line-height的部分类别属性是相对于font-size计算的,而vertical-align百分比属性值又是相对于line-height计算的. 1234567p&#123; font-size: 16px; line-height: 1.5;&#125;p &gt; img&#123; vertical-align: -25%; /* (即16px * 1.5 * -25% = -6px) */&#125; font-size与ex,em,和rem的关系: ex是字符x的高度,font-size越大,对应的ex越大.em是根据当前元素的font-size计算的,而rem( root-em )是相对于HTML根元素的font-size进行计算的. 桌面Chrome浏览器有一个12px的字号限制但并不是所有小于12px的字号都当做12px处理,有一个值例外那就是0. 如果font-size:0;那么文字就会被直接隐藏掉.不然哪怕是0.00001px也会被当做12px处理. font-weight表示文字的粗细程度,我们通常设置为bold 和 normal.也可以设置为100-900,该值必须是整百数.其中400等同于normal,700等同于bold. font属性联写: [font-style] ? font-size [/line-height].例如.font{ font: normal 700 14px/20px } 了解@font face@font face 本质上就是一个定义字体和字体集的变量.这个变量不仅仅是简单的自定义字体,还包括字体重命名,默认字体样式设置.它大多用于字体图标技术.所谓字体本质上就是字符集和图形的一种映射关系.字体图标技术通常把字符映射成另外的图标形状,我们看到的图标,本质上就是一个普通的字符. 文本的控制text-indent就是对文本进行缩进控制.项目中我们用的最多的就是给text-indent一个很大的负值来隐藏文本内容.比如很多网站的LOGO放在&lt;h1&gt;中,然后设置一个很大的负值,比如-9999em. letter-spacing用来控制与字符的间距.这里的字符包括英文字母,汉字以及空格.支持负值. word-spacing用来控制与单词间的间距.它仅作用于空格而不是字面上的单词. white-space 声明了如何处理元素内的空白字符,normal为合并,pre为不合并,只有在换行符的地方换行.nowrap合并空白但不允许文字环绕.当设置为nowrap时,元素的宽度此时表现为”最大可用宽度”,换行符和一些空格全部合并,文本在一行显示. 如何解决text-decoration下划线和字体重叠的问题?可以用兼容性并不好的text-decoration-skip属性,或用box-shadow或background-image模拟,然而最好的解决方式是看似普通却很有用的border属性. 1234a&#123; text-decoration: none; border-bottom: 1px solid;&#125; text-transform是专门为英文字符设计的,要么全部大写text-transform: uppercase,要么全部小写text-transform: lowercase,身份证号的x输入以及验证码的字母大小写都可以使用这个属性实现需求. 元素的显示与隐藏 display:none; display:none;可以让元素以及所有后代元素都隐藏,占据的空间消失,是真正意义上的隐藏. 在火狐浏览器下display:none的元素的background-image是不加载的,但是chrome和safari视情况而定,父元素隐藏图片不加载,自身元素隐藏,图片依旧会加载. visibility:hidden; 与display:none一样可以隐藏元素,但visibility:hidden;保留元素的空间.但他和display:none不一样的是,它具有继承性,父元素设置visibility:hidden;子元素也会看不到,一旦子元素设置visibility:visible;子元素就会显示出来这种后代可见特性在开发中非常有用. visibility可以喝transition配合使用,而display不能和transition配合,因为transition的属性有visibility而没有display. 12345678.list&#123; position:absolute; visibility: hidden;&#125;td:hover .list&#123; visibility: visible; transition: visibility 0s .2s;&#125; 希望元素不可见,不能点击,不占空间,但键盘可访问可以使用clip: rect(0 0 0 0 )剪切隐藏. 希望元素不可见,不能点击,但占据空间且键盘可访问使用relative配合负z-index隐藏 希望元素不可见,但可以点击,不占空间可以使用opacity:0;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"css 前端","slug":"css-前端","permalink":"http://yoursite.com/tags/css-前端/"}]},{"title":"2017前端技术发展回顾","slug":"2017前端技术发展回顾","date":"2018-03-12T08:39:32.000Z","updated":"2018-03-12T08:53:53.000Z","comments":true,"path":"2018/03/12/2017前端技术发展回顾/","link":"","permalink":"http://yoursite.com/2018/03/12/2017前端技术发展回顾/","excerpt":"","text":"HTML 5.2 发布 毫无疑问,这是Vue.js在流行中飞速发展的一年. 前端HTML &amp; CSS 开发者和前端应用程序开发者之间的巨大差别终于被认知,并重新定义. 作为使用web技术构建应用程序的前端 JavaScript开发者变得越来越好,也越来越糟. 今年似乎比往年更多的涌现出一批试图与主流 JavaScript 应用工具（React，Angular，Vue 等）相抗衡的应用程序/框架解决方案。我来列举一部分，Moon，Marko，Hyperapp，Quasar Framework，POI，frint，BunnyJS，jsblocks，Sapper，Stimulus，Choo… jsbin 和 jsfiddle 进化成了 StackBliz 和 codeSandbox 的样子，它们让分享一个应用程序变得如此简单 React 继续被 preact，inferno，nerv，dva 和 rax 之类的所追捧。 devhints.io 很好地将 cheatsheets 组织了起来。 我们发现应用程序的样板或者命令行工具是带有偏见的，例如 React Create App，必要的时候我们要从中逃离。 大多数开发人员发现，一个好的代码编辑器，eslint 以及 prettier 的组合使写代码这件事更快，更轻松愉快. CSS Flexbox 和 Grid 获得浏览器支持，因此越来越多开发者开始关注这两者。 我们终于有无头的 Chrome 了。 你不再需要用 Less 或者 Sass 来使用 CSS 来完成令人惊叹的事情了。 CSS 革命正在进行中。 JavaScript 对象浏览工具已经到来，JavaScript Array Explorer和 JavaScript Object Explorer，它们对于学习 JavaScript 数据类似（例如对象）是非常方便有用的。 Chrome 浏览器在市场上占据主导地位，人们开始担心历史可能会重演。 Brave 成为浏览互联网最愉快且安全的方式。 PhantomJS 不再维护，Headless Chrome 和 Puppeteer 进入。 Prettier 从一个意想不到的地方开始，却成为了一个主角。 很多开发者开始采用静态检查，主要是出于主观原因和赶时髦。有些人完全遵从了 Typescript 和微软的做事方式，也有些人采取的较慢的 Flow。有一点可以肯定，大多数开发者不需要类型，他们只是把已经复杂的问题和解决方法更加复杂化。像大多数事情一样，这种趋势大部分是主观教条而非客观价值。 Web 组件仍然潜伏着，等待着开发人员的大力推动，这可能永远不会发生。 JavaScript 安定了，CSS 爆发了，明年的这个时候所有人都会疲惫不堪。 许多人在使用组件树构建应用程序的时候，开始将 CSS 转移到 JS 中的 CSS 里。 Yarn 似乎满足了需求，因为很多人从 npm 换成 Yarn。然而，Yarn 最大的价值在于它为 npm 带来竞争，从而使得 npm 变得更好。 Scrimba 将用于交互式的编码屏幕录像（录制现场的编辑器是可编辑的）的新的视频格式成为现实。 大多数人开始意识到组件架构和原子化设计之间的关联。 ES 模块将成为浏览器的一部分，并且如果使用 ES 模块，备用计划将是必需的（即来自 webpack 之类的打包文件）。 MVC 框架正在淡出。 使用Bluekit，Storybook，React Styleguidist 和 bit 之类的工具，在你的应用程序之外开发和展示 React 组件开始变得流行。 在 2017 年获得前端工作有关经验，这是从个人项目以及 Github 账号上展示出来的。 从 HTML 文档中预加载资源（CSS，JavaScript，多媒体文件等）到来了。 Cypress 作为一个完整的测试解决方案出现了，测试会越来越好，因为对于应用程序的代码，端到端测试才是重点。 WebAssembly 现在可以总所有主流浏览器中使用了。 Webpack 占主导地位，然后竞争对手 parcel 出现了。 React 16 代号 fiber 发布。 在某些情况下，React 开始与 jQuery 一较高下了. React 的确成为了最多人使用的构建 UI 的工具. Facebook 放弃了 React 的 BSD 许可证，而转成了 MIT 许可证（同样包括 Jest，Flow，Immutable.js 和 GraphQL）。 2017 年 GraphQL 开始流行起来。 Facebook 继续领头负责开发即将到来的如 prepack.io 之类的工具。 正如期待，ECMA-262 第 8 版也就是 ES2017 发布。 React Router 终于稳定下来了。 所有的现代浏览器现在都支持 ECMAScript 2015（也就是 ES6）。 Async JavaScript 函数 开始获得一些认真的关注及使用，主要是因为所有现在浏览器现在都支持 Async 函数了。 移动开发，仍然很难。今年，强烈地倡导 web 平台作为解决这一痛苦的方案获得了大量的支持。 原文地址：Recap of Front-end Development in 2017原文作者：FrontendMasters译文出自：掘金翻译计划本文永久链接：点击译者：bambooom校对者：realYukiko","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端 技术 回顾","slug":"前端-技术-回顾","permalink":"http://yoursite.com/tags/前端-技术-回顾/"}]},{"title":"学习CSS Grid布局","slug":"学习CSS-Grid布局","date":"2017-12-13T07:39:20.000Z","updated":"2017-12-13T07:42:01.000Z","comments":true,"path":"2017/12/13/学习CSS-Grid布局/","link":"","permalink":"http://yoursite.com/2017/12/13/学习CSS-Grid布局/","excerpt":"","text":"CSS Grid 布局是CSS中最强大的布局系统,与flexbox的一维布局系统不同,CSS Grid是一个二维布局系统,它可以同时处理行和列. 第一个Grid布局css Grid布局由两个核心组成部分,warpper(父元素)和items(子元素).warpper是实际的grid(网格),items是网格的内容. 下面是一个warpper元素,内部包含了6个items: 12345678&lt;div class=\"warpper\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 要把warpper元素变成一个grid(网格),只需要把它的display属性设置为grid即可. 123.warpper&#123; display:grid;&#125; 这时我们还没有写任何样式,他会简单的将6个div堆叠在一起. Columns(列)和rows(行)为了使其成为二维的网格容器,我们需要定义行和列.让我们创建两行三列,使用grid-template-cloumns和grid-template-rows属性. 12345.warpper&#123; display:grid; grid-template-rows: 100px 50px; grid-template-cloumns: 100px 80px 60px;&#125; 我们为grid-template-cloumns写入了3个值,这样我们就得到了3列,每列的值代表列的宽度.而grid-template-rows代表行数及行的高度. 放置items(子元素)为了帮助理解,我们在每个items(子元素)加上单独的class. 12345678&lt;div class=\"warpper\"&gt; &lt;div class=\"item1\"&gt;1&lt;/div&gt; &lt;div class=\"item2\"&gt;2&lt;/div&gt; &lt;div class=\"item3\"&gt;3&lt;/div&gt; &lt;div class=\"item4\"&gt;4&lt;/div&gt; &lt;div class=\"item5\"&gt;5&lt;/div&gt; &lt;div class=\"item6\"&gt;6&lt;/div&gt;&lt;/div&gt; 现在我们来创建一个 3*3的grid: 12345.warpper&#123; display:grid; grid-template-rows: 100px 100px 100px; grid-template-cloumns:100px 100px 100px;&#125; 我们只在页面上看到3-2的grid,而我们定义的是3-3的grid.这是因为我们只有6个items来填充这个网格.我们我们再追加3个items,name最后一行也会被填满. 要定位和调整items大小,可以使用grid-cloumn和grid-row属性来设置. 1234.item1&#123; grid-cloumn-start: 1; grid-cloumn-end: 4;&#125; 上面的样式表示,我们希望item1占据从第一个网格线开始,到第四条网格线结束.换句话说它将独占一行.而剩下的items都推到了下一行. 这种形式也可以缩写为: 123456.item1&#123; grid-cloumn: 1/4;&#125;.item3&#123; grid-row: 2/4;&#125; 相关术语 网格容器(Grid):应用display:grid的元素,items的直接父级元素. 网格项(items): 网格容器的直接子元素,后代元素不是. 网格线(Grid-line):构成网格结构的分界线. 网格轨道(Grid-Track):两条相邻网格线之间的空间. 网格单元格(Grid-cell):两个相邻行与相邻列之间的空间. 网格区域(Grid-Area):四条网格线包围的总空间. 父元素 网格容器属性display将元素定义为网格容器,并为其建立新的网格式上下文. grid : 生成一个块级网格 inline-grid: 生成一个内联网格 subgrid: 嵌套的子网格. 在网格容器中使用float,clear,column,vertical-align不会产生任何效果. grid-template-cloumns/rows使用空格分割值列表,用来定义网格的行和列.可以是长度值和百分比,和自动分配(auto)或网格线名称. grid-template-areas指定Grid Area名称来定义网格模板.一个.号代表一个空的单元.你可以使用任意数量的.只要这些.之间没有空隙隔开就表示一个个的单元格. :由items的grid-area指定的区域名称 .(点号):代表一个空网格单元 none:不定义网格区域 12345678910111213141516.container&#123; display:grid; grid-template-rows:auto; grid-template-cloumns:50px 50px 50px 50px; grid-template-areas: \"header header header\" \"main main . sidebar\" \"footer footer footer footer\"&#125;.item-a&#123; grid-area:header;&#125;.item-b&#123; grid-area:main;&#125;... 当你命名网格区域后,该区域两端的网格线实际上是自动命名的,如果你的网格区域名字是foo,则起始行网格线和列网格线是foo-statrt,最后的网格线是foo-end.则意味着一个网格线可能有很多名称. grid-template用于定义grid-template-rows,grid-template-cloumns,和grid-template-areas的缩写. none:将所有的属性设置为初始值. subgrid:将rows和cloumns设置为subgrid,areas设置为初始值. /:将rows和cloumns设置为特定值,areas为none. grid-column-gap/grid-row-gap指定网格线的大小,可以把它想象为设置列/行之间间距的宽度.值为长度值. grid-gapgrid-column-gap/grid-row-gap的缩写语法 justify-items网格容器的水平对其方式,这些行为也可以通过items的justify-self属性设置: start 左侧对其 end 右侧对其 center 居中对齐 stretch 填满区域宽度 align-items网格容器的垂直对齐方式: start 顶部对齐 end 底部对齐 center 垂直居中 stretch 填满区域高度 justify-content/align-content有时,网格容器的内容小于整体容器的大小,可以设置内容在容器中的对齐方式. start 左对齐 end 右对齐 center 居中 stretch 填充 space-around 左右两边都有空间,空格之间距离相等 space-between 左右两边没有空间,空格之间距离相等 space-evenly 左右和每个空间距离相等 grid-auto-columns/grid-auto-rows指定自动生成隐式网格轨道,但定义行和列自动超出网格范围时,隐式网格轨道创建.值为长度,百分比等等. grid-auto-flow如果你有一些未明确放置的网格,自动放置算法会自动放置这些项. row: 依次填充每行 column:依次填充每列 dense: 出现较小的网格项时,尝试填充网格中较早的空缺.但它可能导致你的网格项出现混乱. 子元素 网格项items属性grid-column-start/end通过指定网格线来确定网格在容器中的列的起始位置 grid-row-start/end通过指定网格线来确定网格在容器中的行的起始位置 grid-column/grid-row上面两者的缩写 grid-area为网格项提供一个名词,一遍容器grid-template-areas属性创建模板进行引用.也可以作为grid-row和grid-cloumn的缩写. justify-self/align-selfitems的水平/垂直对其方式","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端 css","slug":"前端-css","permalink":"http://yoursite.com/tags/前端-css/"}]},{"title":"上海外滩随拍","slug":"上海外滩随拍","date":"2017-11-05T03:01:56.000Z","updated":"2017-12-26T07:09:39.000Z","comments":true,"path":"2017/11/05/上海外滩随拍/","link":"","permalink":"http://yoursite.com/2017/11/05/上海外滩随拍/","excerpt":"","text":"","categories":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/categories/旅行/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/tags/旅行/"}]},{"title":"浏览器数据持久化存储技术解析","slug":"浏览器数据持久化存储技术解析","date":"2017-11-04T07:09:36.000Z","updated":"2017-12-22T07:13:22.000Z","comments":true,"path":"2017/11/04/浏览器数据持久化存储技术解析/","link":"","permalink":"http://yoursite.com/2017/11/04/浏览器数据持久化存储技术解析/","excerpt":"","text":"打开Chrome浏览器的调试模式,Application就列举了现代浏览器的8种缓存机制:HTTP文件缓存,LocalStorage,SessionStorage,indexDB,webSQL,Cookie,CacheStorage,ApplicationCache. 从网址到网页展示 我们先看一个问题,从我们打开浏览器地址栏输入一个网址,到浏览器展示网页内容的这段时间,浏览器和服务端都发生了什么事情? 在接受到用户输入的网址后,浏览器会开启一个线程来处理这个请求,对用户输入的 URL 地址进行分析判断,如果是HTTP协议就按照HTTP方式来处理. 调用浏览器引擎中的对应方法,比如 WebView 中的 loadUrl 方法,分析并加载这个 URL 地址. 通过 DNS 解析获取该网站对应的 IP 地址,查询完成后连同浏览器的 Cookies,userAgent 等信息向网站目的地 IP 发送 Get 请求. 进行 HTTP 协议会话,浏览器客户端向 web 服务器发送报文. 进入网站后台上的 web 服务器处理请求, 如 Apache,Tomcat, Node.js服务器. 进入部署好的后端应用,如 PHP, java, Javascript, Python等后端程序,找到对应的请求处理逻辑,这期间可能会读取服务器缓存或查询数据库等. 服务器处理请求并返回响应报文,此时如果浏览器访问过该页面,缓存上有对应资源,会与服务器最后修改记录对比,一致则返回304,否则返回200与对应的内容. 浏览器开始下载 HTML 文档(响应报文状态码为200时) 或者从本地缓存读取文件内容(浏览器缓存有效或响应报文状态码为304时). 浏览器根据下载接收到的 HTML 文件解析结构建立 DOM文档树,并根据 HTML 中的标记请求下载指定的MIME文件(如CSS,JAvaScript脚本等),同时设置缓存等内容. 页面开始解析渲染DOM,CSS根据规则解析并结合DOM文档树进行网页内容布局和绘制渲染,JavaScript根据DOM API 操作DOM,并读取浏览器缓存,执行事件绑定等,页面整个展示过程完成. HTTP文件缓存HTTP文件缓存是基于HTTP协议的浏览器端文件级缓存机制,在文件重复请求的情况下,浏览器可以根据HTTP响应的协议头信息判断是从服务器端请求文件还是本地读取文件.以下是 文件缓存的过程. 1. 浏览器会先查询Cache-Control来判断内容是否过期,如果未过期,直接读取浏览器端缓存文件不发送HTTP请求,否则进入下一步. 2. 在浏览器端判断上次文件返回头中是否含有Etag信息,有则连同If-None-Match一起向服务器发生请求,服务端判断Etag未修改则返回状态304,修改则返回200,否则进入下一步. 3. 在浏览器端判断上次文件是否含有Last-Modified信息,有则一起向服务器发送请求,服务器判断是否失效,失效返回200,未失效返回304. 4. 如果Etag和Last-Modified都不存在,则向服务器请求内容. 在HTML中我们添加的meta标签中的Expires和Cache-Control,且一般Cache-Control设置的是秒,如果以上两个同时设置,只要Cache-Control的设置生效. 12&lt;meta http-equiv=\"Expires\" content=\"Mon, 20 Jul 2016 23:00:00 GMT\"/&gt;&lt;meta http-equiv=\"Cache-Control\" content=\"max-age=7200\"&gt; 同时服务端也要设置静态资源的缓存时间.我们可以结合Koa-static中间件设置实现. 12345const static = require('koa-static')const app = koa()app.use(static('./pages',&#123; maxage: 7200&#125;)) localStoragelocalStorage是HTML5的一种本地缓存方案,目前主要用于浏览器端保存体积较大的数据(如AJAX返回结果等).但它在各版本浏览器的长度限制不一.它的核心API只有4个. 1234localStorange.setItem(key,value)//设置存储记录localStorage.getItem(key)//获取储存记录localStorage.removeItem(key)//删除记录localStorage.clear()//清空 LocalStorage只支持简单数据类型的读取,为方便读取对象等格式内容,通常需要进行一层安全封装再引入使用. sessionStoragesessionStorage和LocalStorage功能类似,但sessionStorange在浏览器关闭时会自动清空.它的API和LocalStorage的API完全相同,但由于不能持久化数据存储,因此使用场景较少. cookiecookie是网站为了辨别用户身份或session追踪而存储在用户浏览器的数据,cookie一般会通过HTTP请求到服务器端.一条cookie主要由键,值,域,过期时间和大小组成,一般用于保存用户的网站认证信息.通常最大限制为4KB. cookie分为两种,sessionCookie和持久型Cookie.前者一般不设置过期时间,表示与浏览器会话期间保存在内存中,持久性Cookie会设置过期时间保存在本地硬盘中,知道过期或清空才失效. Cookie设置中有个HttpOnly参数,浏览器端通过doucument.cookie是读取不到HttpOnly类型的Cookie的,只能通过HTTP请求头发送到服务器进行读写操作.这样可以避免服务器端的Cookie记录被js修改,保证了服务端验证cookie的安全性. WebSQLwebSQL是浏览器端用于存储大量数据的缓存机制,以一个独立浏览器端数据存储规范的形式出现.它在HTML5前就已经出现,是单独的规范,它将数据以数据库二维表的形式存储在客户端,并且允许SQL语句的查询. webSQL的API主要包含上个核心方法:openDatabase(),transaction()和executeAql(). 1234567//openDatabase()打开已经存在的数据库,不存在就创建.他的五个参数是数据库名,版本号,描述,数据库大小,创建回调.let db = openDatabase('mydatabase','1.0','test',2*1024*1024)db.transaction(function(table)&#123; table.executeSql('INSERT INTO t1 (id,msg) VALUES (1,\"hello\")')&#125;)//transaction方法允许我们根据情况控制事物提交或回滚.//executeSql用于执行真实的SQL查询语句. IndexDBIndexDB也是客户端存储大量结构化数据并且能在这些数据上使用索引进行高性能检索的一套API.由于webSQL不是HTML5规范,一般推荐使用IndexDB进行大量数据存储,其基本实现和webSQL类似. 12345if(database)&#123; database.transaction(function(tx)&#123; tx.executeSql('INSERT INTO t1 (id,msg) VALUES (1,\"hello\")') &#125;)&#125; Application CacheApplication Cache是一种允许浏览器通过manifest配置文件在本地有选择性的存储js,css,图片等静态资源的缓存机制.当页面不是首次打开时,通过一个特定的manifest文件配置描述选择性新读取本地ApplicationCache的文件.所以它具有离线浏览,快速加载,服务器载荷小的优势.它的文件访问及更新机制如下: 1. 判断是否是第二次加载页面. 2. 是的话访问AppCache. 3. 检查manifest文件是否更新 4. 无更新从AppCache读取,有更新则重新拉取并更新AppCache. 使用方式 12345678&lt;html manifest=\"app.manifest\"&gt;//对应的描述文件如下CACHE MANIFEST#VERSION 1.0CACHE:xxx.cssXXX.jsXXX.png 浏览器也可以根据window.applicationCache来对其进行控制. 尽管ApplicationCache的实现很方便,但是已经开始被标准弃用,渐渐将会由ServiceWorkers来代替.总之,ApplicationCache仍是一个不成熟的本地缓存解决方案. cacheStoragecacheStorage是ServiceWorkers规范中定义的,用于保存每个ServiceWorker声明的Cache对象,是未来可代替ApplicationCache的离线方案. CacheStorage在浏览器端为window.caches,有open,match,has,delete,keys五个API. 12345caches.has();//检查如果包含cache对象,返回一个promisecaches.open();//打开一个cache对象,返回一个promsiecaches.delete();//删除一个cache对象,返回一个promisecaches.keys();//含有keys中字符串的任意一个,返回一个promisecaches.match();//匹配key中含有该字符的cache,返回一个promise Flash缓存Flash缓存主要基于网页端Flash,具有读写浏览器本地目录的功能,同时也可以向js提供调用的API,这样页面就可以通过js调用Flash读写本地指定的磁盘目录,达到本地数据缓存的目的. 本文摘自张成文编著&lt;&lt;现代前端技术解析&gt;&gt;,详情请点击张成文的Github","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端 数据储存","slug":"前端-数据储存","permalink":"http://yoursite.com/tags/前端-数据储存/"}]},{"title":"读<<美国种族简史>>","slug":"读-美国种族简史","date":"2017-09-06T08:58:07.000Z","updated":"2018-03-06T09:12:15.128Z","comments":true,"path":"2017/09/06/读-美国种族简史/","link":"","permalink":"http://yoursite.com/2017/09/06/读-美国种族简史/","excerpt":"","text":"爱尔兰人爱尔兰人是美国城市里第一批重要的”少数”种族之一.古代的爱尔兰曾经是个技艺和学术上有过某些建树的国家.在15世纪初期,英国国王对爱尔兰的有效控制仅仅局限在东海岸都柏林附近30英里长10英里宽的一条狭长地带.千百年来,爱尔兰的历史就是一部充满偶发的流血起义和遭到血腥镇压的历史.英国在战胜爱尔兰后,颁布了所谓的惩罚性法律,剥夺了爱尔兰人的许多基本权利.为了满足本民族的宗教,教育和政治需要,各种各样的爱尔兰人的秘密和底层的组织纷纷发展起来.由于不得不为自己提供是由政府提供的机构设施,爱尔兰人不但培养了高水平的组织本领,也锻炼了出去规避他们视为非法压迫他们的政府机构的本领. 爱尔兰的产权制度规定,佃农在土地上的任何额外收获,都属于土地所有者的,这就摧毁了佃农的积极性.这种制度在道德和经济上的影响,远远超过了这些法律的实施时间和地点造成的影响.爱尔兰人不但由于这些法律而蒙受了眼前的损失,而且由于积极性下降的社会环境而蒙受了更长远的损失.在后来的美国,学术界和民众都异口同声的说爱尔兰人懒惰和无能,当他们不会想到这是由他们长期受到的压迫中慢慢影响的. 19世纪30年代起,谷物歉收和灾荒加剧了爱尔兰的贫困情况.由于爱尔兰1/4的可耕地用于种植马铃薯,国际马铃薯的歉收对爱尔兰的影响是巨大的.但英国人并没有因为这个原因而放松对爱尔兰的压迫剥削.更多的爱尔兰人选择逃离,这时美国就成了爱尔兰人的第一选择.来美的第一批爱尔兰移民通过签订卖身契约,答应到美充当若干年苦工,以此抵偿未来雇主或轮船公司预先垫支的差旅费,做船抵达宾夕法尼亚中部,之后才然后慢慢涌进美国东北部. 德国人具有德国血统的美国人,仅次于英裔人.德国的军事传统为美国造就了若干名名垂青史的将帅,其中包括在一战和二战指挥美军打败德军的两名虎将,既潘兴和艾森豪威尔. 在还没有德国这个概念的时候,就有相当多的德意志人移居美国了.直到1871年,普鲁士,巴伐利亚等日耳曼小国才被俾斯麦统一起来.早起移民来美的德意志人大都掺杂在荷兰人的队伍中,于1620年定居在新阿姆斯特丹(后来改称纽约)的.”宾夕法尼亚荷兰人”(Pennsylvania Dutch)由此发端,而此处的”荷兰人”(Dutch)这个词,实际上由美国人的发音错误造成的,把”德意志人”(Deutsch)读成了荷兰人(Dutch). 1776年,美国人分裂为英国托利党的支持者和拥护独立的革命派,美籍德意志人则分裂为和平主义者和革命分子. 冯.施图本将军就是从他的祖国赶来,目的就是参加美国独立战争,华盛顿困守瓦力福基时,施图本将军曾为之出谋划策,作为美国军队的教官,他成功训练出一支足以打败英国职业化军队的铁骑. 不管在农村还是城市,德国人集居的方式使他们世代保留着自己的语言和文化.这一点时常表现在民居和文化上的孤立.”德国人不大于美国老百姓交往”,他们彼此从远处观察对方,”都带着一种真诚的好奇心,时常夹杂着对彼此的蔑视”.除了语言,其他德意志文化的许多特点也被带到了美国.和圣诞树一样,牛肉香肠,汉堡包和啤酒已成为美国生活方式的必备之物.在19世纪的辛辛那提,沿街叫卖的德裔食品摊贩,用把牛肉熏制的香肠往长条面包中一夹,就成了后来的热狗.圣路易斯及其周围地区聚集的大批德国人,为另一家德国酿酒厂的创办提供了市场,他的老板是安海斯-步希,生产的是百威啤酒.德国移民推动的最重大的社会变化之一,就是在美国推广了各式各样的天真活泼而且适合整个家庭在公开场合开展的娱乐活动.音乐演奏,野餐,跳舞,打牌,游泳等美国人闲暇时爱从事的文艺活动都是德国移民在19世纪带过来并推广出来的.德国人还组织了军乐团,交响乐团和各式各样的合唱团. 德国人越来越被美国人接受,但第一次世界大战爆发时,席卷全美的反德情绪却粗暴的使这些发生了变化.美国人的反德情绪不仅仅局限在德国本身,而且殃及日耳曼文化和美籍德国人.20世纪早期,美籍德国人慢慢被美国社会同化,其速度后来更有所加快.随着希特勒和纳粹与20世纪30年代在德国的崛起,德国掀起了向美国移民的新高潮,包括世界上数一数二的艺术家,科学家,其中最杰出的就是爱因斯坦.二战虽然也掀起了反德情绪,但其程度远不及一战期间,这次指挥美军在欧洲登陆并打败德国的就是一位具有德意志血统的将军”艾森豪威尔”. 犹太人犹太人不是来自某一国家或属于某一文化,而是来自许多国家并分属不同的文化.尽管犹太人因寄居的国家不同而产生了文化上的割裂,甚至在宗教理论和实践上也存在分歧.但是,犹太人不仅供奉古代以色列的统一始祖,分享宗教信仰和历史传统的共同内核,而且作为少数民族,不管寄居何处,都曾有过不同程度的长期遭到异族敌视的悲惨经历. 公元70年,当罗马帝国的军队占领巴勒斯坦时,古犹太人就从自己的故土被驱逐了出来,从此开始流落异国他乡.基督教在整个欧洲取代了多神信仰之后,犹太人成为了全欧洲大陆唯一不信仰基督教的民族,所到之处皆为”局外人”.这使犹太人在基督教狂热时期(比如十字军东侵)或宗教大恐怖时期出于自身难保的地位.他们在宗教上持有不同见解,而且不管他们到哪都是外乡人,他们有自己的文化,讲不同的语言,穿不同的衣服,而且一般都在单独的村庄居住,他们是被贴了标签的人,周围那些无知且迷信的居民无论陷入什么样的激情或恐惧,一遇到风吹草动,便自然而然的把犹太人当成攻击的靶子. 犹太人通常居住在一起,集聚区的生活方式排除了欧洲犹太人从事农业的可能性.他们在到达纽约及美国其他城市之前的好几百年,就已经都市化了.犹太人在他们最受孤立的欧洲地区,基本上没有受到文艺复兴后现代思想潮流的熏陶,所以他们的文化依然是古老的乡土文化.欧洲犹太人的典型特征之一就是对知识的尊重和景仰.这里指的主要是宗教知识,有关犹太教法典的知识,以及对其意义和内涵的周密而细致的分析. 第一批抵达美洲殖民地的犹太人是所谓的赛法迪犹太人,他们有在西班牙及葡萄牙生活的经历,哥伦布发现新大陆所引发了一系列时间,这也包括赛法迪犹太人到达美洲.之后,德国犹太人也来了,但德国犹太人不聚积在某一处,而是散落在美国各地,有些人在宾夕法尼亚的农场落户,有的则在中西部定居,有的则跟着大篷车向西部进发,这批德国犹太人中有个货郎,名叫李维.斯特劳斯,李维斯牛仔裤就是以他的名字命名的. 13世纪和14世纪,波兰王室鼓励犹太人在其国土上定居,并颁发保护他们的特许状.犹太人成了欧洲地区先进技术和知识传入波兰的载体.几个世纪之后,犹太工匠和商人的家业逐渐壮大起来,这招致周围贫穷而不识字的波兰农民及其教会头目的憎恶和仇恨.犹太人充当政府的税务官或给地主收租,这更使他们成为当众民众的眼中钉.随着政治气候的变化,犹太人时而受到当局的保护,时而遭受当局的迫害.于是,但俄国人从波兰手里夺取的地方,把犹太人禁锢在他们的居住区.叶卡捷琳娜二世之后的40年间,离俄赴美的人中有75%是犹太人,而到美的犹太人中也正好有75%的人来自俄国. 东欧犹太人涌入美国后,与当地的犹太人格格不入.德国犹太人对他们的生活之寒酸感到不可思议,不仅如此,受教育程度也很低,举止也显得很粗俗.德国犹太人还造出了一个词”老K”来称呼东欧的犹太人.但这些都是有原因的,德国犹太人一直在美国的安全环境下飞黄腾达,从来也没有体验过东欧犹太人遭受的那些令人发指的欺凌,不知个中滋味,而东欧犹太人对那些欺凌却记忆犹新,导致他们缺乏自信心和气度,不敢于陌生人搭讪,再加上那副胆小怕事,逆来顺受的模样,自然受到外人的欺凌和捉弄的对象.而且外部有东欧犹太人母亲保护子女太过分的说法,实际上这些犹太妇女当初在东欧时,家里的小孩一旦离开家门,父母就可能再也见不到了.如果人们一开始就知道这些背景就不会对他们有这么多的偏见. 辛苦的工作和重视教育的犹太人很快就有了积蓄,随着经济地位的上升,犹太人也向其他居住地区扩散开来.犹太裔电影业在美国很有地位,米高梅(MGM)电影制片厂的名字缩写,三个字母有两个都是取自犹太人Goldwyn和Mayer,其他的电影业巨子还有华纳兄弟和威廉福克斯.纽约历史上最出名的两家报纸也是由犹太人创办的,&lt;&lt;纽约时报&gt;&gt;和&lt;&lt;犹太前进报&gt;&gt;,有一半犹太血统的约瑟夫.普林策创办了&lt;&lt;纽约世界报&gt;&gt;并设立了普利策奖.在科学和医学界知名的犹太人当属爱因斯坦,罗伯特奥本海默和约纳斯沙克这样的巨擘了.从某种意义上来说,犹太人是美国成功故事的典型代表人物,在逆境中从一无所有到腰缠万贯. 意大利人今天的美籍意大利人,多数是从意大利南部移居美国的那部分人的后裔.意大利半岛的悠久历史可以追溯到基督之前的罗马共和国和罗马帝国,然而作为一个国家,意大利又是年轻的,它仅始于1861年.这一年意大利各省在历经多个世纪的分裂后首次统一在一个政府管辖之下.在文化上,意大利各省甚至于每个小镇,都觉得自身拥有自成一体的独特文化,即便距离很接近,语言和文化也相距甚远.在地理上,该国被亚平宁山脉一分为二,形成了许许多多的山谷,西西里岛和撒丁岛是其两大岛屿. 在意大利南部,可耕地少且零散,致使许多村落相互阻隔,反过来又加剧了他们在语言和其他文化的差距.另外,意大利南部的气候和地形造成了该地区的贫困,气温虽然适中,但降雨量偏低且只集中在少数几个月份,作物成长季节却逢干旱,雨季到来时又是倾盆而下,造成水土流失.致使沟壑,池塘积满死水,孳生疟疾.因为土质最肥沃的低地同时又是疟疾最容易传播的地方.除了农业,工业也先天不足,高山和丘陵占据该国国土面积的75%,只有一半的国土属可耕地,可耕地又大多集中在北部.历史加重了大自然造成的问题,意大利南部长期是历代帝国和王朝的战场,罗马帝国以来,战争在南部反复上演.此外,意大利文艺复兴的硕果是意大利北部的产物,对南部影响很小. 尽管就历史的创伤和极度的贫困而言,意大利人和爱尔兰人是难兄难弟,但在某些方面又不一样.爱尔兰人所受到的压迫,来自于其持有不同宗教信仰的异族,所以在回应时具有强烈的全民族意识,而意大利农民则长期受到宗教信仰相同的本种族人的压迫,这使他们不能团结在一起,而是完全仰仗直系家庭的其他成员,意大利人最信得过的人很少超出近亲的范围,南部意大利人的反击方式既种族间的报复和黑手党也都是以对方的家庭为目的的.值得一提的,在南部意大利人眼中,教育是认为对生活方式构成威胁的.他们认为受教育不能提供向上的社会流动,在那种等级森严的社会里,恐怕这不无道理.教育被视为对家庭神圣性的一种侵犯,是把儿童作为一个孤立的个体抽离出来,教给他们一种相左的一套价值体系,对于穷困潦倒的平民百姓来说,失去一个出外挣钱的劳动力实在是一种不堪忍受的损失. 早期来美的意大利人,近90%都是成年男性,小孩所占的比例远远低于其他国家的移民,这表明,他们来美一开始就是短暂的或是试探性的,返回故土既非失败亦非失望,不少回流的人都在美国挣了一笔可观的钱财.美籍意大利人的居住模式反映出他们在意大利时的地区主义格局,他们往往来自同一个地区的人一起集居在一处,社会关系也局限在某一个范围,这阻碍了全体意大利移民相互间缺乏强烈的认同感,又使他们不敢于其他种族发生摩擦.他们能和他们和谐共处,但并不代表他们能被别人同化,比如他们的择偶对象几乎从不超出本族的范围. 从社会关系来讲,在一个崭新的经济和社会环境中,意大利移民易遭不幸,出于自卫的目的,他们创建了互助会,这算是现代意义上的组织,即一种由陌生人组成了社会组织结构,该结构自身所确定的宗旨使这些陌生人聚集到了一起,通用汽车公司,红十字会,政治运动,公会或是体协,都是这类组织.职业犯罪活动在意大利南部是一门高度发达的艺术,特别是黑手党的老巢西西里,大多数意大利移民并不参与这类活动,因为他们自身就是黑手党的主要受害者.意大利和其他移民一样,较高的犯罪率都发生在第二代移民中. 今天的美籍意大利人在收入,教育智商得分上都与其他美国人大体相仿.值得一提的是,意大利人的崛起基本上并未借助人们通常视为必经之路的教育或是教育相关的职业.美籍意大利人不仅苦干,而且强调自立.他们拒绝接受政府的法定救济,甚至在收入低微时也保持良好的信誉,不热衷于政治和投机.但也是这样,造成了他们与黑人之间关系的恶化.早期意大利人对黑人表现出的敌意较少.黑人领袖所强调的种族进步之路,恰是意大利人所排斥的道路,他们认为靠政府救济和特殊照顾违背他们的价值观念.这两个种族的生活作风也相互冲突,双方都认为对方的言语和肢体语言是故意的侮辱,实际上在两种不同的文化里都有自己的内涵.这使他们与黑人的摩擦越来越多,而与华人则不一样,与华人虽然肤色不同,但价值观念和生活作风与意大利人并无相悖之处.意大利人和中国人相处的很好,远胜于他们和爱尔兰人的关系.总而言之,笼统的用”种族主义”这个字眼来解释,无法找到种族间敌对关系的缘由. 事实证明,美国确实是从意大利来到这里的那些人的机会之邦.但是,把机会变成现实也要付出艰苦的劳动和努力,并具备持之以恒的毅力.那些早起从贫困的意大利南部来的移民用他们的双手获得了新生. 华人中国人常被称为亚洲的犹太人,他们在许多不同的国度里过着自己独立的文化和社会生活.中国人的技能和组织本领使他们称为许多贫穷国家的有价值的外来户,而家境富足又使他们称为政治上受打击的对象.所以这些国家的政府对和华人的态度一直是爱憎兼具的.时至1966年,所罗门群岛政府还在是否要驱逐所有华人的问题进行过辩论.在印度尼西亚和墨西哥都曾发生过对华人的大屠杀. 中国曾在很长的一段时间内一直都是世界上经济,技术和社会组织最先进的国家,时至16世纪,中国人仍拥有世界上最高的生活水平.海华华人的出现和这个伟大文明的衰落是相关的,两者都是自明朝开始.”二战”前移居美国的华人,绝大部分都来自中国南方的一个省份,即广东省,且集中在广东省的台山,他们说台山的方言,但与中国通用的语言相距甚远.”二战”后移居美国的人大都说普通话,这和原有的在美华人产生了隔阂.中国人在极为动荡的悠久历史中所留下的遗产,就是忠于本国本土的家族,将其视为个人唯一可以依靠的归宿.随着华人来到美国的中国文化的另一特点就是对知识的尊重,毕竟中国在隋唐就开创了科举制. 第一批华人移民是作为合同工来美的,他们在农业,铁路修建和其他繁重的体力劳动方面很能吃苦.但他们来美只是尝试性的,只是想赚一笔钱就回国.但美国人对中国移民的态度是苛刻的,甚至是粗暴的.华人既不是白人,又不是基督徒,无论是文化上还是生理上都只能看做不能被同化的种族,美国人视他们为竞争对手,因为他们吃苦耐劳且工资很低.所以华人在美常常会受到其他种族的迫害.1882年的&lt;&lt;排华法案&gt;&gt;打打削减了华人移民的数量,其他新的法律先是禁止在美华人成为美国公民,接着又把公民身份当作从事多项职业的先决条件.华人赴美的大门几乎被彻底关闭.由于就业无门,只能自谋出路,在几十年间,他们的主要职业就是洗衣店.中国餐馆是另一个就业渠道,这些餐馆大都坐落在华人社区或唐人街,竭力让人感到他们不是在于白人竞争.面对无处不在的歧视,中国人的反应是退避三舍,尽量不惹人注目.这和身处隔离区的欧洲犹太人很相似.唐人街发展了自己的社会组织,并推举出首领来处理内部事务,除非万不得已不会求助于当地的美国机构. 早期中国移民的最大悲剧就是如此重视家庭的民族被剥夺了在美组建家庭的可能性.1882年美国单方面压低中国人移民的数量,结果造成华人两性比例严重失调.1860年,在美华人的男女比例约为20 : 1,到1890年上升为27 : 1,很明显许多早期抵美的华人无法组建家庭及繁衍后代,由于贫困又不能返回中国,数以千计的华人孤独的度过了他们的一生,同时也造成了同时期华人的自杀率是全美平均数的三倍. 华人领袖主持唐人街的工作,他们用现今唐人街典型的宝塔形建筑来装饰自己的地带,以至于唐人街旅游业兴旺发达.华人的节庆和游行活动也受到警察的保护,并成为招揽大批观光客的市政项目.由于华人集中居住在一个不发生问题的地区,或至少其问题很难引起外界注意的社区,以至于华人被视为一个安静而有有秩序的种族. 日本人日裔美国人的历史，大体上受到美国人对华人的所有态度，偏见及歧视的影响，华人到达美国比日本人要早30年左右。日本向美国移民始于19世纪后期，德川家族的军阀统治于1868年被推翻，取而代之的是一整套新式的价值观念和民族雄心。但日本的孤立于1854年被强行结束，美国的佩利将军率领美国海军进驻东京湾，诱使日本签订了条约，使日本有机会接触西方的思想和技术，为日本100年后的政治发展确定了发展方向。日本对西方感情很复杂，既憎恶其傲慢，又欣赏其赖以称霸的成就。 日本明治维新给了农民以行动和择业的自由，但也使地主在有利可图的情况下可以随时把佃农从土地上赶走。旧的武士阶层被打破，随着他们在经济和社会上的地位日益没落，那些为武士阶层服务的商人和手艺人也走了下坡路。因此许多人去海外寻找机会，但日本对海外日侨十分关心，国家有能力和威望为其撑腰，这使日本有别于当时的中国，中国当时太弱，自身也难免不被瓜分，根本谈不上为海外华侨讲话。日本政府事实上将其移民看做暂时性的，而美国因反对华人而制定的《排华法案》也使得其他亚洲人无法申请美国国籍。许多在美的日本人把钱汇到家乡，对日本很多城市的发展起到了很重要的作用。比如广岛这样的新兴工业中心才成为“二战”中的一个首要军事目标。 由于日本在19世纪和20世纪之交成为世界强国之一，它在1895年甲午海战战胜了中国，1905年又战胜了俄国，所以美国不能向以前对中国人那样以突然，单方面的终止向美国的移民，美日两国于1908年达成一个保全颜面协议就，史称“君子协议”，该协议规定，日本严格限制赴美的人数，而美方允许让在美的日裔家属与亲人团聚。还有一个很特别的地方，与其他国家不同，日本没有把它的那些精疲力尽，穷困潦倒的劳苦大众送到美国，在移民这一点，日本是严格挑选优秀公民，虽然他们并不是来自富裕家庭。 1941年12月7日，日本向停泊在夏威夷珍珠港的美国舰队发动了一次大规模袭击。这使美国遭受到有史以来最大的惨败。更惊人的是偷袭发生时，日本外交官正在华盛顿扮演和平使者的角色，还有就是日本同时在西太平洋发起攻势。美国人对日本的气愤和恐惧一股脑全发泄到了美籍日本人身上，辱骂和施暴行为时有发生。1942年罗斯福总统签署一项行政命令，授权军方可以把“有关人等”运送到“拘留营”，这个政策得到了广泛的支持。大规模的拘留使得在美日本人匆忙的把房子和其他产业在短时间卖掉，经济收到了很大的损失。但总体来讲，日裔美国人接受了拘留的严酷事实，并不得已退而求其次。尽力改善自己的境遇。 1943年美国陆军开始征召被划为“敌侨”而无资格参军的在美第二代日本人去服役。共有30多万日裔美国人参加了“二战”，日裔兵组成了442团成了“二战”获得荣誉最多的一支劲旅。战后随着日裔美国人的经济地位上升，再之美国种族主义普遍退潮，美籍日本人正在变得美国化。 黑人美国黑人是在违反其自身意志的情况下被强行带到美国的唯一种族。非洲的面积比欧洲大很多，但其海岸线却没有欧洲的长，且天然港口并不多。非洲的河流受到地形和四季变化的制约，只能断断续续的通航，茂密的原始森林和无边的沙漠使得大陆内部的交通和交流很是困难。造成了该大陆的人们各居一隅，操着800多种语言分成无数的部落，他们无法在收到攻击后有效和团结起来，为外人将他们大批虏获提供了机会。且奴隶制早就存在于非洲各部落之间，其历史可以追溯到古希腊和古罗马时期。把黑人当作商品出售，是公元8世纪阿拉伯人入侵北非之后开始的。当非洲人被阿拉伯的奴隶贩子带到西班牙时，欧洲的奴隶制已经开始销声匿迹了。于是西班牙和葡萄牙冒险来到撒哈拉以南的非洲地区，抓捕黑人当作自己的奴隶。当西班牙开始在西半球开辟殖民地时，有大批奴隶被运送到那里当苦力。哥伦布发现美洲大陆后，这种情况更严重了。任何一种奴隶制面临的关键问题就是如何防止奴隶逃跑，在美国南北战争爆发的南方，防止奴隶逃跑的办法不是筑起篱笆或设置岗哨，而是通过使奴隶处于无知，依附和恐惧的状态来实现的。1793年轧花机的发明，使60%的美国奴隶从事棉花种植工作，奴隶日趋集中到美国南部那些土质和气候适宜种植棉花的地带。而美国北方奴隶就很少，因为北方的气候并不适合种植大田作物。美国南北战争不仅是美国黑人历史上的一个转折点，而且堪称奴隶制度的最后一次大流血，对黑人来说，自由既解救了他们，又是他们陷入了一种很被动的境地。因为这些获得自由的奴隶文化水平并不高，只能从事和以前一样的工作，而且他们并不会安顿下来开始干活，只是继续依靠政府发放的救济生活，某些州的地方政府不得已颁布法令，强制黑人进行文化教育，但他们并不能和其他人种一起学习，只是创办专收黑人儿童的学校。虽然黑人在正规教育方面的进步及艰辛有缓慢，但他们发展了新型的文化风格。尤其是音乐和体育方面表现非常出色。","categories":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/categories/读书/"}],"tags":[{"name":"历史 美国","slug":"历史-美国","permalink":"http://yoursite.com/tags/历史-美国/"}]},{"title":"vue项目中的小总结","slug":"vue项目中的小总结","date":"2017-05-21T06:45:23.000Z","updated":"2017-11-22T08:06:23.000Z","comments":true,"path":"2017/05/21/vue项目中的小总结/","link":"","permalink":"http://yoursite.com/2017/05/21/vue项目中的小总结/","excerpt":"","text":"单文件组件中data必须是一个函数,然后返回一个对象.避免多个组件数据混乱.1234567 export default &#123; data()&#123; return &#123; a: \"123\", &#125; &#125;&#125; 列表循环时,尽量使用key,避免元素复用1&lt;div v-for=\"(item,index) in array\" :key=\"index\"&gt;&lt;/div&gt; 在vue中使用less安装less及less-loader依赖 1npm install less less-loader --save-dev 修改webpack配置文件 在单文件组件中使用 1&lt;style lang=\"less\" scoped&gt; $nextTick的用法异步更新队列:Vue在观察到数据变化时不会直接更新Dom,而是开启一个队列,并缓冲在同一事件循环中发生的所有数据变化,然后去除重复数据,避免重复计算和dom操作,然后在下一个事件循环tick中,刷新队列并执行实际(已去重)的工作.$nextTick就是用来知道什么时候dom更新完成的. 123&lt;div id=\"div\" v-if=\"isShow\"&gt;这是一段文本&lt;/div&gt;&lt;button @click=\"getText\"&gt;获取div内容&lt;/button&gt;&lt;!-- 当我们点击按钮时,获取div的文本 --&gt; 1234567getText: function()&#123; this.isShow = true; this.$nextTick(function()&#123; var text = document.getElementById('div').innerText; console.log(text); &#125;)&#125; webpack打包上传服务器后项目图片路径的问题1. 解决方式一: 修改config文件中index.js里assetsPublicPath为&apos;./&apos;, 然后修改webpack.base.conf.js里的url-loader的limit,根据文件大小相应的修改. 但是修改后打包的文件比较大,影响页面加载. 2. 解决方式二: 修改config文件中index.js里assetsPublicPath为&apos;./&apos;,然后修改源代码中css的图片路径为绝对路径, 静态资源由之前的src下的assets文件转移到src同级的static文件下新建一个img文件. 如果该项目有两级以上的域名,就在绝对路径前加上该子域名,如&apos;/XXX/static/img/a.png&apos; scoped下尽量不要使用标签选择器scoped下尽量不要使用标签选择器,会影响页面性能. vue组件添加原生事件vue组件添加原生事件,必须在事件后添加.native修饰符,否则事件不会生效. 在vue中使用TypeScript在vue中使用TypeScript 1. 安装依赖 12npm i vue-class-component vue-property-decorator --savenpm i ts-loader typescript tslint tslint-loader tslint-config-standard --save-dev 2. 配置webpack - 找到&apos;./build/webpack.base.conf.js&apos;添加 1resolve: &#123;extensions: ['.js', '.vue', '.json', '.ts'],&#125; - 找到module.rules,添加对.ts的解析 1234567891011121314&#123; test: /\\.ts$/, exclude: /node_modules/, enforce: 'pre', loader: 'tslint-loader'&#125;,&#123; test: /\\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: &#123; appendTsSuffixTo: [/\\.vue$/], &#125;&#125;, - 添加根路径tsconfig.json文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; // 编译选项 \"compilerOptions\": &#123; // 输出目录 \"outDir\": \"./output\", // 是否包含可以用于 debug 的 sourceMap \"sourceMap\": true, // 以严格模式解析 \"strict\": true, // 采用的模块系统 \"module\": \"esnext\", // 如何处理模块 \"moduleResolution\": \"node\", // 编译输出目标 ES 版本 \"target\": \"es5\", // 允许从没有设置默认导出的模块中默认导入 \"allowSyntheticDefaultImports\": true, // 将每个文件作为单独的模块 \"isolatedModules\": false, // 启用装饰器 \"experimentalDecorators\": true, // 启用设计类型元数据（用于反射） \"emitDecoratorMetadata\": true, // 在表达式和声明上有隐含的any类型时报错 \"noImplicitAny\": false, // 不是函数的所有返回路径都有返回值时报错。 \"noImplicitReturns\": true, // 从 tslib 导入外部帮助库: 比如__extends，__rest等 \"importHelpers\": true, // 编译过程中打印文件名 \"listFiles\": true, // 移除注释 \"removeComments\": true, \"suppressImplicitAnyIndexErrors\": true, // 允许编译javascript文件 \"allowJs\": true, // 解析非相对模块名的基准目录 \"baseUrl\": \"./\", // 指定特殊模块的路径 \"paths\": &#123; \"jquery\": [ \"node_modules/jquery/dist/jquery\" ] &#125;, // 编译过程中需要引入的库文件的列表 \"lib\": [ \"dom\", \"es2015\", \"es2015.promise\" ] &#125;&#125; - 添加根路径tslint.json文件 123456&#123; \"extends\": \"tslint-config-standard\", \"globals\": &#123; \"require\": true &#125;&#125; - 在src下创建vue-shim.d.ts 1234declare module \"*.vue\" &#123; import Vue from \"vue\"; export default Vue;&#125; 之后再代码中引入.vue文件时需要加上.vue后缀,因为ts默认只识别*.ts文件 - 改造APP.vue文件 12345678&lt;script lang=\"ts\"&gt; import Vue from 'vue' import Component from 'vue-class-component' @Component(&#123;&#125;) export default class App extends Vue &#123; &#125;&lt;/script&gt; - 修改main.js为main.ts,并修改&apos;./build/webpack.base.conf.js&apos;中的entry为 `{app: &apos;./src/main.ts&apos;}`","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"vue 前端","slug":"vue-前端","permalink":"http://yoursite.com/tags/vue-前端/"}]},{"title":"CSS常见布局实现","slug":"CSS常见布局实现","date":"2017-04-03T07:26:03.000Z","updated":"2018-04-04T07:33:56.000Z","comments":true,"path":"2017/04/03/CSS常见布局实现/","link":"","permalink":"http://yoursite.com/2017/04/03/CSS常见布局实现/","excerpt":"","text":"水平居中 文本/行内/行内块 123parent&#123; text-align:center;&#125; 单个块级元素 1234.son&#123; margin: 0 auto; &#125;/*左右设置margin为auto将会均分剩余空间.上下设置margin设置了auto,其计算值为0.*/ 多个块级元素 123456#parent&#123; text-align:center &#125;.son&#123; display: inline-block &#125; 绝对定位实现居中 123456789#parent&#123; position: relative &#125;.son&#123; position: absolute; left: 50%;/*父元素的50%;*/ transform: translateX(-50%);/*自身的-50%;如果兼容性不好用margin: -XX;*/ /*子绝父相,通过left或right结合margin或translate达到居中.*/&#125; 任意个元素(flex) 12345678#parent&#123; display: flex; justify-content: center;&#125;.son&#123; flex:1;&#125; 垂直居中 单行文本/行内/行内块 1234#parent&#123; height: 100px; line-height: 100px;&#125; 多行文本/行内/行内块 1234#parent&#123; height: 100px; line-height: 20px;//高度除以文本的行数&#125; 图片 12345678#parent&#123; height: 100px; line-height: 100px; font-size:0;//清除幽灵空白节点的BUG&#125;.son&#123; vertical-align: middle;&#125; 单个块级元素 123456789101112131415161718192021222324252627282930313233343536373839//方案一: table-cell#parent&#123; display: table-cell; vertical-align: middle; //缺点是设置table-cell的元素,宽高设置百分比无效,需要给他的父元素为table才生效. //设置table-cell不感知margin,设置float或position会对布局造成破坏.&#125;//方案二: 绝对定位配合margin或translate#parent&#123; position: relative;&#125;.son&#123; position: absolute; top: 50%; transform: translateY(-50%); //或margin-top: -XXX;&#125;//方案三: margin: auto 0;#parent&#123; position: retive; height:100px;&#125;.son&#123; height: 50px; position:absolute; top: 0; bottom: 0; margin: auto 0; //原理是当top和bottom为0时,margin-top&amp;bottom会无限延伸沾满空间且平分.&#125;//方案四: flex#parent&#123; display: flex; align-items: center; //或为son设置align-self: center;&#125; 任意个元素(flex) 12345#parent&#123; display: flex; align-items: center; //或为son设置align-self: center;&#125; 水平垂直居中 行内/行内块/图片 12345#parent&#123; display: flex; justify-content: center; align-items: center;&#125; Table-cell 12345678#parent&#123; display: table-cell; vertical-align: middle; /*text-align: center;*/ /*如果子元素是行内元素则添加*/&#125;.son&#123; margin: 0 auto;/*如果是块级元素则添加*/&#125; 绝对定位 12345678910#parent&#123; position: retive;&#125;.son&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); /*如果考虑兼容性问题的话可以使用margin*/&#125; 绝对居中 1234567891011121314#parent&#123; position: retive;&#125;.son&#123; position: absolute; top: 0; bottom: 0; left: 0; right:0; margin: auto; /* 当top&amp;bottom为0,margin-top&amp;bottom为无限延伸沾满空间并平分.left与right同上. */&#125; 两列布局左定宽右自适应 float+margin 123456789.left&#123; width:100px; height:100px; float:left;&#125;.right&#123; height:100px; margin-left:100px;&#125; float+overflow 123456789.left&#123; width:100px; height:100px; float:left;&#125;.right&#123; height:100px; overflow: hidden;&#125; table的单元格自动分配 123456789101112#parent&#123; display:table;&#125;.left&#123; width:100px; height:100px; display: table-cell;&#125;.right&#123; height:100px; display:table-cell;&#125; 绝对定位 1234567891011121314151617#parent&#123; position: relative;&#125;.left&#123; width:100px; height:100px; position:absolute; top:0; left:0;&#125;.right&#123; height:100px; position:absolute; top:0; left:100px; right:0;&#125; 使用flex实现自适应. 1234567891011#parent&#123; display:flex;&#125;.left&#123; width:100px; height:100px;&#125;.right&#123; height:100px; flex:1;/*均分父元素剩余空间*/&#125; 使用grid 1234#parent&#123; display: grid; grid-template-columns: 100px auto;/*auto换成1fr也可以*/&#125; 一列不定,一列自适应 使用float+overflow实现 1234567891011#parent&#123; height:100px;&#125;.left&#123; float: left;/*只设置浮动,不设宽度*/ height:100px;&#125;.right&#123; overflow: hidden; height:100px;&#125; flex实现 1234567891011#parent&#123; display: flex; height: 100px;&#125;.left&#123; height:100px;&#125;.right&#123; height:100px; flex:1;&#125; 使用Grid实现 12345678910#parent&#123; display: grid; grid-template-columns: auto 1fr;&#125;.left&#123; height: 100px;&#125;.right&#123; height: 100px;&#125; 三列布局两列定宽,一列自适应1234567891011&lt;div id=\"parent\"&gt; &lt;div class=\"left\"&gt; 左列定宽 &lt;/div&gt; &lt;div class=\"center\"&gt; 中间定宽 &lt;/div&gt; &lt;div class=\"right\"&gt; 右侧自适应 &lt;/div&gt;&lt;/div&gt; 用float+margin实现 1234567891011121314151617#parent&#123; min-width:310px;/*防止宽度过小,子元素换行*/&#125;.left&#123; width:100px; height:100px; float:left;&#125;.center&#123; width:200px; height:100px; float:left;&#125;.right&#123; margin-left:300px; height:100px;&#125; float+overflow实现 12345/*其余样式与以上相同*/.right&#123; overflow: hidden; height:100px;&#125; table-cell的单元格自动分配 1234567891011121314151617#parent&#123; height:100px; width:100%; display:table; border-spacing:10px;/*关键,设置间距*/&#125;.left&#123; display: table-cell; width:100px;&#125;.center&#123; display: table-cell; width:100px;&#125;.right&#123; display: table-cell;&#125; 使用flex实现 12345678910111213#parent&#123; height:100px; display:flex;&#125;.left&#123; width:100px;&#125;.center&#123; width:200px;&#125;.right&#123; flex:1;/*均分父元素剩余空间.*/&#125; 使用Grid实现 12345#parent&#123; height: 100px; display: grid; grid-template-columns: 100px 200px 1fr;/*1fr或auto都可以*/&#125; ####双飞翼布局(两侧定宽,中间自适应) 1234567891011&lt;div id=\"parent\"&gt; &lt;div id=\"center\"&gt; &lt;/div&gt; &lt;div id=\"left\"&gt; &lt;/div&gt; &lt;div id=\"right\"&gt; &lt;/div&gt; &lt;/div&gt; 12345678910111213141516171819#parent&#123; height:100px;&#125;#left&#123; float:left; width:100px; height:100px; margin-left:-100%;/*上移一行*/&#125;#center&#123; height:100px; float:left; width:100%;&#125;#right&#123; height:100px; float:left; margin-left: -100px;/*向上移动自身的距离*/&#125; 圣杯布局方法 定位方式 12345678910111213141516171819#parent&#123; position:relative;&#125;#left&#123; width:100px; position:absolute; top:0; left:0;&#125;#center&#123; margin-left:100px; margin-right:100px;&#125;#right&#123; width:100px; position: absolute; right:0; top:0;&#125; flex方式 123456789101112#parent&#123; display: flex;&#125;#left&#123; width:100px;&#125;#center&#123; flex:1;&#125;#right&#123; width:100px;&#125; Grid方式 1234#parent&#123; display: grid; grid-template-columns: 100px 1fr 100px;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"布局 css","slug":"布局-css","permalink":"http://yoursite.com/tags/布局-css/"}]},{"title":"学习React","slug":"学习React","date":"2017-01-14T03:12:17.000Z","updated":"2017-12-14T03:35:54.000Z","comments":true,"path":"2017/01/14/学习React/","link":"","permalink":"http://yoursite.com/2017/01/14/学习React/","excerpt":"","text":"安装​ creat-react-app 脚手架安装 ​ npm install -g creat-react-app ​ 初始化安装 ​ creat-react-app hello-react ​ 启动 ​ cd hello-react ​ npm start 使用jsx12345678910111213141516import React,&#123;Component&#125; from 'react'import ReactDOM from 'react-dom'import './index.css'class Header extends Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;hello React&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;header/&gt;, document.getElementById(\"root\")) jsx在编译时会变成相应的js对象描述. react-dom负责把这个js对象描述变成dom元素并渲染. Reader方法我们在编写组件时,需要继承react的Component,一个组件类必须实现一个render方法,这个方法返回一个jsx对象,需要注意的是,必须用一个外层的元素把所有内容包裹起来,而不能是几个元素. 表达式插入在jsx中可以插入js表达式,表达式返回的结果会渲染在页面上,表达式用{}包裹,如果包裹的是一个对象,在对象的外面也要加上{}. {}内可以放任何js的代码.不仅仅可以放在标签内部,也可以放在标签属性上. &lt;a className={className}/&gt; 因为class,和for是js关键字,所以在react中用className和htmlFor代替. 条件返回我们可以根据不同的条件返回不同的jsx. 1234567891011121314render()&#123; const isGood = true return ( &lt;div&gt; &lt;h1&gt; &#123; isGood ?&lt;strong&gt;isGood&lt;/strong&gt; :&lt;span&gt;is bad&lt;/span&gt; &#125; &lt;/h1&gt; &lt;/div&gt; )&#125; 如果你想要隐藏一个元素,返回一个null即可. jsx元素变量jsx元素就是js对象,那么jsx元素其实可以像js对象一样赋值给变量,作为函数参数传递或作为函数返回值. 12345678910111213141516171819202122232425//作为变量render()&#123; const isGood = true const good = &lt;strong&gt;isGood&lt;/strong&gt; const bad = &lt;span&gt;isBad&lt;/span&gt; return( &lt;div&gt; &lt;h1&gt; &#123;isGood?good:bad&#125; &lt;/h1&gt; &lt;/div&gt; )&#125;//作为函数参数传递renderGood(good,bad)&#123; const isGood = true return isGood?good:bad&#125;render()&#123; return( &lt;div&gt; &#123;this.renderGood(&lt;strong&gt;isGood&lt;/strong&gt;,&lt;span&gt;isBad&lt;/span&gt;)&#125; &lt;/div&gt; )&#125; 组件的组合,嵌套和组件树自定义的组件必须用大写字母开头,普通html标签用小写字母开头. 组件之间可以组合,嵌套.就像普通的html标签一样使用就可以,这样组合嵌套最后构成一个组件树,来表示它们之间的关系. 事件监听在react中监听事件甚至需要给监听的元素加上类似于onClick和onKeyDown这样的属性,紧跟的是一个表达式插入,这个表达式返回一个实例方法. 在react中不需要调用浏览器原生的addEventListener进行事件监听,react帮我们封装好了一系列的on*的属性,而且不用考虑不同浏览器之间的兼容问题.如果需要用到事件对象event,在函数中传入e参数即可,react把event对象也做了封装. 一般在某个类的实例方法中,this指的就是这个实例本身,但在react中,调用你传给它方法的时候,并不是通过对象方法的方式调用(this.handleclick),而是通过函数调用(handleClick),所以在事件监听函数中的this是null或undefined.当你想在函数中使用当前实例的时候,需要手动将实例方法bind到当前实例再传给react,这种方式在react中非常常见. 这些on*事件只能用在普通的html元素上,不能用在组件标签上 组件的state和setState一个组件的显示形态是由它的数据状态和配置参数决定的.一个组件可以拥有自己的状态,就像一个点赞按钮,有点赞状态和未点赞状态,并可以再这两种状态之间来回切换.state就是存储这种可变化的状态的.改变状态时不能直接赋值,可以使用setState方法来改变状态.当我们调用setState时,react会更新组件状态,重新调用render方法,然后再把render方法所渲染的最新内容显示到页面上.state方法接受一个对象或函数作为参数如果我们用this.state=XXX,React就没办法知道你修改了组件的状态. state接收对象参数12345678910constructor(props)&#123; super(props) this.state = &#123; name: 'tom', isLicked: false &#125;&#125;handleClick()&#123; this.setState(&#123;isLicked: !this.state.isLicked&#125;)&#125; state接收函数作为参数再调用setState时,react不会马上修改state,而是把这个对象放到一个更新队列中,稍后才回从多个队列中把新状态计算合并提取出来合并到state,再触发更新 12345678910111213141516171819//对象作为参数handClick()&#123; this.setState(&#123;count:0&#125;)//this.state.count还是undefinedthis.setState(&#123;count: this.state.count+1&#125;)//undefined+1=NaNthis.setState(&#123;count:this.state.count+2&#125;)//NaN+2=NaN&#125;//函数作为参数可以接受一个参数作为上次setState的返回值handClick()&#123; this.setState((prevState)=&gt;&#123; return &#123;count:0&#125;//0 &#125;) this.setState((prevState)=&gt;&#123; return &#123;count: prevState.count +1&#125;//0+1=1 &#125;) this.setState((prevState)=&gt;&#123; return &#123;count: prevState.count+2&#125;//1+2=3 &#125;)&#125;//进行3次setState,但组件只会渲染一次.因为react会把所有事件循环中的消息队列中的state合并再渲染. 配置组件的props一个组件可能在不同的地方用到,所以组件要有一定的可配置性.每个组件都可以接收一个props参数,他是一个对象,包含你对这个组件的配置. 组件内部是通过this.props的方式来获取组件的参数,如果this.props有需要的属性就采用,没有的话就默认. 再使用一个组件的时候,可以把参数放在标签中的属性中,所以属性都会作为props对象的键值. 默认配置defaultProps我们可以通过||操作符来实现默认配置,const word = this.props.like || &#39;已赞&#39;React也提供了一种方式defaultProps来配置默认配置. 12345678910class LikeBtn extends Component&#123; static defaultProps = &#123; like: '取消', unlike: '点赞' &#125; constructor()&#123; super() this.state = &#123;isLike: false&#125; &#125;&#125; props不可变props一旦传入进来就不能改变.如果我们使用this.props.like=&#39;取消&#39;控制台会直接报错. 你不能改变一个组件被渲染时传进来的props,因为如果渲染过程中可以改变会导致组件的显示形态和行为变得不可预测. 但这并不意味这props永远不能修改,组件的使用者可以主动的通过重新渲染的方式把新的props传入到组件中. 1234&lt;div&gt; &lt;LikeBtn like=&#123;this.state.like&#125;&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;button&gt; &lt;/div&gt; 在这里,我们把state中的数据传给props,但我们点击按钮时,我们使用setState改变state的值,并导致页面重新渲染,改变后的state会传给新的props. state VS propsstate的主要作用是用于组件保存,控制,修改自己的状态.state在组件内部初始化,可以被自身修改,但不能被外界访问和修改.可以把state当做一个局部的只能被自身控制的数据源.通过this.setState进行更新,该方法会导致组件重新渲染. props主要作用是可以传入参数来配置该组件,组件内部无法控制和修改,除非外部主动传入新的props,否则组件的props永远保持不变. 一个组件的state中的数据可以传给子组件的props,一个组件也可以使用外部传入的props来初始化自己的state.但他们职责非常清晰state是让组件控制自己的状态,props是让外部对组件自己进行配置,尽量少的用state,尽量多的使用props 无状态组件12345678const HelloWorld = (props)=&gt;&#123; const sayHi = (event)=&gt;&#123; alert(\"helloWorld\") &#125; return( &lt;div onClick=&#123;sayHi&#125;&gt;helloWorld&lt;/div&gt; )&#125; 以前的一个组件时通过继承Component来构建,一个子类就是一个组件,而用函数式编写方式是一个函数就是一个组件,你可以和之前使用使用该组件.不同的是,函数式组件只能接受props而无法和类组件一样在constructor里面初始化state.函数式组件就是一种只接受props和提供render方法的类组件. 渲染列表数据渲染存放jsx元素的数组1234567891011render()&#123; return( &lt;div&gt; &#123;[ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; ]&#125; &lt;/div&gt; )&#125; 如果你往{}里放一个数组,react会把数组中的元素依次渲染出来. 使用map渲染列表数据123456789101112131415161718192021222324252627282930313233343536373839const users = [ &#123;userName:'tom',age:21,gender:'male'&#125;, &#123;userName:'jerry',age:23,gender:'male'&#125;, &#123;userName:'lily',age:41,gender:'male'&#125;, &#123;userName:'lucy',age:31,gender:'male'&#125;,]render()&#123; const userEle = []//保存渲染后的jsx数组 for(let user of users)&#123; userEle.push( &lt;div&gt; &lt;span&gt;&#123;user.userName&#125;&lt;/span&gt; &lt;span&gt;&#123;user.age&#125;&lt;/span&gt; &lt;span&gt;&#123;user.gender&#125;&lt;/span&gt; &lt;/div&gt; ) &#125; return( &lt;div&gt;&#123;userEle&#125;&lt;/div&gt; )&#125;//但我们一般不会手动写循环来构建jsx结构,而是用es6 的map方法render()&#123; return( &lt;div&gt; &#123; users.map((user,index,arr)=&gt;&#123; return( &lt;div&gt; &lt;span&gt;&#123;&#123;user.userName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;user.age&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;user.gender&#125;&#125;&lt;/span&gt; &lt;/div&gt; ) &#125;) &#125; &lt;/div&gt; )&#125; 然后你会发现,react报错了,因为对于用表达式套数组罗列到页面上的元素,都要为每个元素加上key属性,这个key必须是每个元素的标识 状态提升在编写组件时,当有别的组件依赖或影响某个组件的某个状态state时,我们通常将这种组件之间共享的状态交给组件最近的公共父节点保管,然后通过props把状态传递给子组件,这样就可以在组件之间共享数据了.这种方式在React中被称为状态提升. 如果这个公共的分组件只是组件树下很小的一个子树,我们需要一直把状态提升上去,一旦发生提升,就需要修改原来保存状态以及传递数据的所有代码,这种无限制的提升并不是一个好的方案. 如何更好的管理被多喝组件依赖的状态?React并没有提供更好的解决方案,我们可以引入Redux状态管理工具来帮助我们解决这种共享状态.对于不会被外界依赖和影响的状态,一般只保存在组件内部即可,不需要做提升. 挂载阶段组件的生命周期我们来看看下面这段代码发生了什么 123456789101112ReactDOM.render( &lt;Header/&gt;, document.getElementById('root'))//1.实例化一个Headerconst header = new Header(props,children)//2.调用header.renderconst headerJsx = header.render()//3.构建真正的DOM元素const headerDom = createDOM(...)//4. 把DOM元素追加到页面上document.getElementById('root').appendChild(headerDOm) 上面这个过程称为组件的挂载,这是一个从无到有的过程 React为了更好的掌握组件的挂载过程,提供了一系列等生命周期函数.包括了两个挂载函数. componentWillMount和componentDIdMount.当我们在页面渲染后删除了某个元素后,也有对应的函数componentWillUnmount. 他们之间的顺序为 1. constructor (指向prototype对象所在的构造函数,关于组件自身状态的初始化) 2. component will mount (组件将要挂载,一般组件启动的动作,包括ajax数据的拉取,设置定时器等等在此进行) 3. render (返回jsx元素) 4. component did mount (组件已经挂载,当组件的启动工作依赖dom时,例如动画,就可以放在这里.) 5. component will unmount (组件将要移除,在组件销毁时清除该组件定时器和其他数据清理工作) 更新阶段的组件生命周期除了挂载阶段,还有一种更新阶段.setState导致react重新渲染组件就是一个组件的变化过程. shouldComponentUpdate(nextProps,nextState): 你可以通过这个方法控制组件是否重新渲染,如果返回false就不重新渲染,该生命周期在性能优化上非常有用. componentWillReceiveProps(nextProps):组件从父组件接收到新的props之前调用. componentWillUpdate():组件重新渲染之前调用. componentDIdUpdate():重新渲染后调用. ref 和 React 中的 DOM 操作React中我们很少和打交道,有一系列的on*方法帮我们进行事件监听,我们不再需要调用addEventListener的DOM API,我们通过setState重新渲染组件,渲染时把新的props传给子组件达到页面更新效果,而不再借用jQuery进行页面更新. 但React并不能满足所有的DOM操作,比如进入页面自动focus到某个输入框,.比如你想获取某个元素的尺寸在做后续动画等等.所以它提供了ref属性帮助我们获取已经挂在的dom节点,你可以给某个JSX元素加上ref属性. &lt;input ref={(input)=&gt;{this.input = input}}&gt; 我们给input加了一个ref属性,该属性是一个函数,该元素在页面上挂载完毕后调用这个函数,并把这个挂载后的dom节点传给这个函数.我们把元素赋值给组件实例的一个属性,这样就可以通过this.input获取这个DOM元素. 如果给组件挂载ref,那么我们获取的是这个组件在react内部初始化的实例,这并不常用,不建议这样做. props.children 和容器类组件1234567891011121314151617ReactDOM.render( &lt;Card&gt; &lt;h1&gt;I'm H1&lt;/h1&gt; &lt;div&gt;I'm Div&lt;/div&gt; &lt;/Card&gt;, document.getElementById('root'))class Card extends Component&#123; render()&#123; return&#123; &lt;div&gt; &#123;this.props.children&#125; &#123;this.props.children[0]&#125; &lt;/div&gt; &#125; &#125;&#125; 在使用自定义组件时,可以再组件内部嵌套jsx结构.嵌套的结构可以再组件内部通过props.children获取到,这种组件编写方式在编写容器类型的组件当中非常有用,而在实际React项目中,我们几乎每天都需要用这种方式编写组件. dangerouslySetHTML 和 style 属性#####dangerouslySetHTML 出于安全因素(XSS攻击),React会把所有表达式插入的内容都自动转义.类似于jQuery的text(). 12345const header = '&lt;h1&gt;helloWorld&lt;/h1&gt;'&lt;div&gt; &#123;header&#125; &lt;/div&gt;//因为react的自动转义,并不会渲染&lt;h1&gt;元素,而是显示文本形式 如何做到动态设置HTML效果呢?我们可以给元素设置一个dangerouslySetHTML属性传入一个对象,这个对象的__html属性值就相当于innerHTML,就可以动态渲染元素结构了. 1234&lt;div dangerouslySetHTML=&#123;&#123;__html:'&lt;h1&gt;helloworld&lt;/h1&gt;'&#125;&#125; className=\"container\"&gt;&lt;div&gt; 之所以搞这么复杂是因为设置这个属性可能会导致跨站脚本攻击,不必要的情况就不要使用. style普通DOM元素中的style 1&lt;div style=\"font-size:14px;color:red;\"&gt;&lt;div&gt; React中需要把css属性变为对象再传给元素 1&lt;h1 style=&#123;&#123;fontSize:'14px',color:'red'&#125;&#125;&gt;&lt;/h1&gt; style接收一个对象,里面是css属性键值对,原来css带’-‘的属性都需要换成驼峰命名法.我们可以用props或者state中的数据生成样式对象再传给元素,再用setState修改样式,非常灵活. 12&lt;h1 style=&#123;&#123;fontSize:'14px',color:this.state.color&#125;&#125;&gt;&lt;/h1&gt;this.setState(&#123;color:'blue'&#125;) PropTypes和组件参数验证React提供一种机制,可以给组件的配置参数加上类型验证.我们需要安装React提供的第三方库prop-types npminstall --save prop-types 12345678910import React,&#123; Component &#125; from 'react'import PropTypes from 'prop-types'class Card extends Component&#123; static propTypes = &#123; text: PropTypes.string.isRequired &#125;static defaultProps = &#123; ...&#125;&#125; PropTypes提供的参数有:array,bool,func,number,object,string,node,element… react规范组件和方法命名1. static开头的类属性,如`defaultProps`,`propTypes` 2. 构造函数,constructor 3. getter/setter 4. 组件生命周期 5. _开头的私有方法 6. 事件监听方法,handle** 7. render*()表示不同render()内容的函数 高阶组件高阶组件就是一个函数,传给它一个组件作为函数的参数,它返回一个新的组件. 1234567891011121314151617import React,&#123;Component&#125; from 'react'export default (OldComponent,name)=&gt;&#123; class NewComponent extends Component&#123; constructor()&#123; super() this.state = &#123;data:null&#125; &#125; componentWillMount()&#123; let data = localStorage.getItem(name) this.setState(&#123;data&#125;) &#125; render()&#123; return &lt;OldComponent data=&#123;this.state.data&#125;&gt;&lt;/OldComponent&gt; &#125; &#125; return NewComponent&#125; 怎么使用这个高阶组件呢? 12345678import NewComponent from './NewComponent'class InputName extends Component&#123; render()&#123; return &lt;input value=&#123;this.props.data&#125;&gt; &#125;&#125;InputName = NewComponent(InputName,'username')export default InputName 其实高阶组件就是为了组件之间的代码复用.组件可能有着相同的逻辑,把这些逻辑抽取出来,放在高阶组件里进行复用.高阶组件内部包装的组件和被包装的组件通过props传递数据. contextcontext(上下文)是React中一个比较特殊的东西.某个组件只要往自己的context里面放一些状态,这个组件下的所有子组件都可以直接访问而不用通过中间组件一层层传递,它的父组件则不能访问到. context打破了组件之间通过props传递数据的规范,增强了组件间的耦合性.就像全局变量一样,每个组件都能随意访问和修改,这会让程序运行不可预料. 一些第三方状态管理的库就是充分利用了这种机制给我们提供了极大地便利,所以我们一般不手写context,也不要用它,需要时用这些第三方的应用状态管理库即可. 本文参考胡子大哈的React小书,详情请点击","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端 React","slug":"前端-React","permalink":"http://yoursite.com/tags/前端-React/"}]},{"title":"用NodeJS写一个爬虫","slug":"用NodeJS写一个爬虫","date":"2016-12-05T07:45:03.000Z","updated":"2017-12-05T07:51:45.000Z","comments":true,"path":"2016/12/05/用NodeJS写一个爬虫/","link":"","permalink":"http://yoursite.com/2016/12/05/用NodeJS写一个爬虫/","excerpt":"","text":"简介用NodeJS下一个爬虫,用来获取简书首页的文章,然后保存以txt文件的形式保存在本地,数量为20篇. 初始化项目​ npm init || yarn init 安装依赖​ npm install superagent cheerio —save || yarn add superagent cheerio 页面数据下载123456789101112131415161718192021const fs = require(\"fs\")const request = require(\"superagent\")const cheerio = require(\"cheerio\")let reptileUrl = \"http://www.jianshu.com/\"request .get(reptileUrl) .end(function(err,res)&#123; if(err)&#123; &#125; else&#123; let $ = cheerio.load(res.text,&#123;decodeEntities:false&#125;) //每页有20篇文章,找到标题及其href的值 $(\"#list-container .note-list li\").each(function(index,value)&#123; let url = $(v).find(\".title\").attr(\"href\") //url即文章的链接,需要和reptileUrl拼接起来 getContent(url) &#125;) &#125; &#125;) 获取文章内容,保存在本地1234567891011121314151617181920212223242526272829303132function getContent(url)&#123; let adress = reptileUrl + url request .get(adress) .end(function(err,res)&#123; if(err)&#123; &#125;else&#123; let $ = cherrio.load(res.text,&#123;decodeEntities:false&#125;) //文章标题 let title = $(\".article .title\").text() //文章内容 let content = '' $(\".article .show-content p\").each(function(i, v, a) &#123; content += $(v).text(); &#125;) //要写入的数据 let data = &#123; title: title, content: content &#125; //本地保存 fs.writeFile('../data/' + title + '.txt', JSON.stringify(data), 'utf-8', function(err) &#123; if (err) &#123; &#125; else &#123; console.log(\"It's OK !\") &#125; &#125;) &#125; &#125;)&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"node 爬虫","slug":"node-爬虫","permalink":"http://yoursite.com/tags/node-爬虫/"}]},{"title":"鼓楼,什刹海随拍","slug":"鼓楼,什刹海随拍","date":"2016-10-13T10:19:50.000Z","updated":"2017-12-26T06:58:23.000Z","comments":true,"path":"2016/10/13/鼓楼,什刹海随拍/","link":"","permalink":"http://yoursite.com/2016/10/13/鼓楼,什刹海随拍/","excerpt":"","text":"","categories":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/categories/旅行/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/tags/旅行/"}]},{"title":"深入理解Git 工作流","slug":"深入理解Git-工作流","date":"2016-06-08T01:46:52.000Z","updated":"2018-06-08T01:52:43.000Z","comments":true,"path":"2016/06/08/深入理解Git-工作流/","link":"","permalink":"http://yoursite.com/2016/06/08/深入理解Git-工作流/","excerpt":"","text":"git 工作流集中式工作流集中式工作流以中央仓库作为项目所有修改的单点实体。相比SVN缺省的开发分支trunk，Git叫做master，所有修改提交到这个分支上。本工作流只用到master这一个分支。要发布修改到正式项目中，开发者要把本地master分支的修改『推』到中央仓库中。这相当于svn commit操作，但push操作会把所有还不在中央仓库的本地提交都推上去。 示例 初始化一个空仓库 git init --bare /XX.git 员工A和B克隆中央仓库 git clone /xxx.git A开发功能 Git status， Git add ， Git commit这些命令都是在本地提交，可以 反复操作多次，不用担心中央仓库。 B开发功能 Git status， Git add ， Git commit A 发布功能 git push origin master origin是 A 在科隆仓库时git创建的远程中央仓库别名。master参数告诉git推送的分支。 B 发布功能 git push origin master时 B的本地历史和中央仓库有分歧，提交失败。如果要避免这种情况，B要先 pull A的更新到他的本地仓库合并上他的本地修改，再push。 B在 A的提交之上 rebase。 B用 git pull 合并上游的修改到自己仓库，类似于SVN的 update。命令如下：git pull -rebase origin master。 –rebase告诉git 把B的提交移到中央仓库的master分支顶部。如果你忘记这个选项，pull仍然可以完成，但是每次pull操作要同步中央仓库中别人修改时，提交历史会以一个多余的’合并提交‘结尾。对于集中式工作流最好还是使用 –rebase 选项。 B解决合并冲突。执行git rebase —abort可以回到执行git pull —rebase之前的样子。 B成功发布功能。 git push origin master 功能分支工作流功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支去开发。这样可以把新功能集成到正式项目前，用pull Request 的方式讨论变更。功能分支应该有一个描述性的名字，比如animated-menu-items或issue-#1061，可以让分支有个清楚的用途。 示例 A在开发新功能之前，建立一个独立的分支。git checkout -b xxx master 这个命令检出一个基于 master 的名为xxx分支，git -b 选项表示如果不存在就新建分支。然后老规矩 git status/add/commit 去吃午饭前，push功能分支到中央仓库是很好的做法，方便备份和开发协作。git push -u origin xxx -u选项表示设置本地分支去跟踪远程对于的分支，设置以后，A就可以使用git push 省去指定推送分支的参数。 A回来之后，完成了整个功能的开发，在合并master之前，A发起了一个pull Request 让团队其他人知道功能已经完成。然后请求合并到master。 B收到pull Request 会查看XXX分支的修改，决定在合并到正式项目前是否还要修改，且通过pull Request和A进行讨论。 A 再次修改，编辑，暂存，提交并push到中央仓库，A的活动都会显示在pull Request上。B如果有需要也可以吧XXX分支拉到本地，自己修改，他的提交也会在pull Request上。 Git flow 工作流Gitflow工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。Gitflow工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。 历史分支Gitflow工作流使用2个分支来记录项目的历史。master分支存储了正式发布的历史，而develop分支作为功能的集成分支。 功能分支功能分支不是从master分支上拉出新分支，而是使用develop分支作为父分支。当新功能完成时，合并回develop分支。新功能提交应该从不直接与master分支交互。 发布分支一旦develop分支上有了做一次发布的，就从develop分支上fork一个发布分支。新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上。这个分支只应该做Bug修复、文档生成和其它面向发布任务。一旦对外发布的工作都完成了，发布分支合并到master分支并分配一个版本号打好Tag。另外，这些从新建发布分支以来的做的修改要合并回develop分支。常用的分支约定：用于新建发布分支的分支（develop），用于合并的分支（master），分支命名（relese-X或 relese/X） 维护分支维护分支或是热修复（hotfix）分支用于生成快速给产品发布版本打补丁，这是唯一可以从master分支fork出来的分支。修复完成，修改应该马上合并回master分支和develop分支（当前的发布分支），master分支应该用新的版本号打好Tag。 示例 创建开发分支。为master分支配套一个develop分支。简单来做可以本地创建一个空的develop分支，push到服务器上。git branch develop，git push -u origin develop,以后这个分支会包含项目的全部历史，而master分支只包含部分历史，其他开发者应该克隆中央仓库，建好develop分支跟踪分支。git clone XXX.git,git checkout -b develop origin/develop A 和 B 开始开发新功能。新分支应基于develop。git checkout -b xxx develop.然后 git status/add/commit… A完成功能开发，合并到他本地的develop分支后push到中央仓库。git pull origin develop,git checkout develop,git merge xxx,git push,git branch -d xxx A 开始准备发布，他用一个新的分支做发布准备，这一步也确定了发布的版本号。git checkout -b release-0.1 develop。这个分支是清理发布，执行测试，更新文档等用于改善发布的分支。 A 完成发布，一旦准备好对外发布，A合并并修改master分支和develop分支，删除发布分支。合并回develop分支很重要。发布分支是作为功能开发（develop）和对外发布（master）之间的缓冲。只要合并到master，就应该打好tag方便跟踪。 用户发现bug。 为了处理bug，A从master分支拉出一个维护分支，提交修改解决问题。然后直接合并到master分支，还有，这些信息需要包含到develop分支中。然后安全的删除这个维护分支。 forking工作流forking工作流是分布式工作流，充分利用 git 在分支上的优势,可以安全的管理可靠的开发者,并且可以接受不信任的贡献者的提交.这种工作流不是使用单个服务器的中央仓库代码基线,而是让每个开发者都有一个仓库.每个代码贡献者由两个Git 仓库,一个是本地私有的,另一个服务端公开的.Forking 的优势还有,不需要所有人都能 push代码到中央仓库中,开发者 push 到自己的服务端仓库,而只有项目维护者才能 push 到正式仓库.这也成为了开源项目的理想工作流. 工作方式和其他的 Git 工作流一样, Forking 工作流要先有一个公开的正式仓库存储在服务器上.但一个新的开发者想在项目上工作时,不是直接从正式仓库克隆,而是 fork 正式项目在服务器上创建一个拷贝.这个拷贝作为他个人公开仓库,其他开发者不允许 push 到这个仓库,但可以 pull 到修改.创建自己的服务器拷贝后就可以和往常一样执行 git clone 了.提交本地修改时, 提交到自己的公开仓库中,然后给正式仓库发起一个 pull request, 让项目维护者知道有新的集成了.维护者同意变更后会合并变更到自己本地的 master 中,然后 push master 分支到服务器的正式仓库中. 示例 开发者 fork 正式仓库 开发者克隆自己 fork 出来的仓库 相比用 origin 远程别名指向中央仓库, forking 需要2个远程别名,一个指向正式仓库,一个指向自己的服务端仓库.常见约定使用 origin 作为远程克隆的仓库别名, upstream 作为正式仓库的别名. 开发者开发自己的功能 开发者发布自己的功能 push 代码到自己的公开仓库,发起 pullRwquest 指定要合并的分支.一般是上游( upstream)的 master 分支 项目维护者集成开发者的功能 项目维护者收到 pull request, 他有两种方式,一是直接在 pull request 中查看代码,二是 pull 代码到自己的本地仓库,再手动合并.如果出现合并冲突,需要用第二种方式解决. 开发者和正式仓库做同步 由于正式仓库更新,其他开发需要和正式仓库同步,git pull upstream master. pull RequestPull Request 可以让开发者更方便的进行协作,可以再代码合并之前对修改进行讨论.如果变更有任何问题,团队成员反馈在 PR 中,所有的这些活动都直接跟踪在 PR 中. PR 需要提供4个信息以发起 pull Request: 源仓库,源分支,目的仓库,目的分支. PR 可以和以上的 git 工作流一起使用,基本过程是这样的: 开发者在本地仓库新建一个分支开发功能. 开发者 push 分支修改到公开的仓库中. 开发者通过公开的仓库发起一个 pull request 项目的其他成员 review code ,讨论并修改 项目维护者合并功能到官方仓库中并关闭 pull requset GIt Flow 插件的使用git flow 的简单介绍git flow 是构建在 git 之上的一个组织软件开发活动的模型,是在 Git 之上构建的一项软件开发最佳实践,也是一套使用 Git 进行源代码管理的一套行为规范和简化部分 git 操作的工具.总之, git flow 就是通过在一个项目里划分不同的分支,来实现功能开发, bug 修复,版本发布,以及代码冲突处理等. git flow 把分支划分了几个类别 Master (稳定无 BUG 发布版) Develop (功能开发最前线) Feature (为每一个新功能从 Develop 创建出来的分支) Hotfix (紧急修复 BUG) Release (版本发布,项目上线前的一些全面测试以及准备,同时也肩负版本归档,回滚支持) git flow 插件的常用命令(feature 版本) 切换到相应目录 cd .. 查看分支 git branch -a 切换到相应分支 git checkout develop 初始化 git flow init (-f) 新建分支 git flow feature start xxx develop(基于创建的分支) 发布分支 git flow feature publish 操作 git add . / git status / git commit -m “feat: XXX”/git push 结束分支 git flow feature finish XXX 取得一个发布的新特性分支 git flow feature pull origin XXX 跟踪在 origin 上的特性分支 git flow feature track XXX (release版本) 开始准备 release 版本 git flow release start RELESE [BASE 参数] 创建后发布 git flow release publish RELESE 签出远程变更 git flow release track RELESE 完成release 版本 git flow release finish RELEASE (hotfix 版本) 开始紧急修复 git flow hotfix start version [BASENAME 版本号] 完成紧急修复 git flow hotfix finish VERSION","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"[阮一峰ES6标准]学习笔记","slug":"阮一峰ES6标准-学习笔记","date":"2016-03-21T02:43:25.000Z","updated":"2017-12-21T02:47:11.000Z","comments":true,"path":"2016/03/21/阮一峰ES6标准-学习笔记/","link":"","permalink":"http://yoursite.com/2016/03/21/阮一峰ES6标准-学习笔记/","excerpt":"","text":"let let声明的变量只在代码块内有效 不存在变量提升 let声明变量之前,该变量都是不可用的,称为暂时性死区 相同作用域内不允许重复声明同一个变量 const const声明一个只读的常量,一旦声明,常量的值不能改变. const一旦声明变量,必须初始化,不赋值就会报错. const保证的其实是保存变量的内存地址不得改动.对于简单数据类型,值就保存在变量指向的内存地址,等同于常量.对于复合类型的数据,变量指向的地址保存的是一个指针. var和function声明的全局变量,是顶层对象的属性.而let,const,class声明的全局变量不再属于顶层对象. 变量的解构赋值从数组和对象中提取值,对变量进行赋值,这就称为解构. 12let [a,b,c] = [1,2,3];//a=1,b=2,c=3let [a,b,c] = [1,2] //解构不成功变量值为undefined 如果等号右边不是数组(或不是可遍历的解构),会报错. 1let [a] = false;//false不是可遍历解构,报错 解构赋值允许指定默认值 1let [a,b=666] = [1]//a=1,b=666 对象也可以用于解构赋值 1234567let &#123;foo,bar&#125; = &#123;foo:'a',bar:'b'&#125;;//foo='a',bar='b'//属性名相同才能取到值let &#123;foo,bar&#125; = &#123;foo:'a',baszz:'b'&#125;;//bar为undefined//&#123;foo&#125;其实就是&#123;foo:foo&#125;的简写let &#123;foo:bar&#125; = &#123;foo:'a'&#125;//bar='a',foo未定义//对象解构赋值也可以指定默认值let &#123;x,y=3&#125;=&#123;x:1&#125;//x=1,y=3 字符串也可用于解构赋值,因此此时,字符串被转换为一个类似数组的对象. 1let [a,b,c,d,e] = 'hello';//a='h',b='e' 函数的参数也可用于解构赋值. 1234function add([x,y=3])&#123; return x + y;&#125;add([1,2]); 字符串的扩展ES6为字符串添加了便利器接口,使得字符串可以被for…of循环遍历. ES5有indexOf用来确定一个字符串是否在另一个字符串中. ES6又提供了三种方法: includes():返回布尔值,表示是否找到了参数字符串 startsWith():返回布尔值,表示是否在原字符串的头部 endsWith():返回布尔值,表示是否在原字符串的尾部 这三个方法都提供了第二个参数,表示搜索的位置. 1234let s =\"hello World\"s.includes(\"hello\")//trues.startsWith(\"hel\")//trues.endsWith(\"rld\")//true repeat()方法返回一个新字符串,表示将元字符串重复n次. 1'hello'.repeat(2);//'hellohello' 模板字符串 12let s = 'world'let a = `hello $&#123;s&#125; !`//a='hello world !' ${}里面不仅可以嵌入变量,还可以嵌入函数. 数值的扩展 Number.isFinite()用来检查一个数值是否为有限的(finite) Number.isNaN()用来检查一个数值是否为NaN. 上面两个方法与传统的全局方法isFinite()和isNaN()的区别在于,传统方法会先调用Number()将非数值转换为数值在判断,新的两个方法只对数值有效,非数组一律返回false. Number.parseInt(); Number.parseFloat();将全局方法移植到Number对象上,使语言逐步模块化. Number.isInteger();用来判断一个值是否为整数. 指数运算符,例如2**3===8; 函数的扩展函数参数的默认值 123456789function log(x,y='world')&#123; console.log(x,y)&#125;log('hello')//hello world//参数是默认声明的,所以不能用let和const再次声明function foo(x=5)&#123; let x = 1;//error const x = 2;//error&#125; rest参数 ES6引入rest参数,用于获取函数的多余参数,rest参数搭配的变量是一个数组,该变量将多余的参数放入数组中.rest参数只能是最后一个参数,否则会报错. 12345678function(...values)&#123; let sum = 0; for(var val of values)&#123; sum += val; &#125; return sum;&#125;add(2,3,5)//10 函数的name属性返回该函数的函数名. 箭头函数 12var f = v=&gt; v;var f = ()=&gt;5;//没有参数或多个参数用()包括,多个函数语句用&#123;&#125; 箭头函数内的this是定义时所在的对象,不是使用时的对象 不可以当做构造函数 不可以使用arguments对象 不可以使用yield命令,不能作为Generator函数 箭头函数中的this的指向是固定的,不可变的. 尾调用就是在函数的最后一步调用另外一个函数. 尾递归函数在最后一步调用自身就是尾递归.尾递归不会发生栈溢出,相对节省内存. 1234function factorrial(n,total)&#123; if(n === 1) return total; return factorial(n-1,n*total)&#125; 函数式编程有一个概念,叫做柯里化,意思就是将多参数的函数转换成单参数的函数形式. 数组的扩展扩展运算符是三个点....它好比rest参数的逆运算,将一个数组转为用逗号分隔的参数序列. 1console.log(...[1,2,3])//1 2 3 由于扩展运算符可以展开数组,所以不再需要apply方法将数组转为函数的函数了. 12345678//ES5function f(x,y,z)&#123;...&#125;var args = [1,2,3]f.apply(null,args)//ES6function f(x,y,z)&#123;...&#125;let args = [1,2,3]f(...args) 扩展运算符的应用 复制数组 12345//ES5const a1 = [1,2,3]const a2 = a1.concat();//ES6cionst a2 = [...a1] 合并数组 1234//ES5arr1.concat(arr2,arr3)//ES6[...arr1,...arr2,...arr3] 字符串转为数组 1[...\"hello\"]//['h','e','l','l','o'] 只要是有Iterator接口的对象都可以用扩展运算符转为数组. Array.from()将类似数组的对象和可遍历对象转换为真正的数组. 扩展运算符转换为数组调用的是遍历器接口Iterator,Array.from()不仅可以支持可遍历对象还支持类似数组的对象,既任何拥有length属性的对象都可以通过Array.from转换为数组,而扩展运算符不行. 12345let arrayLike = &#123;'0':'a','1':'b',length:2&#125;//ES5var arr1 = [].slice.call(arrayLike)//ES6let arr2 = Array.from(arrayLike) Array.of()用于将一组值转换为数组.因为Array()和new Array(),由于参数不同导致行为不统一.一个参数指定数组的长度,不少于两个才能组成新数组,这样会导致行为有差异.Array.of()基本可以替代Array()和new Array(). 1Array.of(1,2,3);//[1,2,3] find()用于找出第一个符合条件的数组成员.他的第一个参数是一个回调函数,所有成员依次执行该函数,直到找到第一个为true的成员,没有找到返回undefined.该回调函数一个接受3个参数,分别是value,index,arr. 1234[1,4,-5,10].find((n)=&gt;&#123;n&lt;0&#125;)//-5[1,4,-5,10].find(function(v,i,a)&#123; return value &gt; 9&#125;)//10 findIndex()与find()用法类似,用于找出符合条件成员的索引,都不符合返回-1.由于数组的IndexOf方法无法识别数组的NaN成员,而find和findIndex弥补了数组indexOf的不足. 123[1,4,-5,10].findIndex(function(v,i,a)&#123; return value === 4;//1&#125;) fill()填充一个数组.接受第二和第三个参数分别为起始位置和结束位置之前. 1['a','b','c'].fill(7,1,2)//['a',7,'c'] entries(),keys(),values()都返回一个遍历器对象,可以用for…of进行遍历.entries()是对键值对的遍历,keys()是对键名的遍历,values()是对值得遍历. 123for(let index of ['a','b'].keys())&#123; console.log(index);//0 //1&#125; 数组的includes()返回一个布尔值表示数组是否包含给定的值,与字符串的includes()方法类似.另外Map和Set数据结构有一个has方法,需要注意与includes区分.Map的has用来查找key,Set的has用来查找value. 1[1,2,3].includes(3)//true 对象的扩展属性的简写形式 123var foo = &#123;x:x,y:y&#125;;//等同于let foo = &#123;x,y&#125; 属性名表达式 ES6允许字面量定义对象时,用表达式作为对象的属性名. 123456let name = 'foo'let obj = &#123; [name]: 'foo', ['a'+'bc']: 123&#125;//&#123;foo:'foo','abc':123&#125; Object.is()用来比较两个值是否严格相等,与===行为基本一致.不同之处在于+0不等于-0,NaN等于NaN 1234+0 === -0;//trueObject.is(+0,-0)//falseNaN === NaN;//falseObject.is(NaN,NaN);//true Object.assign()用于对象合并,将源对象所有可枚举属性复制到目标对象. 如果只有一个参数,直接返回该对象. 同名属性,后者会覆盖前者 Object.assign方法实行的是浅拷贝.如果某个属性的值是对象,那么目标对象拷贝的是这个对象的引用. Object.assign的用途. 为对象添加属性 为对象添加方法(将函数放在空对象中) 克隆对象(和一个空对象合并) Object.setPrototypeOf()设置一个对象的prototype对象,返回参数对象本身,它是ES6整数推荐的设置原型对象的方法. 1234let a = &#123;a:1&#125;let proto = &#123;b: 2&#125;Object.setPrototypeOf(a,proto);//a.b === 2//上面代码将proto对象设置为a对象的原型 Object.getPrototypeOf()用于读取一个对象的原型对象. 1Object.getPrototypeOf(a);//&#123;b:2&#125; super关键字指向当前对象的原型对象. Object.keys()返回一个数组,成员是对象所有可遍历属性的键名. Object.values()返回一个数组,成员是对象所有可遍历属性的值. Object.entries()返回一个数组,成员是对象所有可遍历属性的键值对数组. 对象也可用于解构赋值以及扩展运算符 1234let &#123;x,...y&#125; = &#123;x:1,y:2,z:3&#125;x // 1y// &#123;y:2,z:3&#125;let z = &#123;...y&#125;//&#123;y:2,z:3&#125; Null传导运算符?. 123const first = (msg &amp;&amp; msg.body&amp;&amp;msg.body.user || 'default')//使用null传导运算符const first = (msg?.body?.user || 'default') SymbolES6引入了一种原始数据类型Symbol,表示独一无二的值.它是js第七种数据类型,分别是undefined,null,Boolean,String,Number,Object,Symbol 由于symbol不是对象,而是数据类型,所以不能使用new,他是一种类似于字符串的的数据类型. 12345let s = Symbol();let s1 = Symbol();s === s1;//false,Symbol不能参与运算.let obj = &#123;&#125;;obj[s] = 'hello'//Symbol作为属性名不能用.运算形式,且不能被遍历到 Set和MapES6提供了新的数据结构Set,它类似于数组,但是成员都是唯一的,没有重复的值. 12//去除数组的重复成员[...new Set(2,3,2,1,2,3)] Set,prototype.constructor: 构造函数,默认就是Set函数 Set.prototype.size: 返回set实例的成员总数 Set的4个操作方法 add(value): 添加某个值,返回set结构本身 delete(value):删除某个值,返回一个布尔值,表示是否成功 has(value): 返回一个布尔值,表示是否为Set成员. clear():清除所有成员. Set的4个遍历方法 keys():返回键名的遍历器 values():返回值得遍历器(默认遍历生成函数) entries():返回键值对的遍历器 forEach():使用回调函数遍历每个成员 ES6提供了Map数据类型,类似于对象,但他的”键”的范围不限于字符串,各种类型的值都可以作为键. Map的实例属性与操作方法: size: Map结构的成员总数 set(key,value):设置键值,返回整个结构 get(key): 读取某个键的值,找不到key返回undefined has(key):返回布尔值,表示某个键是否在当前Map对象中 delete(key):删除某个键,返回布尔值表示是否成功. clear():清除所有. Map结构提供的遍历方法与Set相同. promise对象promise是异步编程的一种解决方案.它接受一个函数作为参数,函数有两个参数resolve和reject有js引擎提供,resolve函数将promise有未完成变为成功,reject由未完成变为失败. promise实例生成后可以用then指定resolved和rejected状态的回调函数,并且then返回一个新的promise实例,所以可以链式调用. 12345678910111213const promise = new Promise(function(resolve,reject)&#123; if(/*成功*/)&#123; resolve(value) &#125;else&#123; reject(error) &#125;&#125;)promise.then(function(value)&#123; //success&#125;,function(error)&#123; //error&#125;)//一般来说,不要再then中定义rejected状态的回调函数,既then的第二个参数,而应该总是使用catch方法. promise.catch是.then(null,rejection)的别名,指定发生错误是的回调函数. promise.all将多个promise实例包装成一个promise实例.全部成功才成功,有一个失败就是失败. promise.race将多个promise包装为一个,只要其中有一个先改变状态,整个状态就会改变. promise.finally方法用于指定不管promise的最后状态无论怎样都会执行,它接受一个普通的回调函数作为参数,不管怎样都必须执行. Iterator和for…of循环当使用for…of循环某种数据结构时,该循环会自动寻找Iterator接口. 一个对象只要具备Symbol.iterator属性就代表该对象可遍历. 默认调用Iterator接口的场合: 解构赋值let [x,y] = [1,2] 扩展运算符[...arr] yield后面如果跟的是可遍历结构就会调用遍历器接口`yield\\ [2,3,4]` for…of,Array.from()… 遍历器对象除了具有next()函数,还要return()和throw() for..of与其他遍历语法比较. for循环 数组的forEach(无法跳出循环,break,return都不行) for …in(主要是循环对象而设计,不适用于遍历数组) for…of,与for..in一样简洁,可以跳出循环… Generator函数Generator是ES6题提供的异步编程解决方案.可以把它理解为一个状态机,封装了多个状态.还是一个遍历器对象生成函数. Generator函数的特征:function与函数名之间有一个*号,函数体内部使用yield表达式定义不同的内部状态. 12345678910function* helloWorld()&#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorld();//generator函数调用后该函数并不执行,返回的也不是函数运行结果,而是遍历器对象Iterator.然后调用遍历器对象的next方法使得指针移动到下一个状态.hw.next();//&#123;value:'hello',done:fasle&#125;hw.next();//&#123;value:'world',done:false&#125;hw.next();//&#123;value:'ending',done:true&#125; 由于Generator函数返回一个遍历器对象,调用next才会遍历下一个内部状态,所以其实他是一个可以暂停执行的函数,yield就是暂停标志.next()遇到yield就会暂停后面的操作,并把yield后面表达式的值作为返回的value值,下一次调用next,再继续执行,知道遇到yield或return为止.另外yield表达式在其他地方使用都会报错. next()可以带一个参数,作为上一次yield表达式的返回值. 12345678910111213function* foo(x)&#123; var y = 2*(yield (x+1)); var z = yield (y/3); return (x+y+z);&#125;var a = foo(5);a.next();//&#123;value:6,done:fasle&#125;a.next();//&#123;value:NaN,done:fasle&#125;a.next();//&#123;value:NaN,done:fasle&#125;var b = foo(5);b.next();//&#123;value:6,done:fasle&#125;b.next(12);//&#123;value:8,done:fasle&#125;b.next(13);//&#123;value:42,done:fasle&#125; for…of可以自动遍历Generator函数生成的遍历器对象,并且不再需要调用next方法.但函数return 的值不会再循环中. 在Generator函数中调用Generator函数是没有效果的,这就需要用到yield*表达式,用来达成以上目的.并且任何数据结构只要有Iterator接口,就可以使用yield*遍历 123456function* bar()&#123; yield 'a'; yield* foo(); yield 'b'; yield* [1,2,3]&#125; async函数ES6引入了async函数,使异步操作更加方便.async函数就是Generator函数的语法糖.它将*替换成async,将yield替换成await,仅此而已. 12345678910111213const gen = function* ()&#123; cosnt f1 = yield readFile('/etc/a.txt') const f2 = yield readFile('/etc/b.txt') console.log(f1.toString()); console.log(f2.toString());&#125;const gen = async function()&#123; const f1 = await readFile('/etc/a.txt') const f2 = await readFile('/etc/b.txt') console.log(f1.toString()); console.log(f2.toString());&#125; async对generator的改进 内置执行器.async函数的执行与普通函数一样gen() 更好的语义.比起*与yield,语义更清楚. 更广的适用性.async函数的await命令后面可以是promise对象和原始类型的值(但此时等同于同步操作). 返回值是promise对象,而generator返回的是一个Iterator遍历器.而async可以看做多个异步操作包装的promise对象,而await命令就是内部then的语法糖. async函数内部return语句返回的值会成为then方法回调函数的参数 1234async function f()&#123; return 'helloWorld'&#125;f().then(v=&gt;console,log(v))//'helloWorld' async函数内部抛出错误会导致promise对象变为reject状态.错误对象会被catch方法回调函数接收. 正常情况下await后面是一个peomise对象,如果不是,会转成一个立即resolve的promise for await of 用来遍历异步的iterator接口. classES6引入class的概念,作为对象的模板,通过class关键字来定义类. class其实只是一个语法糖,他的大部分功能ES5都可以做到,只是让对象原型的写法更像面向对象编程语法而已. 123456789101112131415161718192021//ES5function Point (x,y)&#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function()&#123; return this.x+','+this.y&#125;var p = new Point(1,2)//ES6class Point&#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; toString()&#123; return this.x+','+this.y &#125;&#125;Point === Point.prototype.constructor//truevar p = new Point(); toString是Point类内部定义的方法,它是不可枚举的,这与ES5不一致. 类不存在变量提升 class的静态方法,类相当于实例的原型,所有类中定义的方法都会被实例继承,如果在一个方法前加上static关键字就表示该方法不会被实例继承,而是直接通过类来调用,这就成为静态方法.静态方法中的this指的是类而不是实例. 12345678class Foo()&#123; static hello()&#123; return 'helloWorld' &#125;&#125;Foo.hello()//'helloWorld'var h = new Foo();h.hello()//报错typeError... 父的静态方法可以被子类继承 123456789101112131415161718192021class Foo()&#123; constructor(x,y)&#123; &#125; static hello()&#123; return 'helloWorld' &#125; toString()&#123; ... &#125;&#125;class Bar extends Foo()&#123; constructor(x,y,z)&#123; super(x,y)//调用父类的constructor(x,y) this.z = z; &#125; toString()&#123; return this.z +','+super.toString &#125;&#125;Bar.hello()//'helloWorld' super关键字表示父类的构造函数,用来新建父类的this对象. 子类必须在constructor方法中调用super方法,否则新建实例会报错,这是因为子类没有自己的this对象而是继承父类的this对象,然后对其加工,不调用super()子类就得不到this对象. 如果子类没有定义constructor,这个方法会被默认添加,super也会默认添加.只要调用super才能使用this关键字. 修饰器修饰器函数用来修改类的行为,是对一个类进行处理的函数,修饰器函数的第一个参数就是说要修身的目标类.如果觉得一个参数不够用,可以再修饰器外再封装一层函数. 123456789@testableclass MyTest()&#123; ...&#125; function testable(target)&#123; target.isTest = true;//静态属性 target.prototype.isOk = false;//实例属性 &#125; MyTest.isTest // true 修饰器实在代码编译时发生的,这意味着修饰器本质就是编译时执行的函数. Moduleexport 用于规定模块的对外接口. 1234567export var a = 'a'export var b = 'b'export &#123;a,b&#125;export default&#123; a, b&#125; import 用于输入其他模块提供的功能. 123import &#123;a,b&#125; from './xxx'import a as A from './xxx'import * as num from './xxx' 如果import要取代Node的require方法就形成了障碍,因为require是运行时加载模块,而import无法取代require的动态加载功能.CommonJS输出的是一个值得拷贝,而ES6模块输出的是值得引用. 浏览器加载ES6模块,也使用&lt;script&gt;,但要加入type=’module’属性告诉浏览器这是一个ES6模块. 1&lt;script type=\"module\" src=\"./foo.js\"&gt;&lt;/script&gt;","categories":[],"tags":[]},{"title":"深圳大梅沙看海","slug":"深圳大梅沙看海","date":"2015-10-29T06:18:00.000Z","updated":"2017-12-26T06:30:29.000Z","comments":true,"path":"2015/10/29/深圳大梅沙看海/","link":"","permalink":"http://yoursite.com/2015/10/29/深圳大梅沙看海/","excerpt":"","text":"昨日风和日丽,携友出行,至大梅沙海滨公园,拍数照以作留念.","categories":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/categories/旅行/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/tags/旅行/"}]},{"title":"重温<<计算机操作系统>>","slug":"重温-计算机操作系统","date":"2015-10-18T07:19:25.000Z","updated":"2017-11-14T06:02:28.000Z","comments":true,"path":"2015/10/18/重温-计算机操作系统/","link":"","permalink":"http://yoursite.com/2015/10/18/重温-计算机操作系统/","excerpt":"","text":"并发与并行概念并行是指两个或多个事件在同一时刻发生,而并发是两个或多个事件在同一时间间隔内发生.在多道程序环境下,并发性是指在一段时间内宏观上有多个程序在同时运行,但在单处理机系统中,每一时刻却仅能有一道程序执行,故微观上这些程序只能是分时的交替执行.倘若在多处理机,这些可以并发执行的程序便可分配到多个处理机上,实现并行执行. 理解如果某个系统支持两个或多个动作同时存在,name这个系统就是一个并发系统.如果某个系统支持两个或多个动作同时执行,那么这个系统就是一个并行系统.并发系统与并行系统这两个定义之间的关键差异在于存在这个词. 在并发程序中可以同时拥有两个或多个线程,这意味着,如果程序在单核处理器上运行,那么这两个线程将交替换入或换出内存.这些线程是同时存在的,每个线程都处于执行过程中的某个状态.如果程序能够并行执行,那么就一定是运行在多核处理器上的.此时,程序中的每个线程都将分配到一个独立的处理器核上,因此可以同时运行. 我相信你已经能够得出结论:”并行概念是并发概念的一个子集”.也就是说,你可以编写一个拥有多个线程或进程的并发程序,但如果没有多核处理器来执行这个程序,那么就不能以并行的方式来运行代码.因此,凡是在求解单个问题涉及多个执行流程的编程模式或执行行为,都属于并发编程的范畴. 摘自:&lt;&lt;并发的艺术&gt;&gt;-[美]布雷谢斯 Erlang 之父 Joe Armstrong 用一张5岁小孩都能看懂的图解释了并发与并行的区别.从图中可以看出,并发是两个队列交替使用一台咖啡机,并行是两个队列同时使用两台咖啡机.如果串行,一个队列使用一台咖啡机.并发和并行都可以是多个线程,就看这些线程能不能同时被多个CPU执行,如果可以说明是并行,而并发是多个线程被一个CPU轮流切换着执行. 进程与线程概念对进程较为经典的定义有: 1. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动. 2. 进程是程序在一个数据集合上运行的过程,它是系统进行资源分配和调度的一个独立单位. 3. 系统为每个进程定义了一个数据结构-进程控制块(PCB).OS根据PCB来对并发执行的进程进行控制和管理. 线程和进程的比较: 1. 再引入线程的操作系统中,通常一个进程都拥有若干个线程,至少有一个线程. 2. 进程为资源拥有的最小单位,而线程作为调度和分派的基本单位,线程不拥有系统资源,可以访问资源. 理解进程和线程的主要差别在于他们是不同的操作系统资源的管理方式.进程有独立的地址空间,一个进程崩溃后,在保护模式下不会对其他进程产生影响,而线程只是一个进程中的不同执行路径.线程有自己的堆栈和局部变量,但线程没有单独的地址空间,一个线程死掉就等于整个进程死掉,所以在进程切换时,耗费资源较大,效率变差.但对于一些要求同时进行并且又要共享某些变量的并发操作,只能用进程,不能用线程. 生产者消费者问题概念生产者消费者问题是一个经典的多进程同步问题,也叫缓存绑定问题. 既有两个进程:一组生产者进程和一组消费者进程共享一个初始值为空固定大小为n的缓存区.生产者的工作是制造一段数据,只要缓存没满就放入缓存区,否则必须等待,如此反复.同时,只要缓存区不为空,消费者才能从中取出消息,一个取出一段数据,否则只能等待.由于缓存区是临界资源,它只允许一个生产者放入消息,或一个消费者从中取出消息. 问题的核心是要保证不让生产者在缓存满的时候还要向内写数据,不让消费者试图从空的缓存中取出数据. 理解生产者和消费者对缓存区互斥访问是互斥关系,同时又是相互协作关系,即同步关系.那么需要解决的是互斥和同步PV操作的位置.使用”进程间通信”即可解决唤醒问题: 我们使用了两个信号标:full和empty.信号量mutex作为互斥信号量.用于控制互斥访问缓存池,互斥信号量初始值为1.信号量full用于记录当前缓冲池中”满”缓冲区数,初始值为0.信号量empty用于记录当前缓存区”空”缓存区数,初始值为n.新的数据增加后,full增加,empty减少.如果生产和试图在empty为0时减少其值,生产者就会被”催眠”.下一轮中有数据消费掉时,empty就会增加,生产者就会被”唤醒”.1234567891011121314151617181920212223semaphore mutex = 1;//临界区互斥信号量semaphore empty = n;//空闲缓存区semaphore full = 1;//缓存区初始化为空produce()&#123; while(1)&#123; produce an item in dextp;//生产数据 P(empty);//获取空缓存区单元 P(mutex);//进入临界区 add nextp to buffer;//将数据放入缓存区 V(mutex);//离开临界区,释放互斥信号量 V(full)//满缓存区加1 &#125;&#125;consume()&#123; while(1)&#123; P(full);//获取满缓存区单元 P(mutex);//进入临界区 remove an item from buffer;//拿走数据 V(mutex);//离开临界区 V(empty);//空缓存区单元加1 consume the item//消费数据 &#125;&#125;","categories":[{"name":"理解计算机","slug":"理解计算机","permalink":"http://yoursite.com/categories/理解计算机/"}],"tags":[{"name":"计算机基础 操作系统","slug":"计算机基础-操作系统","permalink":"http://yoursite.com/tags/计算机基础-操作系统/"}]}]}